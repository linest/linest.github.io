<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Redis | Blog of Linest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="REmote DIctionary Server 远程目录服务 默认端口 6379 特点  内存KV存储 redis相比memcached  value更强大，支持复杂类型，并且value上限达到1GB 速度更快 支持持久化 支持集群  高性能  高并发，低延迟，每秒万级别处理性能10w/s  内存, 内存访问速度100ns以内 C语言，更近底层 单线程，避免竞争加锁和线程切换 非阻塞IO，多路复">
<meta property="og:type" content="website">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://linest.github.io/tmp/db-redis.html">
<meta property="og:site_name" content="Blog of Linest">
<meta property="og:description" content="REmote DIctionary Server 远程目录服务 默认端口 6379 特点  内存KV存储 redis相比memcached  value更强大，支持复杂类型，并且value上限达到1GB 速度更快 支持持久化 支持集群  高性能  高并发，低延迟，每秒万级别处理性能10w/s  内存, 内存访问速度100ns以内 C语言，更近底层 单线程，避免竞争加锁和线程切换 非阻塞IO，多路复">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-04-10T04:11:36.208Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis">
<meta name="twitter:description" content="REmote DIctionary Server 远程目录服务 默认端口 6379 特点  内存KV存储 redis相比memcached  value更强大，支持复杂类型，并且value上限达到1GB 速度更快 支持持久化 支持集群  高性能  高并发，低延迟，每秒万级别处理性能10w/s  内存, 内存访问速度100ns以内 C语言，更近底层 单线程，避免竞争加锁和线程切换 非阻塞IO，多路复">
  
    <link rel="alternative" href="/atom.xml" title="Blog of Linest" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/fonts/octicons/octicons.css">
  <link rel="stylesheet" href="/css/fonts/font-awesome-4.6.3/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Linest</a></h1>
		</hgroup>

		
		<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/doodle">涂鸦</a></li>
				        
							<li><a href="/live2d">云撸猫</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tagcloud">标签&amp;分类</a></li>
				        
						</ul>
					</nav>	
				</section>
				
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">勤奋的懒惰者
爱听故事的人~
Zjuer
</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Linest</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Linest</h1>
			</hgroup>
			
			<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/doodle">涂鸦</a></li>
		        
					<li><a href="/live2d">云撸猫</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tagcloud">标签&amp;分类</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/tmp/db-redis.html" class="article-date">
  	<time datetime="2020-04-10T04:11:36.208Z" itemprop="datePublished">2020-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>REmote DIctionary Server 远程目录服务<br>
默认端口 6379</p>
<h1 id="特点">特点</h1>
<hr>
<p>内存KV存储<br>
redis相比memcached</p>
<ul>
<li>value更强大，支持复杂类型，并且value上限达到1GB</li>
<li>速度更快</li>
<li>支持持久化</li>
<li>支持集群</li>
</ul>
<h1 id="高性能">高性能</h1>
<hr>
<p>高并发，低延迟，每秒万级别处理性能10w/s</p>
<ul>
<li>内存, 内存访问速度100ns以内</li>
<li>C语言，更近底层</li>
<li>单线程，避免竞争加锁和线程切换</li>
<li>非阻塞IO，多路复用</li>
</ul>
<h1 id="单线程模型">单线程模型</h1>
<hr>
<p>内部使用文件事件处理器file event handler是单线程的<br>
IO多路复用，同时监听多个socket, 事件进入队列，依次处理，因此要求能快速执行，避免影响</p>
<h1 id="通讯协议">通讯协议</h1>
<hr>
<p>RESP(Redis Serialization Protocol) Redis序列化协议<br>
文本协议，虽然浪费流量但是直观</p>
<h1 id="redis结构">Redis结构</h1>
<hr>
<p>RedisObject描述一个value</p>
<ul>
<li>type: 类型</li>
<li>encoding: 实现类型</li>
<li>ptr: 指向实际存储</li>
<li>lru: 最后访问时间</li>
<li>refcount: 引用计数，内存对象共享，节约内存空间</li>
</ul>
<p>RedisDb描述整个库</p>
<ul>
<li>dict: 维护key和值对象的字典</li>
<li>expires: 维护key和过期时间的字典</li>
</ul>
<p>SDS(Simple Dynamic String)描述简单动态字符串，预分配一定空间，记录实际长度</p>
<ul>
<li>free：空闲长度</li>
<li>len：数据已占长度</li>
<li>buf: 指向分配的空间</li>
</ul>
<p><a href="https://blog.csdn.net/qq_35433716/article/details/85042094" target="_blank" rel="noopener">https://blog.csdn.net/qq_35433716/article/details/85042094</a></p>
<h1 id="类型">类型</h1>
<hr>
<p>暴露在外的接口，内部有多种类型实现<br>
object encoding命令查询键的内部实现类型<br>
总共有6中类型，8种实现</p>
<h2 id="string">string</h2>
<p>根据长度决定内部格式,不超过512M</p>
<ul>
<li>int：8字节的数字类型</li>
<li>embstr：不大于39字节，sds和redis对象一次连续分配，只读，修改将转化为raw类型</li>
<li>raw：大于39字节，sds和redis对象不连续，两次分配</li>
</ul>
<h2 id="hash">hash</h2>
<p>map结构</p>
<ul>
<li>ziplist：个数小于512，每个值都小于64字节，key和value连续存储，数据多时性能下降</li>
<li>hashtable：稀疏结构，内存占用大，MurmurHash2，链表解决哈希冲突</li>
</ul>
<h2 id="list">list</h2>
<p>可双端操作</p>
<ul>
<li>ziplist：数量少且数据小时，连续内存空间，随机访问好</li>
<li>linkedlist：链表，增删效率高</li>
<li>quicklist：3.2版本，linkedlist分段，每一段采用ziplist，结合优势</li>
</ul>
<h2 id="set">set</h2>
<p>集合</p>
<ul>
<li>intset：都是整数且小于512个</li>
<li>hashtable：key为元素，值为null</li>
</ul>
<h2 id="zset">zset</h2>
<p>有序集合，附带分值,涉及排序时间单次复杂度多为O(logn)</p>
<ul>
<li>ziplist：个数少于128并且大小不超过64字节，数据和分值连续存储，按分值由小到大排列</li>
<li>skiplist：除了跳表外还维护哈希结构，可以查数据对应分值</li>
</ul>
<h1 id="操作">操作</h1>
<hr>
<h2 id="增删改查">增删改查</h2>
<ul>
<li>string: get/set/del</li>
<li>hash: h前缀</li>
<li>list：l前缀</li>
<li>set：s前缀</li>
<li>zset：z前缀</li>
</ul>
<h2 id="类型特有">类型特有</h2>
<ul>
<li>string: strlen</li>
<li>hash:</li>
<li>list:
<ul>
<li>lindex 遍历，复杂度O(n)，两端性能好，中间性能差</li>
<li>blpop,brpop，阻塞式弹出，附带timeout值，有数据可以弹出就立刻返回，否则等待一段时间，timeout为0就无限等待，直到有数据, 可以多个键一起，直到任意一个有数据</li>
</ul>
</li>
<li>set:
<ul>
<li>sadd，可添加多个，返回新增个数，因为可能部分数据已存在</li>
<li>srem，可删除对个，返回删除个数，因为可能部分数据不存在</li>
<li>scard，计数操作，读取内部维护的变量，不会遍历，复杂度O(1)</li>
<li>srandmember，随机返回指定个数</li>
<li>spop，随机弹出一个</li>
<li>sinter，sunion，sdiff，集合交并补可以将结果保存在一个键中</li>
</ul>
</li>
<li>zset:
<ul>
<li>zadd，选项ch添加后数据和分值变化的个数</li>
<li>zrank和zrevrank，正负向排名，排名从0开始记</li>
<li>zrange，范围查询，指定排名范围</li>
<li>zrangebyscore，范围查询，指定分数范围</li>
</ul>
</li>
</ul>
<h2 id="key遍历">key遍历</h2>
<ul>
<li>
<p>keys<br>
keys命令全量遍历，长时间阻塞，只有确定key数量很少或者只有一个人使用时才适合调用</p>
</li>
<li>
<p>scan<br>
渐进式，多次，需要客户端配合去重，总时间更长</p>
</li>
</ul>
<p>每次返回游标值，下次继续遍历。开始时游标为0，之后如果再次为0说明遍历结束<br>
非锁定，如果同时有增删改，那么遍历结果可能重复可能不全</p>
<p>底层原理和Java的HashMap类似，数组+链表，每次返回游标就是数组索引<br>
limit是每次扫描数组元素个数。由于每个数组元素挂载的数量不同，因此每次扫描返回数量不同<br>
游标递增顺序是高位增加,即反序-增加-再反序: 0(00),2(10),1(01),3(11)<br>
之所以采用这种顺序，是为了应对扩容和缩容时，减少重复扫描<br>
为了不阻塞，采用维护新旧两表，渐进式容量变化，因此扫描时可能会同时访问旧表和新表</p>
<ul>
<li>sscan,hscan,zscan<br>
遍历集合中元素，道理一样，返回小部分数据避免全返回时间过长<br>
smembers,hgetall,zrange</li>
</ul>
<h2 id="维护命令">维护命令</h2>
<ul>
<li>info 查看使用状况</li>
<li>info clients 可查看连接数量</li>
<li>config set可以修改配置，不用重启</li>
<li>config get maxclients 最大连接数</li>
<li>ping 测试联通性</li>
<li>设置密码：config set requirepass 123456</li>
<li>授权密码：auth 123456</li>
</ul>
<h1 id="慢查询">慢查询</h1>
<hr>
<p><code>slowlog</code>命令获取最近的n条慢查询，结构为(id,时间戳，执行时间，命令内容)<br>
记录命令执行时间，不算网络传输时间和命令排队时间,有助于排查性能瓶颈<br>
内部列表维护，可以配置容量，以及超过多少秒算慢，默认<code>slowlog-max-len</code>128容量和<code>slowlog-log-slower-than</code>10ms,建议1ms对应QPS1000,扩大容量并slow get定期持久化到硬盘</p>
<h1 id="pipeline">Pipeline</h1>
<hr>
<p>命令真正的执行时间通常在微秒级，但是网络延迟可能在毫秒级，影响很大<br>
很多命令没有批处理，可以自定义把多条命令打包，一起发往服务端提升效率<br>
原生批处理针对同一个key并且原子操作，pipeline打包的操作间无关联非原子<br>
Pipeline虽然可以减少传输开销，但还是要控制大小，否则容易造成网络拥塞</p>
<p>redis-cli通过pipe参数可以高效大量插入</p>
<h1 id="简单事务">简单事务</h1>
<hr>
<p>multi-&gt; … -&gt;exec/discard<br>
multi命令后开了一个队列，后续命令在队列中，执行时连续排他执行</p>
<ul>
<li>命令语法错误，比如拼写,事务不执行</li>
<li>命令操作错误，比如使用不正确的类型操作，不能回滚<br>
事务是在exec时才开始执行，不是开启multi后直接执行</li>
</ul>
<h2 id="watch机制">watch机制</h2>
<p>事务开始multi前可以进行watch观察变量，如果变化了事务不会执行，乐观锁机制<br>
底层维护watched_keys数据结构，watch一个key,会把客户端加入这个key的链表<br>
Redis单线程，事务是串行的，一个事务执行后会从watch链表中删除自身客户端并且标记其他客户端CLIENT_DIRTY_CAS，其他客户端到exec时就会放弃执行</p>
<h1 id="注意事项">注意事项</h1>
<hr>
<p>习惯</p>
<ul>
<li>
<p>没有命名空间，需要合理命名键，“业务名：对象名：id：属性”</p>
</li>
<li>
<p>危险命令，可以通过rename配置禁用掉</p>
<ul>
<li>keys 遍历所有键，复杂度O(n)，线上大量数据时避免使用</li>
<li>flushdb/flushall删除当前库或所有库数据，危险命令</li>
<li>config客户端修改配置</li>
</ul>
</li>
<li>
<p>dbsize 不遍历计算，而是内部维护统计，复杂度O(1)</p>
</li>
<li>
<p>mset和mget批量操作效率更高，减少多次操作网络开销，但是要注意</p>
</li>
<li>
<p>hsacn，sscan渐进式，优于lrange,smembers,hgetall数据量大可能阻塞</p>
</li>
<li>
<p>rename重命名可能导致删除旧键，对应值数据大会阻塞</p>
</li>
</ul>
<h1 id="内存管理">内存管理</h1>
<hr>
<h2 id="swap机制">swap机制</h2>
<p>key一直保存在内存中，但是value不一定，可以被放入磁盘。因此Redis可以保持超过自身内存大小的数据。</p>
<h2 id="过期机制与内存回收">过期机制与内存回收</h2>
<p>过期设置</p>
<ul>
<li>persist: 永久有效</li>
<li>expire: 指定时间长度后过期，expireat指定时间戳过期，两者底层都是pexpireat毫秒级实现</li>
</ul>
<p>ttl查询过期时间，单位秒，pttl可以毫秒</p>
<ul>
<li>非负数：键过期时间</li>
<li>-1：键没设置过期时间</li>
<li>-2：键不存在</li>
</ul>
<p>过期后不是立刻释放</p>
<ul>
<li>惰性删除：过期不管，下次访问key时检查并删除</li>
<li>定期删除：每隔100ms随机抽查带有过期时间的key，不是全删</li>
</ul>
<p>上述不能保证清除，而内存是有限的，可能会写满达到设置的最大内存上限(比如config set maxmemory 2gb)<br>
内存满时写操作失败，但是读操作可以，触发淘汰策略，即没空间写考虑释放一些空间</p>
<ul>
<li>noeviction： 默认，不回收，直接报错</li>
<li>allkeys-lru： 最常用，所有key都参与的LRU</li>
<li>volatile-lru：会过期的key参与的LRU</li>
<li>allkeys-random: 所有key随机</li>
<li>volatile-random: 会过期的key随机</li>
<li>volatile-ttl: 会过期的key中具有最短存活时间</li>
</ul>
<p>LRU实现<br>
RedisObject有个字段叫lru，每次访问，记录时间戳<br>
Redis采取近似实现，旧算法每次选5个key，比较挑出最老的，新算法维护一个容量16的池，移除时舍弃最老的，新增时如果在池范围内，替换最新的</p>
<h1 id="持久化">持久化</h1>
<hr>
<p>定期异步保存到磁盘</p>
<ul>
<li>
<p>RDB(Redis DataBase)：时间间隔快照<br>
save命令启动会进行大IO，阻塞业务，一般使用bgsave会Fork子进程处理<br>
子进程和父进程初始共享内存数据，父进程数据变化时COW(Copy On Write)分离，减少内存分配<br>
子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉</p>
</li>
<li>
<p>AOF(Append-Only File)：操作后记录日志，恢复时重放<br>
随时间推移，日志可能会非常大<br>
bgrewriteaof可以异步重写文件，进行优化，减少文件大小<br>
fsync异步每秒刷盘，如果磁盘很忙，异步fsync超过2秒还没完成，为了数据安全会阻塞等待</p>
</li>
</ul>
<p>取舍<br>
如果可以容忍数分钟以内的数据丢失，只使用RDB即可满足，恢复速度快<br>
两种可以同时开启，也可以都关闭即数据丢失也无所谓</p>
<h1 id="响应时间长原因">响应时间长原因</h1>
<hr>
<ul>
<li>网络原因，到达redis就慢</li>
<li>内存交换，受查询本身影响，内存不够换到磁盘</li>
<li>队列阻塞，受其他查询影响，到达redis后排队，前面有重量操作</li>
<li>持久化，受其他功能影响，fork进程，aof刷盘等待</li>
</ul>
<h1 id="应用">应用</h1>
<hr>
<h2 id="分布式锁">分布式锁</h2>
<p>加锁SETNX 不存在才设值，由于是单线程模型，因此多个请求只有一个能执行<br>
解锁使用DEL,删除记录</p>
<p>为了避免加锁后挂掉导致无法放锁，需要关联过期时间<br>
使用SET key value EX 10 NX在一行命令里进行设值和过期操作</p>
<p>为了解锁时判定来源避免把别人的锁放掉，可以用value值存一些标识<br>
因为if判断和DEL是两个操作，为了保证原子性，可以使用Lua脚本</p>
<p>局限性</p>
<ul>
<li>Redis实现的分布式锁主要强调性能，可靠性和安全性上可能有隐患<br>
主从模式下，由于异步复制，可能丢失一部分数据，分布式锁是不安全的<br>
多集群下，RedLock算法，获取当前时间戳，顺序向多个master加锁, 过半成功并且总时间没超时认为加锁成功。好处是防止了单点故障，坏处是需要多个集群，各集群时钟不统一造成过期释放时间不一致问题</li>
<li>没有通知机制，没加到锁的线程需要不断轮询尝试</li>
</ul>
<p>Redisson实现</p>
<ul>
<li>watchdog机制，默认锁30s过期,加锁后开启后端线程，每10s延期一次</li>
<li>采取hash结构，考虑到重入情况，除了标识外还增加计数逻辑</li>
</ul>
<h2 id="令牌桶">令牌桶</h2>
<p><a href="https://blog.csdn.net/sunlihuo/article/details/79700225" target="_blank" rel="noopener">https://blog.csdn.net/sunlihuo/article/details/79700225</a><br>
记录时间戳，取时更新令牌数，redis本身的单线程模型配合Lua脚本保证原子性</p>
<ul>
<li>如果有令牌，直接取</li>
<li>如果没令牌，尝试更新令牌数，当前时间与上次时间更新时间差值除以生成间隔</li>
</ul>
<h2 id="滑动窗口">滑动窗口</h2>
<p>利用zset 每次操作，加入key value 当前时间戳作为score<br>
利用zremrangeByScore删除分值0到(当前时间-窗口)之间的数据，即把非窗口范围内的删除，然后统计剩余个数</p>
<h2 id="消息队列">消息队列</h2>
<p>lpush+brpop,产出端的阻塞队列</p>
<h2 id="延时队列">延时队列</h2>
<p>zset，用时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理</p>
<h2 id="发布订阅">发布订阅</h2>
<p>实现产生一次消费多次Pub/Sub<br>
publish  subcribe</p>
<p>局限：</p>
<ul>
<li>在消费者下线的情况下，生产的消息会丢失</li>
<li>集群模式下，pub会发送给每个节点，消耗带宽严重</li>
</ul>
<h2 id="有限集合">有限集合</h2>
<p>lpush+ltrim</p>
<h2 id="抽奖">抽奖</h2>
<p>spop/srandmember</p>
<h2 id="排行榜">排行榜</h2>
<p>zadd上榜+zincrby增加分值+zrevrangebyrank反向排名</p>
<h2 id="计数器">计数器</h2>
<p>incr,decr,incrby,decrby,incrbyfloat 由于是单线程模型，完全不需要同步机制比如CAS</p>
<h2 id="大量统计不同元素">大量统计不同元素</h2>
<p>场景：元素数量非常多，需要求不同的元素有多少<br>
不会完整的存储下来，而是基于估算，模糊计数，估算有一定误差<br>
pfadd，pfcount，HyperLogLog结构底层类似位图机制，最多占用12K空间，原理进行哈希，记录开头最长的连续0进行估算</p>
<h2 id="任务跟踪">任务跟踪</h2>
<p>zadd 增加任务<br>
zrem 成功执行后删除<br>
周期zrangeByScore，找出延迟任务</p>
<h1 id="主从备份">主从备份</h1>
<hr>
<p>主从是异步复制最终一致，因此会有丢失<br>
从节点除了备份功能还可以分担读操作压力, 从节点默认不接受任何读写请求，会重定向到相应主节点<br>
客户端访问从节点，readonly命令开启只读模式，如果槽是自己维护则返回，否则还要重定向。命令是连接级，每次建立连接后丢失<br>
实现读写分离，客户端要维护一份主从关系，遇到读时主动选择从节点建立readonly连接</p>
<h2 id="流程">流程</h2>
<p>完整同步，适合初次同步</p>
<ol>
<li>从机发送Psync</li>
<li>主机发送runID和偏移</li>
<li>主机生成RDB并发送</li>
<li>生成RDB过程中还有新数据写入到复制缓冲区，发送</li>
</ol>
<p>部分同步，适合短期断开后恢复</p>
<ol>
<li>从机发送Psync，携带runID和偏移量</li>
<li>主机判断缺失数据是否还在缓冲区，如果在直接发，不在说明错过太多，需要再生成RDB</li>
</ol>
<p>主从之间还有定期心跳，也会发送偏移量用于同步数据</p>
<h2 id="哨兵">哨兵</h2>
<p>高可用，Sentinel哨兵节点，自动故障发现，故障转移，并同时通知应用方，避免故障时人工参与</p>
<p>哨兵节点也是Redis节点,但是不存数据，功能有限<br>
整个机制，只是增加了哨兵节点，没有对数据节点进行更改<br>
哨兵节点还充当配置提供者，客户端先通过哨兵获取主从节点信息，然后再去连接进行操作</p>
<ol>
<li>哨兵节点监控数据节点和其他哨兵节点，发现不可达就标记下线</li>
<li>如果主节点不可达，就询问其他哨兵，如果大多数一致认为不可达，选出一个哨兵领导完成故障转移</li>
<li>哨兵选择（断开时间，优先级，复制偏移量等因素）一个从节点slave of no one提升为新的主节点，其他节点重设主节点</li>
</ol>
<p>quorum</p>
<ul>
<li>判断不可达所需票数</li>
<li>选举参与数，至少要有max(quorum，sentinel/2 + 1)的哨兵参与，也就是说至少过半</li>
</ul>
<p>注意事项</p>
<ul>
<li>避免将所有哨兵部署在一台物理机</li>
<li>应部署至少三个并且奇数个哨兵</li>
</ul>
<p>监控原理<br>
哨兵每隔10s对数据节点发送info命令，获取拓扑</p>
<ul>
<li>可以从主节点获取从节点信息</li>
<li>感知新从节点加入</li>
<li>故障转移后，更新新拓扑</li>
</ul>
<p>哨兵每隔2秒对主节点hello频道上发送状态判断和自身信息，并订阅</p>
<ul>
<li>获取其他哨兵信息</li>
<li>了解其他哨兵判断</li>
</ul>
<p>哨兵每隔1s对其余节点发送ping心跳,判断是否可达</p>
<h2 id="主从方案">主从方案</h2>
<ul>
<li>Redis Master-Slave + Keepalived + VIP<br>
Keepalived检测主机，发现挂掉后转移虚拟ip到从机，并且人工操作提升从机为新的主机，客户端无需改变</li>
<li>Redis Master-Slave + DNS Service + Sentinel<br>
切换时哨兵调用notification-script修改DNS</li>
<li>Redis Master-Slave + Configure Center（Zookeeper） + Sentinel<br>
切换时哨兵调用notification-script修改配置中心</li>
</ul>
<h1 id="集群">集群</h1>
<hr>
<p>3.0 Redis Cluster<br>
单一节点无法承受时，把数据分散存储，单一节点只存部分数据</p>
<p>其他方案</p>
<ul>
<li>客户端分区方案，代码逻辑决定读写哪个redis节点，缺点实现复杂考虑点多，自行维护路由，高可用故障转移</li>
<li>代理方案，Twemproxy或Codis，请求发给代理，代理根据一致性哈希决定读写哪个redis节点，缺点节点数量变化后数据无法自动迁移，适合单纯的缓存丢失不敏感</li>
</ul>
<p><a href="https://www.cnblogs.com/junneyang/p/5899850.html" target="_blank" rel="noopener">https://www.cnblogs.com/junneyang/p/5899850.html</a></p>
<h2 id="虚拟槽">虚拟槽</h2>
<p>虚拟槽哈希 slot=CRC16(key)&amp;16383 即先循环冗余散列再范围取余<br>
如果key包含大括号，则对括号内部分进行哈希，否则以整个key进行哈希, 大括号hash tag机制增加了可控性，可以人为的使不同key分到相同槽<br>
从槽计算公式可以看出集群支持最大节点数16384(2^14)，即一台机器一个槽</p>
<p>槽数量考量</p>
<ul>
<li>功能上足够：集群节点数应该不会超过1000个节点(过多节点gossip通信效率下降)，即使1000个节点每个节点可以分16个槽，槽位足够分</li>
<li>性能上更优：不采取更大的2^16次方65536个槽，考虑到节点会记录自己负责哪些槽，采取位图方式，位图信息会发给其他节点
<ul>
<li>全量大： 16384个槽全量位图是2KB，而65536全量8KB</li>
<li>压缩率低： 节点数少的情况下，每台机器负责槽数量多，位图填充比较满，压缩率下降</li>
</ul>
</li>
</ul>
<p>没有采用一致性哈希，一致性哈希基于算法对于数据分布即节点控制，难以操控<br>
虚拟槽哈希把数据映射到槽，槽在机器上怎么分布由用户设定人工干预，不会自动分配和迁移，因此集群的高可用依赖于主从</p>
<h2 id="节点通信">节点通信</h2>
<p>节点专门单独使用一个端口建立TCP连接通信，检测在线，交换信息</p>
<p>通信场景</p>
<ul>
<li>meet-pong：新节点加入</li>
<li>ping-pong：携带节点自身槽数据(约2KB)和节点总量十分之一的其他节点状态信息(10个节点约1KB)
<ul>
<li>每秒随机挑5个节点，从中选出最久没通信的节点发送ping, Gossip</li>
<li>每100毫秒扫描已知节点，如果距离上次通信已经过半超时时间，发送ping</li>
</ul>
</li>
<li>pong广播，自身信息更新，主动广播</li>
<li>fail广播，判定其他下线，发起广播</li>
</ul>
<p>单节点ping每秒发送量为<code>1 + 10*num(node.pong_received &gt; cluster_node_timeout/2)</code><br>
超时默认15秒，调节超时时间短，发送量大，超时时间长影响故障发现，需要权衡带宽<br>
同时节点数也会影响带宽，能满足业务情况下，采用小集群更好</p>
<h2 id="请求路由">请求路由</h2>
<ul>
<li>
<p>Dummy客户端<br>
节点收到请求，计算对应的槽是否自己负责，如果其他节点负责，返回客户端重定向MOVED，重新发起请求</p>
</li>
<li>
<p>Smart客户端<br>
重定向机制开销大，客户端本地也维护一份槽映射关系，直接请求目标节点</p>
</li>
</ul>
<ol>
<li>根据本地映射发起请求</li>
<li>如果槽正在在线迁移，返回ASK, 客户端根据返回的地址再次发起请求</li>
<li>如果槽没命中，返回MOVED, 客户端cluster slots更新映射后，再次发起请求</li>
</ol>
<h2 id="集群功能限制">集群功能限制</h2>
<ul>
<li>批量操作只支持相同槽的key，即不能跨机</li>
<li>事务仅支持同机key</li>
<li>不能把key所对应的value分散到多台机器</li>
<li>单机可支持16个空间，集群模式下不支持多数据库空间，只能db0</li>
<li>从节点只能复制主节点，不能树状复制</li>
</ul>
<h2 id="查询多个key">查询多个key</h2>
<p>无底洞问题：需要查询集群多个key，多次网络交互<br>
根据场景选择</p>
<ul>
<li>依次查询：最简单，key多的话延迟严重</li>
<li>相同槽查询：客户端组织，每次批量查一个槽
<ul>
<li>依次每个槽mget查询，node多也比较慢</li>
<li>多线程mget查询，编程复杂</li>
</ul>
</li>
<li>数据安排：提前把要一起查的业务数据根据hash_tag存储在同一槽上，业务维护复杂，数据易倾斜</li>
</ul>
<h2 id="集群构建">集群构建</h2>
<p>需要主从，否则节点挂掉整个集群会拒绝服务，推荐至少6台机器3主3从<br>
redis本身很轻量，占用空间1M，因此即使数据量不大，一开始就以集群方式运行，能更好处理后期扩展</p>
<p>手动创建需要节点握手和分配哈希槽和从节点设定过程，也可使用redis-trib.rb脚本快速创建</p>
<ul>
<li>
<p>节点握手<br>
各个节点单独启动，启动后是孤立的不知道其他节点，客户端通过连接一个集群节点然后发起cluster meet新节点<br>
使得建立联系开始交换数据，把新节点加入集群, Gossip协议类似流言传播的方式传播元数据，使得集群其他节点感知到新节点加入</p>
</li>
<li>
<p>分配哈希槽<br>
节点建立连接后还不能工作，需要分配哈希槽，通过cluster addslots命令<br>
任何一个槽没有机器可用，整个集群拒绝服务。可以关闭cluster-require-full-coverage</p>
</li>
<li>
<p>从节点设定<br>
分配到槽的节点是主节点，新加入集群的节点也默认是主节点，手动cluster replicate设置节点作为从节点</p>
</li>
</ul>
<h2 id="集群伸缩">集群伸缩</h2>
<p>节点伸缩，槽和数据迁移，数据再平衡</p>
<h2 id="数据倾斜">数据倾斜</h2>
<ul>
<li>
<p>存储倾斜：特定节点数据量大</p>
<ul>
<li>big key：单一String过大或者集合元素过多100w的集合需要1秒操作，redis-cli-bigkeys检查，拆分成多个kv</li>
<li>槽内key太多：cluster countkeysinslot查看槽内key数量，cluster getkeysinslot遍历检查是否存在hash tag</li>
<li>节点槽分配不均：redis-trib.rb info查看槽分布，运维调整 redis-trib.rb rebalance</li>
</ul>
</li>
<li>
<p>查询倾斜：hot key 查询集中在特定节点</p>
<ul>
<li>副本分散：范围内随机数后缀，比如分成16份，请求压力分散到不同后缀，查询时先带随机后缀查，查不到再查原key并生成随机后缀key，随机后缀过期时间由原key加随机值，避免同时失效</li>
<li>本地缓存：客户端本地缓存一份，降低集群访问</li>
</ul>
</li>
</ul>
<h2 id="故障转移">故障转移</h2>
<ol>
<li>节点定期向其他节点ping-pong, 更新最后访问时间</li>
<li>节点定期检测，如果最后访问距今超过cluster-node-timeout, 标记为主观下线pfail</li>
<li>状态传播，收到的节点将状态加入故障链表，标记下线状态的有效期为超时时间的2倍，过期失效，防止误报</li>
<li>统计信息，半数以上主节点都标记某个节点主观下线，认为客观下线fail</li>
<li>状态传播，通知从节点进行故障转移</li>
</ol>
<h1 id="性能优化">性能优化</h1>
<hr>
<h2 id="减少内存使用">减少内存使用</h2>
<p>多个独立kv可以放入集合更紧凑存储<br>
每个键值对有一套内存结构，数量多就会占空间，而放入集合只使用一个键值对结构<br>
比如100w简单字符串键值对100M，而使用hash结构放到一个key内只用16M</p>
<h2 id="利用多核">利用多核</h2>
<p>启动多实例，taskset将每个实例绑定不同内核</p>
<h2 id="主从架构">主从架构</h2>
<ul>
<li>Master最好不做持久化，数据重要的情况下Slave开启AOF</li>
<li>主从最好部署在同一局域网，提升速度</li>
<li>不采用树状结构，采用链表 Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3，优点是主机挂掉后架构不用变</li>
</ul>
<h1 id="框架">框架</h1>
<hr>
<ul>
<li>Jedis：
<ul>
<li>全面支持命令</li>
<li>同步阻塞IO, 线程不安全，需要配合连接池</li>
</ul>
</li>
<li>Redisson：
<ul>
<li>功能简单，只支持集合不支持字符串操作，不支持排序、事务、管道、分区等Redis特性，更专注于高级的分布式协调, 提供各种完备工具Bloom filter，BitSet，锁等</li>
<li>基于Netty，异步非阻塞IO，线程安全</li>
</ul>
</li>
</ul>

        
    <div class="donate_module">
        <div id="donate_board" class="donate_bar">
            <br>
            <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
        </div>
        <div id="donate_guide" class="donate_bar hidden">
            <br>
            <a href="/assets/reward/wechat_code.jpg"  class="fancybox">
                <img src="/assets/reward/wechat_code.jpg" title="微信打赏" height="190px" width="auto"/>
            </a>
            <span class="donate_space"></span>
            <a href="/assets/reward/alipay_code.jpg"  class="fancybox">
                <img src="/assets/reward/alipay_code.jpg" title="支付宝打赏" height="190px" width="auto"/>
            </a>
        </div>
        <span class="donate_txt">一分也是爱~</span> 
    </div>

        <div class="breakword">
    <hr>
    <p><strong>版权声明</strong></p>
    <p><img src="/assets/copyright/cc.png" alt=""></p>
    <p><a href="http://linest.github.io/tmp/db-redis.html">This site</a> by <a href="mailto:xlinest@gmail.com">Linest</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.
    <br>由<a href="mailto:xlinest@gmail.com">Linest</a>创作并维护的博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
    <p>本文永久链接：<a href="http://linest.github.io/tmp/db-redis.html">http://linest.github.io/tmp/db-redis.html</a></p>
</div>
      
    </div>
    
  </div>
  
    
  
</article>
<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Linest
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> customized by <a href="#">Linest</a> with <span class="octicon octicon-heart" style="color:red"></span>
				</div>
				<div class="hide">
						<a href="https://clustrmaps.com/site/x7rd" title="Visit tracker"><img src="//clustrmaps.com/map_v2.png?cl=ffffff&w=70&t=n&d=trdgmMc8YDC9aFR4WIBOzfE8f6bNwx_Pq7HA9YiG3sA" /></a>
				</div>
    </div>
  </div>
</footer>

    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true
	}
</script>

<!-- Baidu auto push -->
<script>
(function(){
	var bp = document.createElement('script');
	var curProtocol = window.location.protocol.split(':')[0];
	if (curProtocol === 'https') {
		bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	}
	else {
		bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	}
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(bp, s);
})();
</script>

<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



  </div>
<script>!function(i){var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function r(t,e){var n=new Image,i=t.getAttribute("data-original");n.onload=function(){t.src=i,e&&e()},n.src=i}function t(){for(var t=0;t<o.length;t++)e=o[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(i.innerHeight||document.documentElement.clientHeight)&&r(o[t],function(){o.splice(t,t)});var e,n}t(),i.addEventListener("scroll",t)}(this);</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>