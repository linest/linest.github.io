<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Java NIO | Blog of Linest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java1.4引入NIO(New I/O) Java7引入NIO.2(AIO) 传统IO是面向流(stream-oriented)，字节传输 NIO是面向块(block-oriented)，利用数据块缓冲 Channel与Buffer  低级I/O管道，面向字节，不同于Stream区分读写,Channel是双向的 发送端缓冲-&amp;gt;发送端channel-&amp;gt;传输-&amp;gt;接收端channel">
<meta property="og:type" content="website">
<meta property="og:title" content="Java NIO">
<meta property="og:url" content="http://linest.github.io/tmp/java-nio.html">
<meta property="og:site_name" content="Blog of Linest">
<meta property="og:description" content="Java1.4引入NIO(New I/O) Java7引入NIO.2(AIO) 传统IO是面向流(stream-oriented)，字节传输 NIO是面向块(block-oriented)，利用数据块缓冲 Channel与Buffer  低级I/O管道，面向字节，不同于Stream区分读写,Channel是双向的 发送端缓冲-&amp;gt;发送端channel-&amp;gt;传输-&amp;gt;接收端channel">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-02-25T16:55:43.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java NIO">
<meta name="twitter:description" content="Java1.4引入NIO(New I/O) Java7引入NIO.2(AIO) 传统IO是面向流(stream-oriented)，字节传输 NIO是面向块(block-oriented)，利用数据块缓冲 Channel与Buffer  低级I/O管道，面向字节，不同于Stream区分读写,Channel是双向的 发送端缓冲-&amp;gt;发送端channel-&amp;gt;传输-&amp;gt;接收端channel">
  
    <link rel="alternative" href="/atom.xml" title="Blog of Linest" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/fonts/octicons/octicons.css">
  <link rel="stylesheet" href="/css/fonts/font-awesome-4.6.3/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Linest</a></h1>
		</hgroup>

		
		<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/doodle">涂鸦</a></li>
				        
							<li><a href="/live2d">云撸猫</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tagcloud">标签&amp;分类</a></li>
				        
						</ul>
					</nav>	
				</section>
				
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">勤奋的懒惰者
爱听故事的人~
Zjuer
</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Linest</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Linest</h1>
			</hgroup>
			
			<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/doodle">涂鸦</a></li>
		        
					<li><a href="/live2d">云撸猫</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tagcloud">标签&amp;分类</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/tmp/java-nio.html" class="article-date">
  	<time datetime="2020-02-25T16:55:43.729Z" itemprop="datePublished">2020-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java NIO
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java1.4引入NIO(New I/O) Java7引入NIO.2(AIO)</p>
<p>传统IO是面向流(stream-oriented)，字节传输<br>
NIO是面向块(block-oriented)，利用数据块缓冲</p>
<h1 id="channel与buffer">Channel与Buffer</h1>
<hr>
<p>低级I/O管道，面向字节，不同于<code>Stream</code>区分读写,<code>Channel</code>是双向的<br>
发送端缓冲-&gt;发送端channel-&gt;传输-&gt;接收端channel-&gt;接收端缓冲</p>
<p>缓冲区是通道发送和接收的容器，在字节基础上包装提供操作视图，每种原生类型都有，比如<code>CharBuffer</code>,<code>DoubleBuffer</code>等</p>
<p>使用FileChannel读写文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">FileChannel readChannel = fis.getChannel();</span><br><span class="line">FileChannel writeChannel = fos.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    buffer.clear();</span><br><span class="line">    <span class="keyword">int</span> len = readChannel.read(buffer);  <span class="comment">//由管道读取到缓存中</span></span><br><span class="line">    <span class="keyword">if</span>(len == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    writeChannel.write(buffer);  <span class="comment">//由缓存写入管道</span></span><br><span class="line">&#125;</span><br><span class="line">readChannel.close();</span><br><span class="line">writeChannel.close();</span><br></pre></td></tr></table></figure>
<ul>
<li>FileChannel: 文件IO</li>
<li>DatagramChannel: UDP</li>
<li>SocketChannel/ServerSocketChannel: TCP</li>
</ul>
<h1 id="向量i-o">向量I/O</h1>
<hr>
<p>普通IO和单一缓冲交互，向量IO支持和一组缓冲按顺序交互<br>
<code>FileChannel</code>就支持向量，实现了<code>GatheringByteChannel</code>和<code>ScatteringByteChannel</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span> <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">SeekableByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向量交互便于实现结构化数据处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer [] scatterBuffers = &#123; header, colorMap, imageBody &#125;;</span><br><span class="line">fileChannel.read (scatterBuffers);</span><br></pre></td></tr></table></figure>
<h1 id="文件内存映射">文件内存映射</h1>
<hr>
<p>文件映射到内存，程序直接和内存交互，操作系统负责内存磁盘间同步<br>
所使用的内存是堆外内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">FileChannel fc = fis.getChannel();</span><br><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, (<span class="keyword">int</span>) fc.size());</span><br></pre></td></tr></table></figure>
<p>可以加载更大的文件<br>
可以作为高速共享内存<br>
操作系统负责，即使程序崩溃也不受影响。但是断电等意外可能操作系统没来得及写入磁盘造成数据丢失</p>
<p>释放问题，仅仅close是不够的，内存的释放方法在gc的finalize时才执行的一个private方法，实效不能保证<br>
如果影响后续逻辑，需要显式书写释放代码作为临时解决方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cleaner cleaner = ((sun.nio.ch.DirectBuffer) buffer).cleaner();</span><br><span class="line"><span class="keyword">if</span> (cleaner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cleaner.clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件拷贝">文件拷贝</h1>
<hr>
<p>涉及多个缓冲区操作<br>
Read Buffer 内核读缓冲区<br>
Socket Buffer 内核Socket缓冲<br>
NIC Buffer 网卡缓冲<br>
Application Buffer 用户缓冲</p>
<p>java.nio.fle.Files.copy提供的文件拷贝依然是用户态拷贝<br>
拷贝流程为先读再写<br>
普通基于流</p>
<ol>
<li>用户态发起read系统调用</li>
<li>内核空间请求硬件数据DMA（direct memory access）</li>
<li>数据加载到内核缓存区Read Buffer（第一次拷贝 hardware -&gt; kernel）</li>
<li>内核复制数据到用户缓冲区Application Buffer（第二次拷贝 kernel -&gt; user）</li>
<li>用户态逻辑处理</li>
<li>用户态发起write系统调用</li>
<li>数据复制到内核socket缓冲区Socket Buffer（第三次拷贝 user -&gt; socket）</li>
<li>内核DMA写入数据到设备缓冲区NIC Buffer（第四次拷贝 socket -&gt; hardware）</li>
<li>返回用户态<br>
读写过程存在4次切换，4次数据拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备-&gt;内核缓冲-&gt;应用缓冲-&gt;内核缓冲-&gt;设备</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByStream</span><span class="params">(File source, File des)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(des);)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bufer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = is.read(bufer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                os.write(bufer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NIO中的拷贝可以避免不必要的拷贝和切换，效率更高<br>
零拷贝发送流程</p>
<ol>
<li>用户态发出sendfile系统调用</li>
<li>磁盘加载数据到内核缓冲区Read Buffer（第一次复制 hardware -&gt; kernel）</li>
<li>描述符拷贝到socket缓冲，包含内核内存地址和偏移量,没有拷贝数据</li>
<li>根据描述符直接使用内核缓冲区写入设备缓冲区NIC Buffer（第二次复制 kernel -&gt; hardware）</li>
<li>返回用户态<br>
零拷贝只需要2次切换和2次数据复制，并且数据不经过用户空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备-&gt;内核缓冲-&gt;设备</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> satic <span class="keyword">void</span> <span class="title">copyFileByChannel</span><span class="params">(File source, File des)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel sourceChannel = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">        FileChannel targetChannel = <span class="keyword">new</span> FileOutputStream(des).getChannel();) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> count = sourceChannel.size(); count&gt;<span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">long</span> transferred = sourceChannel.transferTo(sourceChannel.position(), count, targetChannel);</span><br><span class="line">            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存映射也可以实现零拷贝</p>
<ol>
<li>用户态发出mmap系统调用</li>
<li>磁盘拷贝数据到内核态 (hardware -&gt; kernel)</li>
<li>内核用户态共享空间，返回用户态</li>
<li>用户态发起write系统调用</li>
<li>数据复制到内核socket缓冲区（kernel -&gt; socket）</li>
<li>内核写入数据到设备（socket -&gt; hardware）</li>
<li>返回用户态<br>
整个过程4次状态切换，3次拷贝，和上述sendfile相比，用户可以进行操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备-&gt;共享内存-&gt;内核缓冲-&gt;设备</span><br></pre></td></tr></table></figure>
<p>零拷贝不一定优于FileChannel,取决于数据大小。<br>
数据量大FileChannel性能更好，读超过4kb,写超过64b。</p>
<h1 id="编码转换">编码转换</h1>
<hr>
<p>Buffer编码转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">CharsetEncoder encoder = utf8.newEncoder();</span><br><span class="line">CHarsetDecoder decoder = utf8.newDecoder();</span><br><span class="line">CharBuffer cb = CharBuffer.wrap(<span class="string">"UTF-8编码"</span>);</span><br><span class="line">ByteBuffer bb = encoder.encode(cb);</span><br><span class="line">cb = decoder.decode(bb);</span><br></pre></td></tr></table></figure>
<h1 id="文件锁">文件锁</h1>
<hr>
<p>基于FileChannel,锁是锁住文件，不是锁通道，进程级别，可协调不同软件对文件的访问</p>
<ul>
<li>可以指定加锁范围，局部加锁</li>
<li>可以指定共享/独占</li>
<li>提供阻塞lock和非阻塞tryLock方式</li>
</ul>
<p>默认行为是全量不共享加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示调用lock的release或者通道关闭都会解除</p>
<h1 id="多路复用">多路复用</h1>
<hr>
<p>单线程管理多通道，线程阻塞直到一个通道上有输入</p>
<ul>
<li>不同于多个线程的阻塞IO，多路复用同时多个输入时，顺次遍历，处理完一个才处理下一个，而多个线程彼此独立</li>
<li>不同于手动轮询多通道非阻塞IO，多路复用的轮询由内核负责，更加高效</li>
</ul>
<p>多路复用节省资源<br>
Selector根据事件标识进行多路复用<br>
基于操作系统机制，Linux基于epoll，Windows基于iocp</p>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开启一个selector和作为服务端的channel</span></span><br><span class="line">        <span class="keyword">try</span> (Selector selector = Selector.open();</span><br><span class="line">            ServerSocketChannel serverSocket = ServerSocketChannel.open();) &#123;</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">            <span class="comment">//关闭阻塞，允许注册</span></span><br><span class="line">            serverSocket.confgureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//channel注册上selector，并说明关注点，这里是关心这个通道上的连接请求</span></span><br><span class="line">            serverSocket.regiser(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始监听</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞等待，直到有客户端接入请求</span></span><br><span class="line">                selector.select();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//遍历调用逻辑</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">//当前是连接请求，接受连接</span></span><br><span class="line">                        SocketChannel channel = serverSocket.accept();</span><br><span class="line">                        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">//之后关注这个通道的读事件</span></span><br><span class="line">                        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//当前有数据就绪</span></span><br><span class="line">                        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">                        ByteBuffer bf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span>((len = socketChannel.read(bf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            bf.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(bf.array(),<span class="number">0</span>,len));</span><br><span class="line">                            bf.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NioClient</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SocketChannel schannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));)&#123;</span><br><span class="line">            schannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            buff.put(<span class="keyword">new</span> Date().toString().getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变更通知机制">变更通知机制</h1>
<hr>
<p>WatchService</p>
<h1 id="aio">AIO</h1>
<hr>
<p>事件机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel serverSock = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">serverSock.accept(serverSock, <span class="keyword">new</span> CompletionHandler&lt;&gt;() &#123;</span><br><span class="line">    <span class="comment">//异步操作回调函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock)</span> </span>&#123;</span><br><span class="line">        serverSock.accept(serverSock, <span class="keyword">this</span>);</span><br><span class="line">        sayHelloWorld(sockChannel, Charset.defaultCharset().encode(<span class="string">"Hello World!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="io模型">IO模型</h1>
<hr>
<p>IO大体上两个过程，检查数据就绪(设备-&gt;内核缓冲区)和进行数据拷贝(内核缓冲区-&gt;用户进程缓冲区)</p>
<p>同步和异步描述用户方法调用行为，IO需要一个长时间执行过程</p>
<ul>
<li>同步: 用户调用方法，执行IO完毕后，才能继续向下执行</li>
<li>异步：用户调用方法，不等待结束立刻返回，IO继续进行，完成后回调用户方法</li>
</ul>
<p>同步：应用负责处理IO请求</p>
<ul>
<li>阻塞模型：内核检查数据没就绪，用户线程阻塞等待，就绪后内核把数据拷贝到用户线程，线程阻塞状态解除，即用户从发起方法调用开始到最终数据到应用缓冲为止一直在阻塞等待</li>
<li>非阻塞模型：内核检查数据没就绪，用户线程立刻返回。用户线程可以稍后再次发请求，如果就绪就会把数据拷贝到用户线程。即两个过程分开，数据没就绪就返回用户线程非阻塞，数据就绪就拷贝用户线程阻塞等待完成</li>
<li>多路复用模型：使用单个线程管理多个通道，用户调用select阻塞，直到有通道上发生读写事件。每个通道是个非阻塞模型，即内核轮询每个通道数据是否就绪。在用户看来依然是阻塞的，但是内部多个通道是非阻塞的</li>
<li>信号驱动模型：发请求会注册一个方法，用户线程继续执行，内核数据就绪会发送信号，用户线程收到信号后调用IO方法进处理<br>
异步：操作系统处理IO请求, 应用逻辑直接用</li>
<li>异步模型：用户线程发送请求后继续执行，IO完成后收到回调，数据已完成拷贝到用户空间，用户线程无需继续调用IO方法直接使用数据。不同于以上几种，内核向用户线程拷贝数据时不会阻塞用户线程执行</li>
</ul>
<p>服务端通信模型<br>
BIO：同步阻塞IO, 调用方等待方法执行返回，底层IO在数据未就绪时阻塞<br>
服务器Acceptor线程收到请求，新建线程处理，处理结果返回客户端，一个连接持续占用一个线程，适合连接数少场景<br>
NIO: 同步非阻塞IO, 调用方看来依然是等待方法执行完返回，但是底层IO不会阻塞住，数据未就绪不断轮询<br>
请求注册，Selector轮询多路复用, 只有真正通信时才进行处理无需一直占用，适合连接数多并且连接短场景，因为长的话影响轮询<br>
AIO: 异步非阻塞IO，调用方立刻返回，提供回调<br>
操作系统处理IO，处理完通知，无需轮询是否完成，适合连接数多并且连接长场景</p>
<p>模式</p>
<ul>
<li>Reactor模式，多路复用，轮询检查依次处理<br>
响应器收到事件后，同线程内调用Handler同步处理</li>
<li>Proactor模式，异步，轮询检查开启异步处理<br>
响应器收到事件后，交给线程池异步处理</li>
</ul>
<p>改进？？</p>
<ul>
<li>多少IO目标</li>
<li>目标间是否有序</li>
<li>持续多长</li>
<li>单线程还是多线程</li>
<li>网络通信还是本地</li>
</ul>

        
    <div class="donate_module">
        <div id="donate_board" class="donate_bar">
            <br>
            <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
        </div>
        <div id="donate_guide" class="donate_bar hidden">
            <br>
            <a href="/assets/reward/wechat_code.jpg"  class="fancybox">
                <img src="/assets/reward/wechat_code.jpg" title="微信打赏" height="190px" width="auto"/>
            </a>
            <span class="donate_space"></span>
            <a href="/assets/reward/alipay_code.jpg"  class="fancybox">
                <img src="/assets/reward/alipay_code.jpg" title="支付宝打赏" height="190px" width="auto"/>
            </a>
        </div>
        <span class="donate_txt">一分也是爱~</span> 
    </div>

        <div class="breakword">
    <hr>
    <p><strong>版权声明</strong></p>
    <p><img src="/assets/copyright/cc.png" alt=""></p>
    <p><a href="http://linest.github.io/tmp/java-nio.html">This site</a> by <a href="mailto:xlinest@gmail.com">Linest</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.
    <br>由<a href="mailto:xlinest@gmail.com">Linest</a>创作并维护的博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
    <p>本文永久链接：<a href="http://linest.github.io/tmp/java-nio.html">http://linest.github.io/tmp/java-nio.html</a></p>
</div>
      
    </div>
    
  </div>
  
    
  
</article>
<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Linest
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> customized by <a href="#">Linest</a> with <span class="octicon octicon-heart" style="color:red"></span>
				</div>
				<div class="hide">
						<a href="https://clustrmaps.com/site/x7rd" title="Visit tracker"><img src="//clustrmaps.com/map_v2.png?cl=ffffff&w=70&t=n&d=trdgmMc8YDC9aFR4WIBOzfE8f6bNwx_Pq7HA9YiG3sA" /></a>
				</div>
    </div>
  </div>
</footer>

    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true
	}
</script>

<!-- Baidu auto push -->
<script>
(function(){
	var bp = document.createElement('script');
	var curProtocol = window.location.protocol.split(':')[0];
	if (curProtocol === 'https') {
		bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	}
	else {
		bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	}
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(bp, s);
})();
</script>

<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<script>!function(i){var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function r(t,e){var n=new Image,i=t.getAttribute("data-original");n.onload=function(){t.src=i,e&&e()},n.src=i}function t(){for(var t=0;t<o.length;t++)e=o[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(i.innerHeight||document.documentElement.clientHeight)&&r(o[t],function(){o.splice(t,t)});var e,n}t(),i.addEventListener("scroll",t)}(this);</script></body>
</html>