<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>LeetCode-树篇 | Blog of Linest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结  关注点  树形态(空，只有根，线状，正常) 树类型(二叉，BST，多叉)  技巧  递归，黑盒思维 求解流程中附加额外逻辑，分解复杂问题为简单问题 利用两个卫语句，覆盖了同时为null的情况  Sample123if(t1 == null) return t2;if(t2 == null) return t1;//both not null 常规完整的各种情况判断 Sample123456">
<meta property="og:type" content="website">
<meta property="og:title" content="LeetCode-树篇">
<meta property="og:url" content="http://linest.github.io/leetcode/leetcode-tree.html">
<meta property="og:site_name" content="Blog of Linest">
<meta property="og:description" content="总结  关注点  树形态(空，只有根，线状，正常) 树类型(二叉，BST，多叉)  技巧  递归，黑盒思维 求解流程中附加额外逻辑，分解复杂问题为简单问题 利用两个卫语句，覆盖了同时为null的情况  Sample123if(t1 == null) return t2;if(t2 == null) return t1;//both not null 常规完整的各种情况判断 Sample123456">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-01T02:31:21.325Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode-树篇">
<meta name="twitter:description" content="总结  关注点  树形态(空，只有根，线状，正常) 树类型(二叉，BST，多叉)  技巧  递归，黑盒思维 求解流程中附加额外逻辑，分解复杂问题为简单问题 利用两个卫语句，覆盖了同时为null的情况  Sample123if(t1 == null) return t2;if(t2 == null) return t1;//both not null 常规完整的各种情况判断 Sample123456">
  
    <link rel="alternative" href="/atom.xml" title="Blog of Linest" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/fonts/octicons/octicons.css">
  <link rel="stylesheet" href="/css/fonts/font-awesome-4.6.3/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Linest</a></h1>
		</hgroup>

		
		<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/doodle">涂鸦</a></li>
				        
							<li><a href="/live2d">云撸猫</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tagcloud">标签&amp;分类</a></li>
				        
						</ul>
					</nav>	
				</section>
				
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">勤奋的懒惰者
爱听故事的人~
Zjuer
</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Linest</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Linest</h1>
			</hgroup>
			
			<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/doodle">涂鸦</a></li>
		        
					<li><a href="/live2d">云撸猫</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tagcloud">标签&amp;分类</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/leetcode/leetcode-tree.html" class="article-date">
  	<time datetime="2019-12-01T02:31:21.325Z" itemprop="datePublished">2019-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode-树篇
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="总结">总结</h1>
<hr>
<h2 id="关注点">关注点</h2>
<ul>
<li>树形态(空，只有根，线状，正常)</li>
<li>树类型(二叉，BST，多叉)</li>
</ul>
<h2 id="技巧">技巧</h2>
<ul>
<li>递归，黑盒思维</li>
<li>求解流程中附加额外逻辑，分解复杂问题为简单问题</li>
<li>利用两个卫语句，覆盖了同时为null的情况</li>
</ul>
<figure class="highlight java"><figcaption><span>Sample</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line"><span class="keyword">if</span>(t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line"><span class="comment">//both not null</span></span><br></pre></td></tr></table></figure>
<p>常规完整的各种情况判断</p>
<figure class="highlight java"><figcaption><span>Sample</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//both not null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意条件一致不能混用</p>
<figure class="highlight java"><figcaption><span>Sample</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//这里条件不对应该是left!=null，上一句反向是有一个空或者全空,只判断left==null无法区分</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意">注意</h2>
<ul>
<li>访问左右子时，先检查当前是否为null</li>
<li>错误的构建方式，引用值传递，传入方法的参数是一个副本，方法内的对象并不会接在外面<br>
外部指针和参数指针是两个指向相同的指针，方法内部改变的只有参数指针指向</li>
</ul>
<figure class="highlight java"><figcaption><span>Sample</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">    n = <span class="keyword">new</span> Node();</span><br><span class="line">&#125;</span><br><span class="line">method(node.left);</span><br></pre></td></tr></table></figure>
<h1 id="基础遍历">基础遍历</h1>
<hr>
<h2 id="❀144-binary-tree-preorder-traversal">❀144. Binary Tree Preorder Traversal</h2>
<blockquote>
<p>前序遍历</p>
</blockquote>
<p>迭代法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode n = stack.pop();</span><br><span class="line">            result.add(n.val);</span><br><span class="line">            <span class="comment">//左子树优先，因此先进栈右子树，让左子树在上面</span></span><br><span class="line">            <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(n.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀94-binary-tree-inorder-traversal">❀94. Binary Tree Inorder Traversal</h2>
<blockquote>
<p>中序遍历</p>
</blockquote>
<p>迭代，栈辅助，出栈时表示遍历到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//一直往左走</span></span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//走不下去出栈往右走，即相当于左中右顺序</span></span><br><span class="line">                curr = stack.pop();</span><br><span class="line">                result.add(curr.val);</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀145-binary-tree-postorder-traversal">❀145. Binary Tree Postorder Traversal</h2>
<blockquote>
<p>后序遍历</p>
</blockquote>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="comment">//避免为空，先指向根</span></span><br><span class="line">        TreeNode last = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode n = stack.peek();</span><br><span class="line">            <span class="comment">//按照左右根顺序遍历，如果当前节点想出栈，那么必须已完成左右</span></span><br><span class="line">            <span class="keyword">if</span>(n.left != <span class="keyword">null</span> &amp;&amp; last != n.left &amp;&amp; last != n.right) &#123;</span><br><span class="line">                <span class="comment">//左节点遍历过的标志是上个出栈节点是左节点(没有右子)，或者上个出栈节点是右节点(右已经完成那么左也完成)</span></span><br><span class="line">                <span class="comment">//左子没遍历过时，入栈</span></span><br><span class="line">                stack.push(n.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n.right != <span class="keyword">null</span> &amp;&amp; last != n.right) &#123;</span><br><span class="line">                <span class="comment">//右节点遍历过的标志是上个出栈节点是右节点</span></span><br><span class="line">                <span class="comment">//右子没遍历过时，入栈</span></span><br><span class="line">                stack.push(n.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//左右子都遍历过，当前节点出栈</span></span><br><span class="line">                last = stack.pop();</span><br><span class="line">                result.add(last.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树层级">二叉树层级</h1>
<hr>
<p>BFS，直接按层<br>
DFS，维持层号，间接获取层信息</p>
<h2 id="❀102-binary-tree-level-order-traversal">❀102. Binary Tree Level Order Traversal</h2>
<blockquote>
<p>层序遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="107-binary-tree-level-order-traversal-ii">107. Binary Tree Level Order Traversal II</h2>
<blockquote>
<p>自底向上层序遍历</p>
</blockquote>
<p>可以依然采用自顶向上流程，在结果收集上特殊处理。可以收集完Collections.reverse(result)整体逆序，也可以直接使用LinkedList作为结果集，直接用add(0,level)头部插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="number">0</span>, level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="103-binary-tree-zigzag-level-order-traversal">103. Binary Tree Zigzag Level Order Traversal</h2>
<blockquote>
<p>层与层之间正向反向交错</p>
</blockquote>
<p>判断奇数层和偶数层，奇数层直接逆序或者采用头部插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                Collections.reverse(level);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀958-check-completeness-of-a-binary-tree">❀958. Check Completeness of a Binary Tree</h2>
<blockquote>
<p>判断树是否是完全二叉树，即只有最后一层后半部分缺失</p>
</blockquote>
<p>层序遍历，全部双子则保持完整状态，如果遇到无子或只有左子，进入不完整状态，如果只有右子情况时非法<br>
一旦进入不完整状态，只能接受无子情况，其他情况都非法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> complete = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode n = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(complete &amp;&amp; n.left == <span class="keyword">null</span> &amp;&amp; n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!complete &amp;&amp; (n.left != <span class="keyword">null</span> || n.right != <span class="keyword">null</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右子缺失，进入不完整状态</span></span><br><span class="line">                <span class="keyword">if</span>(complete &amp;&amp; n.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    complete = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀314-binary-tree-vertical-order-traversal">❀314. Binary Tree Vertical Order Traversal</h2>
<blockquote>
<p>二叉树纵向遍历，多个同行同列时按照从左到右顺序</p>
</blockquote>
<p>层序遍历，为每个节点附加列信息，根节点列为0，哈希表按列收集后整理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最左侧列和最右侧列</span></span><br><span class="line">        <span class="keyword">int</span> minCol = Integer.MAX_VALUE, maxCol = Integer.MIN_VALUE;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//[node, column]</span></span><br><span class="line">        Queue&lt;Object[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Object[]&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            Object[] obj = queue.poll();</span><br><span class="line">            TreeNode n = (TreeNode)obj[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = (<span class="keyword">int</span>)obj[<span class="number">1</span>];</span><br><span class="line">            minCol = Math.min(minCol, col);</span><br><span class="line">            maxCol = Math.max(maxCol, col);</span><br><span class="line">            map.putIfAbsent(col, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(col).add(n.val);</span><br><span class="line">            <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Object[]&#123;n.left, col-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Object[]&#123;n.right, col+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = minCol; i &lt;= maxCol; i++) &#123;</span><br><span class="line">            result.add(map.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="993-cousins-in-binary-tree">993. Cousins in Binary Tree</h2>
<blockquote>
<p>值不重复的二叉树，判定两个节点是不是同层不同父</p>
</blockquote>
<p>层序遍历，同层判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCousins</span><span class="params">(TreeNode root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> parentX = <span class="number">0</span>, parentY = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode n = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                    <span class="keyword">if</span>(n.left.val == x) &#123;</span><br><span class="line">                        parentX = n.val;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n.left.val == y) &#123;</span><br><span class="line">                        parentY = n.val;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                    <span class="keyword">if</span>(n.right.val == x) &#123;</span><br><span class="line">                        parentX = n.val;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n.right.val == y) &#123;</span><br><span class="line">                        parentY = n.val;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(parentX == <span class="number">0</span> &amp;&amp; parentY == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parentX == <span class="number">0</span> || parentY == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> parentX != parentY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="637-average-of-levels-in-binary-tree">637. Average of Levels in Binary Tree</h2>
<blockquote>
<p>二叉树每层平均值</p>
</blockquote>
<p>BFS层序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(sum/size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀513-find-bottom-left-tree-value">❀513. Find Bottom Left Tree Value</h2>
<blockquote>
<p>求最后一层第一个节点</p>
</blockquote>
<p>BFS层序遍历，每一层指向第一个节点，最后指针位置就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = root.val;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = node.val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS前序遍历，给每层留一个位置，放每一层级遍历到的第一个节点，即保留了左视图，BFS需要完整遍历，DFS效率更高一点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        findBottomLeftValue(root, list, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root, List&lt;Integer&gt; list, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level == list.size())&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        findBottomLeftValue(root.left, list, level+<span class="number">1</span>);</span><br><span class="line">        findBottomLeftValue(root.right, list, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀199-binary-tree-right-side-view">❀199. Binary Tree Right Side View</h2>
<blockquote>
<p>求二叉树的右视图</p>
</blockquote>
<p>每层最后一个节点可见，层序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i == size-<span class="number">1</span>) &#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归，右边优先，每层只取第一个，即深度等于已存结果长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        rightView(root, result, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightView</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result, <span class="keyword">int</span> currDepth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(currDepth == result.size())&#123;</span><br><span class="line">            result.add(curr.val);</span><br><span class="line">        &#125;</span><br><span class="line">        rightView(curr.right, result, currDepth + <span class="number">1</span>);</span><br><span class="line">        rightView(curr.left, result, currDepth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="515-find-largest-value-in-each-tree-row">515. Find Largest Value in Each Tree Row</h2>
<blockquote>
<p>求二叉树每层最大值</p>
</blockquote>
<p>BFS层序遍历，每层求最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                max = Math.max(max, node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS前序遍历，每一层留一个位置，遍历过程中每个节点尝试更新相应层的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        largestValues(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">largestValues</span><span class="params">(TreeNode root, List&lt;Integer&gt; res, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d == res.size())&#123;</span><br><span class="line">            <span class="comment">//本行第一个</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//非第一个，更新已有</span></span><br><span class="line">            res.set(d, Math.max(res.get(d), root.val));</span><br><span class="line">        &#125;</span><br><span class="line">        largestValues(root.left, res, d+<span class="number">1</span>);</span><br><span class="line">        largestValues(root.right, res, d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="623-add-one-row-to-tree">623. Add One Row to Tree</h2>
<blockquote>
<p>在指定层插入一层节点</p>
</blockquote>
<p>在第一层插即根节点变化，在其他层插还是原来的根节点<br>
BFS,找到指定层，每个层节点插入新节点，整层处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(level == d-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            TreeNode newLeft = <span class="keyword">new</span> TreeNode(v), newRight = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            newLeft.left = node.left;</span><br><span class="line">            newRight.right = node.right;</span><br><span class="line">            node.left = newLeft;</span><br><span class="line">            node.right = newRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS前序，维护当前深度即可，单个处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        addOneRow(root, v, d, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d, <span class="keyword">int</span> curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr == d-<span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode leftNode = <span class="keyword">new</span> TreeNode(v), rightNode = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            leftNode.left = root.left;</span><br><span class="line">            rightNode.right = root.right;</span><br><span class="line">            root.left = leftNode;</span><br><span class="line">            root.right = rightNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addOneRow(root.left, v, d, curr+<span class="number">1</span>);</span><br><span class="line">        addOneRow(root.right, v, d, curr+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="边界">边界</h1>
<hr>
<h2 id="❀545-boundary-of-binary-tree">❀545. Boundary of Binary Tree</h2>
<blockquote>
<p>逆时针(左边-叶子-右边)求二叉树边界</p>
</blockquote>
<p>分成三部分，求不含首尾节点的左界，求叶节点，求不含首尾节点的右界逆序<br>
左边界不同于左视图，并非是每层第一个节点，另外叶子节点可能不同层难以控制顺序，不适合层序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			res.add(root.val);</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		res.add(root.val);</span><br><span class="line">		getLeftPath(root.left, res);</span><br><span class="line">		getLeaf(root, res);</span><br><span class="line">		getRightReversePath(root.right, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLeftPath</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//不含叶节点</span></span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		res.add(root.val);</span><br><span class="line">        <span class="comment">//左侧尽可能走，不能向左时再向右</span></span><br><span class="line">		<span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			getLeftPath(root.left, res);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			getLeftPath(root.right, res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRightReversePath</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			getRightReversePath(root.right, res);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			getRightReversePath(root.left, res);</span><br><span class="line">		&#125;</span><br><span class="line">		res.add(root.val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLeaf</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			res.add(root.val);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			getLeaf(root.left, res);</span><br><span class="line">			getLeaf(root.right, res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="872-leaf-similar-trees">872. Leaf-Similar Trees</h2>
<blockquote>
<p>判断两颗树从左到右叶节点相同</p>
</blockquote>
<p>递归，DFS收集叶节点比较，缺点是全遍历之后才能判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getLeafList(root1).equals(getLeafList(root2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getLeafList</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getLeafList(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getLeafList</span><span class="params">(TreeNode root, List&lt;Integer&gt; leafList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            leafList.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        getLeafList(root.left, leafList);</span><br><span class="line">        getLeafList(root.right, leafList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，DFS前序遍历，每次两个树各自尝试找到下一个叶节点，不同的话立刻返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(root1);</span><br><span class="line">        stack2.push(root2);</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(findNextLeafValue(stack1) != findNextLeafValue(stack2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextLeafValue</span><span class="params">(Stack&lt;TreeNode&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分治与外部状态">分治与外部状态</h1>
<hr>
<h2 id="❀965-univalued-binary-tree">❀965. Univalued Binary Tree</h2>
<blockquote>
<p>判断树是否由单一值组成</p>
</blockquote>
<p>不用外部维护，每个节点保证子节点和自己值相同即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.val != root.left.val </span><br><span class="line">           || root.right != <span class="keyword">null</span> &amp;&amp; root.val != root.right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部维护，判断每个节点是否等于根值即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> v = root.val;</span><br><span class="line">        preOrder(root, v);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.val != v) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preOrder(node.left, v);</span><br><span class="line">        preOrder(node.right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="404-sum-of-left-leaves">404. Sum of Left Leaves</h2>
<blockquote>
<p>求左叶子节点的和，只有根不算</p>
</blockquote>
<p>分治，普通遍历无法访问父节点即无法分辨叶子的左右，增加一个额外标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isLeft ? root.val : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left, <span class="keyword">true</span>) + sumOfLeftLeaves(root.right, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于外部状态，前序遍历每个节点判断是否有左叶子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode leftChild = root.left;</span><br><span class="line">        <span class="keyword">if</span>(leftChild != <span class="keyword">null</span> &amp;&amp; leftChild.left == <span class="keyword">null</span> &amp;&amp; leftChild.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += leftChild.val;</span><br><span class="line">        &#125;</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers</h2>
<blockquote>
<p>根叶路径作为一个数字，求所有数字和</p>
</blockquote>
<p>前序遍历，遇到根节点单条路径完成，求得数字后外部累加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preOrder(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node, <span class="keyword">int</span> base)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curr = base*<span class="number">10</span> + node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += curr;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preOrder(node.left, curr);</span><br><span class="line">        preOrder(node.right, curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子树状态">子树状态</h1>
<hr>
<p>分治，适合后续遍历</p>
<h2 id="❀104-maximum-depth-of-binary-tree">❀104. Maximum Depth of Binary Tree</h2>
<blockquote>
<p>计算最大深度，即最长路径上的结点数</p>
</blockquote>
<p>后序遍历，自底向上，在子树最大高度的基础上增加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以BFS层序遍历，即求最大层数</p>
<h2 id="❀111-minimum-depth-of-binary-tree">❀111. Minimum Depth of Binary Tree</h2>
<blockquote>
<p>求最短路径节点数</p>
</blockquote>
<p>递归，如果只有一个子节点，那么求子节点，如果两个子节点，求两者最小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，层序遍历，最早出现叶节点的层数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> minDepth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> minDepth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀110-balanced-binary-tree">❀110. Balanced Binary Tree</h2>
<blockquote>
<p>判断树是否平衡</p>
</blockquote>
<p>两个子树平衡并不代表整树平衡，因为子树可以高度差很多<br>
利用求高度辅助方法，每个节点判断高度差</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        balance = <span class="keyword">true</span>;</span><br><span class="line">        getHeight(root);</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            balance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀543-diameter-of-binary-tree">❀543. Diameter of Binary Tree</h2>
<blockquote>
<p>求树直径，即任意两节点最长路径，可能不通过根节点</p>
</blockquote>
<p>后序遍历，即求任意节点左右两侧高度只和，叶节点高度0<br>
实质上是求树高度，顺便计算经过节点的最长路径长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxLength = <span class="number">0</span>;</span><br><span class="line">        treeHeight(root);</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">treeHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = treeHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = treeHeight(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pathLength = leftHeight + rightHeight + <span class="number">2</span>;</span><br><span class="line">        maxLength = Math.max(maxLength, pathLength);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/discuss/124198/Iterative-Accepted-Java-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/diameter-of-binary-tree/discuss/124198/Iterative-Accepted-Java-Solution</a><br>
迭代，后序，第一次不弹出，只作为压入后续节点，第二次再弹出，此时子树处理完成</p>
<h2 id="563-binary-tree-tilt">563. Binary Tree Tilt</h2>
<blockquote>
<p>左右子树所有节点和的绝对值差，作为节点Tilt，求所有节点Tilt之和</p>
</blockquote>
<p>后序遍历，树求和，当前节点与左右子树和，顺便把绝对值差值累加到外部变量上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        subTreeSum(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subTreeSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSum = subTreeSum(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightSum = subTreeSum(root.right);</span><br><span class="line">        result += Math.abs(leftSum-rightSum);</span><br><span class="line">        <span class="keyword">return</span> root.val + leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="508-most-frequent-subtree-sum">508. Most Frequent Subtree Sum</h2>
<blockquote>
<p>所有子树和中频率最高的和值</p>
</blockquote>
<p>子树和问题，后序遍历求每个子树和，外部哈希表存储后统计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cntMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        subTreeSum(root, cntMap);</span><br><span class="line">        <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; maxSumList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : cntMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = cntMap.get(key);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; maxCnt) &#123;</span><br><span class="line">                maxCnt = cnt;</span><br><span class="line">                maxSumList.clear();</span><br><span class="line">                maxSumList.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt == maxCnt) &#123;</span><br><span class="line">                maxSumList.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSumList.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subTreeSum</span><span class="params">(TreeNode root, Map&lt;Integer,Integer&gt; cntMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSum = subTreeSum(root.left, cntMap);</span><br><span class="line">        <span class="keyword">int</span> rightSum = subTreeSum(root.right, cntMap);</span><br><span class="line">        <span class="keyword">int</span> sum = root.val + leftSum + rightSum;</span><br><span class="line">        cntMap.put(sum, cntMap.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀671-second-minimum-node-in-a-binary-tree">❀671. Second Minimum Node In a Binary Tree</h2>
<blockquote>
<p>特殊树结构，要么有两个子节点要么没有子节点，节点值等于左右节点最小值，求第二小节点，没有返回-1</p>
</blockquote>
<p>分治。根据树结构，根节点是最小，第二小值是左右子树第二小值中的较大值<br>
如果子节点等于根，那么从子树的次小值是候选值<br>
如果子节点不等于根，那么子节点本身就是候选值，因为根据性质已经是大于根节点的子树最小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//节点数太少，肯定没有第二小值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = root.left.val, right = root.right.val;</span><br><span class="line">        <span class="comment">//左子和根相等，根是最小值，那么需要从左子树中找第二小值作为候选</span></span><br><span class="line">        <span class="keyword">if</span> (root.left.val == root.val) &#123;</span><br><span class="line">            left = findSecondMinimumValue(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right.val == root.val) &#123;</span><br><span class="line">            right = findSecondMinimumValue(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="路径">路径</h1>
<hr>
<p>自上而下，适合前序遍历</p>
<h2 id="257-binary-tree-paths">257. Binary Tree Paths</h2>
<blockquote>
<p>收集所有二叉树根叶路径</p>
</blockquote>
<ul>
<li>递归，DFS前序遍历，不断延长路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    treePath(<span class="keyword">null</span>,root,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">treePath</span><span class="params">(String path, TreeNode node, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String newPath = path == <span class="keyword">null</span> ? String.valueOf(node.val) : path +<span class="string">"-&gt;"</span> + node.val;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.add(newPath);</span><br><span class="line">    &#125;</span><br><span class="line">    treePath(newPath, node.left, result);</span><br><span class="line">    treePath(newPath, node.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代，DFS前序遍历，路径和节点一起进栈，可以建数据结构或者用数组</li>
<li>BFS层序遍历</li>
</ul>
<h2 id="❀112-path-sum">❀112. Path Sum</h2>
<blockquote>
<p>判断是否存在一条路径和为指定值</p>
</blockquote>
<p>递归，目标和和缩小，最终判定叶节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀113-path-sum-ii">❀113. Path Sum II</h2>
<blockquote>
<p>求和为指定值的所有路径</p>
</blockquote>
<p>前序遍历，注意构建中路径的恢复和保护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        pathSum(root,sum, root.val, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> pathSum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pathSum == sum) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path.add(root.left.val);</span><br><span class="line">            pathSum(root.left, sum, pathSum + root.left.val, path, result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path.add(root.right.val);</span><br><span class="line">            pathSum(root.right, sum, pathSum + root.right.val, path, result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀437-path-sum-iii">❀437. Path Sum III</h2>
<blockquote>
<p>任意从上到下小段路径，不一定包含根和叶，路径和为指定值的路径条数</p>
</blockquote>
<p>递归，复杂度O(n)，求任意分段的和，利用前序和<br>
维护路径上前序和的map,key是前序和，value是方法数，因为节点允许负值，达到相同前序和可能多种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap();</span><br><span class="line">        preSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pathSum(root, <span class="number">0</span>, sum, preSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> currSum, <span class="keyword">int</span> target, Map&lt;Integer, Integer&gt; preSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newSum = currSum + root.val;</span><br><span class="line">        <span class="keyword">int</span> res = preSum.getOrDefault(newSum - target, <span class="number">0</span>);</span><br><span class="line">        preSum.put(newSum, preSum.getOrDefault(newSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        res += pathSum(root.left, newSum, target, preSum) + pathSum(root.right, newSum, target, preSum);</span><br><span class="line">        <span class="comment">//恢复统计</span></span><br><span class="line">        preSum.put(newSum, preSum.get(newSum) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀124-binary-tree-maximum-path-sum">❀124. Binary Tree Maximum Path Sum</h2>
<blockquote>
<p>含有负值的树，从树任意节点开始到任意节点为止，最大路径和，不一定经过根节点</p>
</blockquote>
<p>最大路径和是从某一节点开始，左右子向下能达到的最大和值<br>
问题转化为求每个节点向下最大和值，先构建辅助函数，从节点开始向下能达到的最大路径和，此时左右子树路径需要选其中一个大的<br>
在计算流程中，更新外部维护的最大路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPathSumDownNode(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathSumDownNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = maxPathSumDownNode(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = maxPathSumDownNode(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pathSum = left + right + root.val;</span><br><span class="line">        max = Math.max(max, pathSum);</span><br><span class="line">        <span class="keyword">return</span>  root.val + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀687-longest-univalue-path">❀687. Longest Univalue Path</h2>
<blockquote>
<p>最长单一值路径长度，可以不通过根节点</p>
</blockquote>
<p>转变为求每个节点向下同值路径长度，计算流程中更新外部最长路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        univalueRootPath(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return path from root</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">univalueDownPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftPath = univalueDownPath(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightPath = univalueDownPath(root.right);</span><br><span class="line">        leftPath = (root.left != <span class="keyword">null</span> &amp;&amp; root.val == root.left.val) ? leftPath +<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        rightPath = (root.right != <span class="keyword">null</span> &amp;&amp; root.val == root.right.val) ? rightPath +<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        max = Math.max(max, leftPath + rightPath);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftPath, rightPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索树">搜索树</h1>
<hr>
<p>利用大小性质舍弃</p>
<h2 id="❀700-search-in-a-binary-search-tree">❀700. Search in a Binary Search Tree</h2>
<blockquote>
<p>搜索树查找</p>
</blockquote>
<p>递归版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val &lt; root.val ? searchBST(root.left,val) : searchBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> &amp;&amp; root.val != val)&#123;</span><br><span class="line">            root = val &lt; root.val ? root.left : root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀270-closest-binary-search-tree-value">❀270. Closest Binary Search Tree Value</h2>
<blockquote>
<p>查找最近节点</p>
</blockquote>
<p>按照正常查找流程，过程中维护差值绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = root.val;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = Math.abs(target - root.val) &lt; Math.abs(target - min) ? root.val : min;</span><br><span class="line">            root = root.val &lt; target ? root.right : root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀938-range-sum-of-bst">❀938. Range Sum of BST</h2>
<blockquote>
<p>无重复值搜索树范围内节点求和</p>
</blockquote>
<p>递归，根据性质决定一边或者拆分两边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; R) &#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.left, L, R);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; L) &#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.right, L, R);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val + rangeSumBST(root.left, L, root.val-<span class="number">1</span>) + rangeSumBST(root.right, root.val+<span class="number">1</span>, R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀669-trim-a-binary-search-tree">❀669. Trim a Binary Search Tree</h2>
<blockquote>
<p>给一个范围，把范围外的结点除掉</p>
</blockquote>
<p>如果节点小于范围，那么所有左边都小于，舍弃<br>
如果节点大于范围，那么所有右边都大于，舍弃<br>
如果节点在之间，那么保留，递归处理子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; L) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; R) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,L,R);</span><br><span class="line">        root.right = trimBST(root.right,L,R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索树中序">搜索树中序</h1>
<hr>
<p>中序遍历递增，树如同一个升序数组</p>
<h2 id="❀538-convert-bst-to-greater-tree">❀538. Convert BST to Greater Tree</h2>
<blockquote>
<p>每个节点都累加上所有比它大的节点值</p>
</blockquote>
<p>反向中序获得递减数列，外部维护和值，每个节点附加上累加和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        root.val += sum;</span><br><span class="line">        sum = root.val;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以先中序转成有序list然后再处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, list);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sum += list.get(i).val;</span><br><span class="line">            list.get(i).val = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, list);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inOrder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="653-two-sum-iv-input-is-a-bst">653. Two Sum IV - Input is a BST</h2>
<blockquote>
<p>二叉搜索树判断是否有两数和等于特定值</p>
</blockquote>
<p>可以针对每个树节点，从根搜索一遍O(nlogn)<br>
可以利用中序转成数组，然后求，O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, list);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = list.get(i).val + list.get(j).val;</span><br><span class="line">            <span class="keyword">if</span>(sum == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, list);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inOrder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="501-find-mode-in-binary-search-tree">501. Find Mode in Binary Search Tree</h2>
<blockquote>
<p>找出二叉搜索树中出现最多的节点</p>
</blockquote>
<p>二叉搜索树中序遍历时有序的，即相同值连续，便于统计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer prev;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, result);</span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="keyword">null</span> || prev != root.val) &#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; maxCnt) &#123;</span><br><span class="line">            result.clear();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            maxCnt = cnt;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt == maxCnt) &#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root.val;</span><br><span class="line">        inOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀98-validate-binary-search-tree">❀98. Validate Binary Search Tree</h2>
<blockquote>
<p>验证二叉搜索树</p>
</blockquote>
<p>递归分治，只判断单一节点左小右大是不够的，需要有上下界限定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//null代表无限制</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, Integer low, Integer high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span>(high != <span class="keyword">null</span> &amp;&amp; root.val &gt;= high || low != <span class="keyword">null</span> &amp;&amp; root.val &lt;= low) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, low, root.val) &amp;&amp; isValidBST(root.right, root.val, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，中序遍历升序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root, prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode n = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="keyword">null</span> &amp;&amp; n.val &lt;= prev.val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = n;</span><br><span class="line">                curr = n.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="783-minimum-distance-between-bst-nodes">783. Minimum Distance Between BST Nodes</h2>
<h2 id="530-minimum-absolute-difference-in-bst">530. Minimum Absolute Difference in BST</h2>
<p>二叉搜索树最小间距</p>
<p>中序遍历，顺次求间距，因为中序升序，差值总可以是正数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    Integer prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = Math.min(root.val - prev,min);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root.val;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀230-kth-smallest-element-in-a-bst">❀230. Kth Smallest Element in a BST</h2>
<blockquote>
<p>二叉搜索树找到第k小的元素，保证存在</p>
</blockquote>
<p>分治法，目标节点的左子树包含k-1个节点，实际上变为节点计数问题<br>
在计数的同时，嵌入目标个数比较逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        helper(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回树节点数，同时嵌入目标个数逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftCount = helper(root.left, k);</span><br><span class="line">        <span class="comment">//右子树寻找要减掉左子树</span></span><br><span class="line">        <span class="keyword">int</span> rightCount = helper(root.right, k - leftCount - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左子树有k-1个节点，那么当前节点就是所求</span></span><br><span class="line">        <span class="keyword">if</span> (k - <span class="number">1</span> == leftCount) &#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历法，按照升序性质数过去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> Integer res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorder(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索树改变结构">搜索树改变结构</h1>
<hr>
<h2 id="❀776-split-bst">❀776. Split BST</h2>
<blockquote>
<p>给定一个值，将无重复的二叉搜索树分割成两个子树，使得第一个子树小于等于给定值，第二个子树大于给定值</p>
</blockquote>
<p>目标分割值在树中不一定存在，迭代实现有点小麻烦<br>
递归分治处理，只断开是不够的，还需要拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode[] splitBST(TreeNode root, <span class="keyword">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode[]&#123;<span class="keyword">null</span>, <span class="keyword">null</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == V) &#123;</span><br><span class="line">            TreeNode right = root.right;</span><br><span class="line">            root.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode[]&#123;root, right&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; V) &#123;</span><br><span class="line">            <span class="comment">//根节点大于分割值，说明在左侧，左子树继续分割</span></span><br><span class="line">            TreeNode[] nodes = splitBST(root.left, V);</span><br><span class="line">            TreeNode left = nodes[<span class="number">0</span>];</span><br><span class="line">            TreeNode right = nodes[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//将子树中大于部分拼接回原来根的左子树</span></span><br><span class="line">            root.left = right;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode[]&#123;left,root&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode[] nodes = splitBST(root.right, V);</span><br><span class="line">            TreeNode left = nodes[<span class="number">0</span>];</span><br><span class="line">            TreeNode right = nodes[<span class="number">1</span>];</span><br><span class="line">            root.right=left;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode[]&#123;root, right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀450-delete-node-in-a-bst">❀450. Delete Node in a BST</h2>
<blockquote>
<p>删除二叉搜索树节点</p>
</blockquote>
<p>迭代</p>
<ol>
<li>先搜索要删节点，需要同时找到父节点，便于删除</li>
<li>把目标节点的左右子树合并，接回原树</li>
</ol>
<p>子树合并算法，找到大树的最小节点，即最左节点，找到后把小树接在左子树位置即可<br>
最左节点一定是左子，如果是右子那么比父节点大，就不是最小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key == root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeBST(root.left,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定位目标节点，同时维护父节点</span></span><br><span class="line">        TreeNode curr = root, prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(key &gt; curr.val) &#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; curr.val) &#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode subTree = mergeBST(curr.left, curr.right);</span><br><span class="line">            <span class="keyword">if</span>(curr.val &lt; prev.val) &#123;</span><br><span class="line">                prev.left = subTree;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev.right = subTree;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">mergeBST</span><span class="params">(TreeNode small, TreeNode large)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(large == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> small;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curr = large;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.left = small;</span><br><span class="line">        <span class="keyword">return</span> large;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeBST(root.left,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把小树接入大树中，大树最左节点是最小，把小树接在左子上</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">mergeBST</span><span class="params">(TreeNode small, TreeNode large)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(large == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> small;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curr = large;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.left = small;</span><br><span class="line">        <span class="keyword">return</span> large;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反序列化建树">反序列化建树</h1>
<hr>
<p>只靠单个遍历序列不能唯一确定一棵树，需要中序和前/后序搭配</p>
<h2 id="❀108-convert-sorted-array-to-binary-search-tree">❀108. Convert Sorted Array to Binary Search Tree</h2>
<blockquote>
<p>用有序数组建一颗平衡搜索树</p>
</blockquote>
<p>为了保持平衡，每次二分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = i + (j - i)/<span class="number">2</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node.left = sortedArrayToBST(nums, i, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = sortedArrayToBST(nums, mid + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，把父节点，以及子节点数组下标范围作为整体进出栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayNode</span> </span>&#123;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        <span class="keyword">int</span> low;</span><br><span class="line">        <span class="keyword">int</span> high;</span><br><span class="line">        ArrayNode(TreeNode node, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = node;</span><br><span class="line">            <span class="keyword">this</span>.low = low;</span><br><span class="line">            <span class="keyword">this</span>.high = high;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;ArrayNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始父节点是null,可用整个范围</span></span><br><span class="line">        s.push(<span class="keyword">new</span> ArrayNode(<span class="keyword">null</span>,<span class="number">0</span>,nums.length-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">            ArrayNode an = s.pop();</span><br><span class="line">            <span class="keyword">int</span> mid = an.low + (an.high - an.low)/<span class="number">2</span>;</span><br><span class="line">            TreeNode parent = an.parent;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">            <span class="keyword">if</span>(an.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//父节点是null说明当前是根节点</span></span><br><span class="line">                root = node;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//父子节点根据大小关系选择左右</span></span><br><span class="line">                <span class="keyword">if</span>(node.val &lt; parent.val) &#123;</span><br><span class="line">                    parent.left = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent.right = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确保范围有效</span></span><br><span class="line">            <span class="keyword">if</span>(mid-<span class="number">1</span> &gt;= an.low) &#123;</span><br><span class="line">                s.push(<span class="keyword">new</span> ArrayNode(node, an.low, mid - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= an.high) &#123;</span><br><span class="line">                s.push(<span class="keyword">new</span> ArrayNode(node, mid + <span class="number">1</span>, an.high));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="109-convert-sorted-list-to-binary-search-tree">109. Convert Sorted List to Binary Search Tree</h2>
<blockquote>
<p>根据有序链表建二叉搜索树</p>
</blockquote>
<p>与数组不同，链表无法直接定位中点，使用快慢指针找中点，断开成两链表，分别构建子树<br>
维护中点前指针，方便断开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head, prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀105-construct-binary-tree-from-preorder-and-inorder-traversal">❀105. Construct Binary Tree from Preorder and Inorder Traversal</h2>
<blockquote>
<p>前序中序建树</p>
</blockquote>
<p>递归，前序第一节点就是根，找到其在中序位置，左右部分就是左右子树，根据左右子树大小对前序分割</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preS, <span class="keyword">int</span> preE, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inS, <span class="keyword">int</span> inE)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preS &gt; preE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preS];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = inS; i &lt;= inE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = i - inS, rightSize = inE - i;</span><br><span class="line">        root.left = buildTree(preorder, preS+<span class="number">1</span>, preS+leftSize, inorder, inS, i-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, preE-rightSize+<span class="number">1</span>, preE, inorder, i+<span class="number">1</span>, inE);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代<br>
让前序不断进栈，前序每个节点都是左子树的根节点<br>
如果栈顶匹配到中序，那么说明左子树构建完毕，出栈等待构建右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        TreeNode out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            TreeNode curr = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[j]) &#123;</span><br><span class="line">                out = stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//没有节点需要右子树，连到左子树</span></span><br><span class="line">                stack.peek().left = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有节点需要右子树，连接后置空</span></span><br><span class="line">                out.right = curr;</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="106-construct-binary-tree-from-inorder-and-postorder-traversal">106. Construct Binary Tree from Inorder and Postorder Traversal</h2>
<blockquote>
<p>后序中序建树</p>
</blockquote>
<p>递归，后序最后节点是根，找到其在中序位置，左右部分就是左右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inS, <span class="keyword">int</span> inE, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postS, <span class="keyword">int</span> postE)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inS &gt; inE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postE];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = inS; i &lt;= inE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = i - inS, rightSize = inE - i;</span><br><span class="line">        root.left = buildTree(inorder, inS, i-<span class="number">1</span>, postorder, postS, postS+leftSize-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(inorder, i+<span class="number">1</span>, inE, postorder, postE-rightSize, postE-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1008-construct-binary-search-tree-from-preorder-traversal">❀1008. Construct Binary Search Tree from Preorder Traversal</h2>
<blockquote>
<p>前遍历构建二叉搜索树</p>
</blockquote>
<p>二叉搜索树，从前序拿到根节点后，根据搜索树性质右子树比根节点大，找到第一个大于根节点的位置即可<br>
实质上二叉搜索树中序是升序，即前序和中序可以唯一确定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bstFromPreorder(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[s];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = s; i &lt;= e; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[i] &gt; rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = bstFromPreorder(preorder,s+<span class="number">1</span>, i-<span class="number">1</span>);</span><br><span class="line">        root.right = bstFromPreorder(preorder,i,e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀889-construct-binary-tree-from-preorder-and-postorder-traversal">❀889. Construct Binary Tree from Preorder and Postorder Traversal</h2>
<blockquote>
<p>前序后序建树，任意一个即可</p>
</blockquote>
<p>不能唯一确定，思路依然是分割左右<br>
前序第一个和后序最后一个肯定相等，作为根节点<br>
前序第二节点表示左子树根，如果出现在后序中间，那么后序前半部分就是左子树，如果出现在后序末尾，那么可以作为整体，成为左右子树都可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructFromPrePost(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>, post, <span class="number">0</span>, post.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preS, <span class="keyword">int</span> preE, <span class="keyword">int</span>[] post, <span class="keyword">int</span> postS, <span class="keyword">int</span> postE)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preS &gt; preE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preS]);</span><br><span class="line">        <span class="keyword">if</span>(preS == preE) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre[preS+<span class="number">1</span>] == post[postE-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//左右都可以，这里放在左侧</span></span><br><span class="line">            root.left = constructFromPrePost(pre, preS+<span class="number">1</span>, preE, post, postS, postE-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> v = pre[preS+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = postS; i &lt; postE; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(post[i] == v) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> leftSize = i - postS + <span class="number">1</span>, rightSize = postE - i - <span class="number">1</span>;</span><br><span class="line">            root.left = constructFromPrePost(pre, preS+<span class="number">1</span>, preS+leftSize, post, postS, i);</span><br><span class="line">            root.right = constructFromPrePost(pre, preE-rightSize+<span class="number">1</span>,preE, post, i+<span class="number">1</span>, postE-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀95-unique-binary-search-trees-ii">❀95. Unique Binary Search Trees II</h2>
<blockquote>
<p>用1~n构建所有二叉搜索树</p>
</blockquote>
<p>分治，一个数组，选一个作为根，构建左右子树，再组合左右子树<br>
可以进一步使用哈希表缓存，避免重复构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) &#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low == high) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> TreeNode(low));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试以每个节点作为根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftParts = generateTrees(low, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightParts = generateTrees(i+<span class="number">1</span>, high);</span><br><span class="line">            <span class="comment">//左右侧组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; leftParts.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; rightParts.size(); k++) &#123;</span><br><span class="line">                    <span class="comment">//新建根节点，连接左右</span></span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = leftParts.get(j);</span><br><span class="line">                    root.right = rightParts.get(k);</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="序列化">序列化</h1>
<hr>
<h2 id="❀114-flatten-binary-tree-to-linked-list">❀114. Flatten Binary Tree to Linked List</h2>
<blockquote>
<p>二叉树转前序链表，右指针作为链表下一指针</p>
</blockquote>
<p>递归分治，先把左右子树都转链表，左链表接右链表，整体作为根的右子<br>
涉及到链表拼接，返回尾节点比较方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        flattenTail(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整后根节点不变，返回尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">flattenTail</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode leftTail = flattenTail(root.left);</span><br><span class="line">        TreeNode rightTail = flattenTail(root.right);</span><br><span class="line">        <span class="comment">//当前节点，左部分，右部分</span></span><br><span class="line">        <span class="keyword">if</span>(leftTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            leftTail.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> rightTail == <span class="keyword">null</span> ? leftTail : rightTail;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightTail == <span class="keyword">null</span> ? root : rightTail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，前序遍历，尾部追加成链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                 stack.push(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                 stack.push(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tail = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail.right = curr;</span><br><span class="line">                tail = tail.right;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀897-increasing-order-search-tree">❀897. Increasing Order Search Tree</h2>
<blockquote>
<p>搜索树调整成递增顺序，即只含右分支的直线结构</p>
</blockquote>
<p>相当于右指针作为链表指针，调整成升序单链表，采取中序遍历，调整后根节点可能变化<br>
基本思路是左子树变直线，接续结点，接续右子树的直线，然而需要左子树尾结点接续，返回头结点不太方便，将尾节点作为参数传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> increasingBST(root, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把树调整成直线，返回链表头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root, TreeNode tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tail;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = increasingBST(root.left, root);</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = increasingBST(root.right, tail);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部辅助头结点，链表生长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode dummy = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    TreeNode last = dummy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> dummy.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left);</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        last.right = node;</span><br><span class="line">        last = last.right;</span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀426-convert-bst-to-sorted-doubly-linked-list">❀426. Convert BST to Sorted Doubly Linked List</h2>
<blockquote>
<p>二叉搜索树转换为有序循环双链表，循环首尾相连，便于找到头尾节点</p>
</blockquote>
<p>中序遍历能按顺序遍历，适合构建链表<br>
递归, 维护前驱指针，全局维护因为各层都要感知最新变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">	Node last = dummy;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inorder(root);</span><br><span class="line">        <span class="comment">//链表主体完成后，调整首尾成环</span></span><br><span class="line">		last.right = dummy.right;</span><br><span class="line">		dummy.right.left = last;</span><br><span class="line">		<span class="keyword">return</span> dummy.right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inorder(node.left);</span><br><span class="line">		last.right = node;</span><br><span class="line">		node.left = last;</span><br><span class="line">		last = node;</span><br><span class="line">		inorder(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代版中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(), last = dummy;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Node curr = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                curr = stack.pop();</span><br><span class="line">                last.right = curr;</span><br><span class="line">                curr.left = last;</span><br><span class="line">                last = curr;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last.right = dummy.right;</span><br><span class="line">        dummy.right.left = last;</span><br><span class="line">        <span class="keyword">return</span> dummy.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分治法，调整左子树，调整右子树，最后和节点本身三部分拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node left = treeToDoublyList(root.left);</span><br><span class="line">		Node right = treeToDoublyList(root.right);</span><br><span class="line">		<span class="comment">// 节点本身调整为循环结构</span></span><br><span class="line">		root.left = root;</span><br><span class="line">		root.right = root;</span><br><span class="line">		<span class="keyword">return</span> contact(contact(left, root), right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个循环双链相连</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">contact</span><span class="params">(Node first, Node second)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span> || second == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> first == <span class="keyword">null</span> ? second : first;</span><br><span class="line">		&#125;</span><br><span class="line">		Node firstLast = first.left, secondLast = second.left;</span><br><span class="line">		firstLast.right = second;</span><br><span class="line">		second.left = firstLast;</span><br><span class="line">		secondLast.right = first;</span><br><span class="line">		first.left = secondLast;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="606-construct-string-from-binary-tree">606. Construct String from Binary Tree</h2>
<blockquote>
<p>树转字符串，子树用括号包起来，不影响结构时空子树可以省略括号</p>
</blockquote>
<p>分治法。根据各种情况决定括号怎么加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String leftStr = tree2str(t.left);</span><br><span class="line">        String rightStr = tree2str(t.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftStr.length() == <span class="number">0</span> &amp;&amp; rightStr.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t.val + <span class="string">""</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftStr.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t.val + <span class="string">"()("</span>+rightStr+<span class="string">")"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightStr.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t.val + <span class="string">"("</span>+leftStr+<span class="string">")"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.val + <span class="string">"("</span>+leftStr+<span class="string">")("</span> + rightStr +<span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="序列判定">序列判定</h1>
<hr>
<h2 id="❀255-verify-preorder-sequence-in-binary-search-tree">❀255. Verify Preorder Sequence in Binary Search Tree</h2>
<blockquote>
<p>判断数组是否是某个二叉搜索树的前序遍历</p>
</blockquote>
<p>利用栈O(N)<br>
如果小于栈顶，属于左子树进栈，如果大于栈顶说明轮到右子树，出栈，出栈后不能再有更小的数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始时，搜索树最小值无限制</span></span><br><span class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : preorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; low) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; i &gt; stack.peek())&#123;</span><br><span class="line">                low = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为顺序遍历，之前的数据不用了，可以把原数据直接覆写作为栈，空间O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE, index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : preorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;low) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(index&gt;=<span class="number">0</span> &amp;&amp; i&gt;preorder[index]) low = preorder[index--];</span><br><span class="line">            preorder[++index] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两树关系">两树关系</h1>
<hr>
<h2 id="❀101-symmetric-tree">❀101. Symmetric Tree</h2>
<blockquote>
<p>判断树是否对称</p>
</blockquote>
<p>利用判断两树镜像辅助函数，左右交叉递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirrorTree(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirrorTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isMirrorTree(p.left, q.right) &amp;&amp; isMirrorTree(p.right,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀100-same-tree">❀100. Same Tree</h2>
<blockquote>
<p>判断两树相同</p>
</blockquote>
<p>递归，同步遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，同步遍历<br>
但是要注意附加条件如果子树节点进栈，要么两个都进，要么都不进，因为仅仅前序遍历并不能确定唯一树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; s1 = <span class="keyword">new</span> LinkedList&lt;&gt;(), s2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        s1.push(p);</span><br><span class="line">        s2.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; !s2.isEmpty()) &#123;</span><br><span class="line">            TreeNode n1 = s1.pop();</span><br><span class="line">            TreeNode n2 = s2.pop();</span><br><span class="line">            <span class="keyword">if</span>(n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1.right != <span class="keyword">null</span>) s1.push(n1.right);</span><br><span class="line">            <span class="keyword">if</span>(n2.right != <span class="keyword">null</span>) s2.push(n2.right);</span><br><span class="line">            <span class="keyword">if</span>(s1.size() != s2.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1.left != <span class="keyword">null</span>) s1.push(n1.left);</span><br><span class="line">            <span class="keyword">if</span>(n2.left != <span class="keyword">null</span>) s2.push(n2.left);</span><br><span class="line">            <span class="keyword">if</span>(s1.size() != s2.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀572-subtree-of-another-tree">❀572. Subtree of Another Tree</h2>
<blockquote>
<p>判断是否是子树</p>
</blockquote>
<p>逐个节点匹配，如果是子树，那么走到某一节点两树相等，利用树相同辅助方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树操作">树操作</h1>
<hr>
<h2 id="617-merge-two-binary-trees">617. Merge Two Binary Trees</h2>
<blockquote>
<p>合并二叉树，对应位置结点求和</p>
</blockquote>
<p>前序遍历，如果不使用额外空间可以不创建新结点，直接修改t1结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        node.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        node.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="226-invert-binary-tree">226. Invert Binary Tree</h2>
<blockquote>
<p>翻转二叉树，交换左右子树</p>
</blockquote>
<p>DFS使用临时变量交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode invLeft = invertTree(root.left);</span><br><span class="line">        TreeNode invRight = invertTree(root.right);</span><br><span class="line">        root.left = invRight;</span><br><span class="line">        root.right = invLeft;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="公共祖先">公共祖先</h1>
<hr>
<h2 id="❀235-lowest-common-ancestor-of-a-binary-search-tree">❀235. Lowest Common Ancestor of a Binary Search Tree</h2>
<blockquote>
<p>二叉搜索树，找两节点最低公共祖先</p>
</blockquote>
<p>根据二叉搜索树特性，两个节点分布于最低公共祖先的左右两侧，或者两个节点本身就是公共祖先</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == p.val || curr.val == q.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr.val &gt; p.val &amp;&amp; curr.val &gt; q.val) &#123;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr.val &lt; p.val &amp;&amp; curr.val &lt; q.val) &#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀236-lowest-common-ancestor-of-a-binary-tree">❀236. Lowest Common Ancestor of a Binary Tree</h2>
<blockquote>
<p>最低公共祖先</p>
</blockquote>
<p>递归，如果当前节点就是其中一个目标节点，那么就是祖先<br>
如果两个目标分布在当前节点同侧，那么其中一个子树求祖先会是null<br>
两个目标出现在当前节点左右两侧，那么对两个子树求祖先都有值，当前节点就是祖先</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode leftCommon = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode rightCommon = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(leftCommon != <span class="keyword">null</span> &amp;&amp; rightCommon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftCommon != <span class="keyword">null</span> ? leftCommon : rightCommon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代, 层序构建父节点map, 路径向上求交点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        parent.put(root, <span class="keyword">null</span>);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.put(node.right, node);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.put(node.left, node);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(parent.containsKey(p) &amp;&amp; parent.containsKey(q))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//go up the paths</span></span><br><span class="line">        Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ancestors.contains(q)) &#123;</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者分别求出根到两个目标节点的路径，两个路径列表比较</p>
<h1 id="n叉树">n叉树</h1>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历子节点，注意先null判断子节点列表</li>
</ul>
<h2 id="❀589-n-ary-tree-preorder-traversal">❀589. N-ary Tree Preorder Traversal</h2>
<blockquote>
<p>前序遍历</p>
</blockquote>
<p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node node, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.children == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Node n : node.children) &#123;</span><br><span class="line">            preorder(n, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，子节点逆序进栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            Node n = stack.pop();</span><br><span class="line">            result.add(n.val);</span><br><span class="line">            <span class="keyword">if</span>(n.children == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n.children.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.push(n.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="590-n-ary-tree-postorder-traversal">590. N-ary Tree Postorder Traversal</h2>
<blockquote>
<p>后序遍历</p>
</blockquote>
<p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Node n : node.children) &#123;</span><br><span class="line">                postorder(n, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，子节点顺序进栈，结果整体逆序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(Node n: node.children) &#123;</span><br><span class="line">                    stack.push(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="429-n-ary-tree-level-order-traversal">429. N-ary Tree Level Order Traversal</h2>
<blockquote>
<p>层序序遍历</p>
</blockquote>
<p>BFS一次出队列一层，加入下一层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>) &#123;</span><br><span class="line">                Node node = queue.remove();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addAll(node.children); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="690-employee-importance">690. Employee Importance</h2>
<blockquote>
<p>树状结构人员图，给一个人，求部下所有和</p>
</blockquote>
<p>多叉树后序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">            map.put(e.id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getImportance(map,id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(Map&lt;Integer,Employee&gt; map, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Employee leader = map.get(id);</span><br><span class="line">        <span class="keyword">for</span>(Integer i : leader.subordinates) &#123;</span><br><span class="line">            sum += getImportance(map, i);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += leader.importance;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="559-maximum-depth-of-n-ary-tree">559. Maximum Depth of N-ary Tree</h2>
<blockquote>
<p>最长路径结点数</p>
</blockquote>
<p>递归, DFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(Node n : root.children) &#123;</span><br><span class="line">                <span class="keyword">int</span> subMax = maxDepth(n);</span><br><span class="line">                max = Math.max(subMax, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代，BFS层序遍历，统计一共几层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>,count = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            Node node = queue.remove();</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">if</span>(node.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">               queue.addAll(node.children);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                depth++;</span><br><span class="line">                count = queue.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
    <div class="donate_module">
        <div id="donate_board" class="donate_bar">
            <br>
            <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
        </div>
        <div id="donate_guide" class="donate_bar hidden">
            <br>
            <a href="/assets/reward/wechat_code.jpg"  class="fancybox">
                <img src="/assets/reward/wechat_code.jpg" title="微信打赏" height="190px" width="auto"/>
            </a>
            <span class="donate_space"></span>
            <a href="/assets/reward/alipay_code.jpg"  class="fancybox">
                <img src="/assets/reward/alipay_code.jpg" title="支付宝打赏" height="190px" width="auto"/>
            </a>
        </div>
        <span class="donate_txt">一分也是爱~</span> 
    </div>

        <div class="breakword">
    <hr>
    <p><strong>版权声明</strong></p>
    <p><img src="/assets/copyright/cc.png" alt=""></p>
    <p><a href="http://linest.github.io/leetcode/leetcode-tree.html">This site</a> by <a href="mailto:xlinest@gmail.com">Linest</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.
    <br>由<a href="mailto:xlinest@gmail.com">Linest</a>创作并维护的博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
    <p>本文永久链接：<a href="http://linest.github.io/leetcode/leetcode-tree.html">http://linest.github.io/leetcode/leetcode-tree.html</a></p>
</div>
      
    </div>
    
  </div>
  
    
  
</article>
<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关注点"><span class="toc-number">1.1.</span> <span class="toc-text">关注点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧"><span class="toc-number">1.2.</span> <span class="toc-text">技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意"><span class="toc-number">1.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础遍历"><span class="toc-number">2.</span> <span class="toc-text">基础遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀144-binary-tree-preorder-traversal"><span class="toc-number">2.1.</span> <span class="toc-text">❀144. Binary Tree Preorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀94-binary-tree-inorder-traversal"><span class="toc-number">2.2.</span> <span class="toc-text">❀94. Binary Tree Inorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀145-binary-tree-postorder-traversal"><span class="toc-number">2.3.</span> <span class="toc-text">❀145. Binary Tree Postorder Traversal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树层级"><span class="toc-number">3.</span> <span class="toc-text">二叉树层级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀102-binary-tree-level-order-traversal"><span class="toc-number">3.1.</span> <span class="toc-text">❀102. Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-binary-tree-level-order-traversal-ii"><span class="toc-number">3.2.</span> <span class="toc-text">107. Binary Tree Level Order Traversal II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-binary-tree-zigzag-level-order-traversal"><span class="toc-number">3.3.</span> <span class="toc-text">103. Binary Tree Zigzag Level Order Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀958-check-completeness-of-a-binary-tree"><span class="toc-number">3.4.</span> <span class="toc-text">❀958. Check Completeness of a Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀314-binary-tree-vertical-order-traversal"><span class="toc-number">3.5.</span> <span class="toc-text">❀314. Binary Tree Vertical Order Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#993-cousins-in-binary-tree"><span class="toc-number">3.6.</span> <span class="toc-text">993. Cousins in Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#637-average-of-levels-in-binary-tree"><span class="toc-number">3.7.</span> <span class="toc-text">637. Average of Levels in Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀513-find-bottom-left-tree-value"><span class="toc-number">3.8.</span> <span class="toc-text">❀513. Find Bottom Left Tree Value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀199-binary-tree-right-side-view"><span class="toc-number">3.9.</span> <span class="toc-text">❀199. Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#515-find-largest-value-in-each-tree-row"><span class="toc-number">3.10.</span> <span class="toc-text">515. Find Largest Value in Each Tree Row</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#623-add-one-row-to-tree"><span class="toc-number">3.11.</span> <span class="toc-text">623. Add One Row to Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#边界"><span class="toc-number">4.</span> <span class="toc-text">边界</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀545-boundary-of-binary-tree"><span class="toc-number">4.1.</span> <span class="toc-text">❀545. Boundary of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#872-leaf-similar-trees"><span class="toc-number">4.2.</span> <span class="toc-text">872. Leaf-Similar Trees</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分治与外部状态"><span class="toc-number">5.</span> <span class="toc-text">分治与外部状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀965-univalued-binary-tree"><span class="toc-number">5.1.</span> <span class="toc-text">❀965. Univalued Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#404-sum-of-left-leaves"><span class="toc-number">5.2.</span> <span class="toc-text">404. Sum of Left Leaves</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129-sum-root-to-leaf-numbers"><span class="toc-number">5.3.</span> <span class="toc-text">129. Sum Root to Leaf Numbers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子树状态"><span class="toc-number">6.</span> <span class="toc-text">子树状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀104-maximum-depth-of-binary-tree"><span class="toc-number">6.1.</span> <span class="toc-text">❀104. Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀111-minimum-depth-of-binary-tree"><span class="toc-number">6.2.</span> <span class="toc-text">❀111. Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀110-balanced-binary-tree"><span class="toc-number">6.3.</span> <span class="toc-text">❀110. Balanced Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀543-diameter-of-binary-tree"><span class="toc-number">6.4.</span> <span class="toc-text">❀543. Diameter of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#563-binary-tree-tilt"><span class="toc-number">6.5.</span> <span class="toc-text">563. Binary Tree Tilt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#508-most-frequent-subtree-sum"><span class="toc-number">6.6.</span> <span class="toc-text">508. Most Frequent Subtree Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀671-second-minimum-node-in-a-binary-tree"><span class="toc-number">6.7.</span> <span class="toc-text">❀671. Second Minimum Node In a Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#路径"><span class="toc-number">7.</span> <span class="toc-text">路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#257-binary-tree-paths"><span class="toc-number">7.1.</span> <span class="toc-text">257. Binary Tree Paths</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀112-path-sum"><span class="toc-number">7.2.</span> <span class="toc-text">❀112. Path Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀113-path-sum-ii"><span class="toc-number">7.3.</span> <span class="toc-text">❀113. Path Sum II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀437-path-sum-iii"><span class="toc-number">7.4.</span> <span class="toc-text">❀437. Path Sum III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀124-binary-tree-maximum-path-sum"><span class="toc-number">7.5.</span> <span class="toc-text">❀124. Binary Tree Maximum Path Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀687-longest-univalue-path"><span class="toc-number">7.6.</span> <span class="toc-text">❀687. Longest Univalue Path</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搜索树"><span class="toc-number">8.</span> <span class="toc-text">搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀700-search-in-a-binary-search-tree"><span class="toc-number">8.1.</span> <span class="toc-text">❀700. Search in a Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀270-closest-binary-search-tree-value"><span class="toc-number">8.2.</span> <span class="toc-text">❀270. Closest Binary Search Tree Value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀938-range-sum-of-bst"><span class="toc-number">8.3.</span> <span class="toc-text">❀938. Range Sum of BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀669-trim-a-binary-search-tree"><span class="toc-number">8.4.</span> <span class="toc-text">❀669. Trim a Binary Search Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搜索树中序"><span class="toc-number">9.</span> <span class="toc-text">搜索树中序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀538-convert-bst-to-greater-tree"><span class="toc-number">9.1.</span> <span class="toc-text">❀538. Convert BST to Greater Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#653-two-sum-iv-input-is-a-bst"><span class="toc-number">9.2.</span> <span class="toc-text">653. Two Sum IV - Input is a BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-find-mode-in-binary-search-tree"><span class="toc-number">9.3.</span> <span class="toc-text">501. Find Mode in Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀98-validate-binary-search-tree"><span class="toc-number">9.4.</span> <span class="toc-text">❀98. Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#783-minimum-distance-between-bst-nodes"><span class="toc-number">9.5.</span> <span class="toc-text">783. Minimum Distance Between BST Nodes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#530-minimum-absolute-difference-in-bst"><span class="toc-number">9.6.</span> <span class="toc-text">530. Minimum Absolute Difference in BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀230-kth-smallest-element-in-a-bst"><span class="toc-number">9.7.</span> <span class="toc-text">❀230. Kth Smallest Element in a BST</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搜索树改变结构"><span class="toc-number">10.</span> <span class="toc-text">搜索树改变结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀776-split-bst"><span class="toc-number">10.1.</span> <span class="toc-text">❀776. Split BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀450-delete-node-in-a-bst"><span class="toc-number">10.2.</span> <span class="toc-text">❀450. Delete Node in a BST</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反序列化建树"><span class="toc-number">11.</span> <span class="toc-text">反序列化建树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀108-convert-sorted-array-to-binary-search-tree"><span class="toc-number">11.1.</span> <span class="toc-text">❀108. Convert Sorted Array to Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109-convert-sorted-list-to-binary-search-tree"><span class="toc-number">11.2.</span> <span class="toc-text">109. Convert Sorted List to Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀105-construct-binary-tree-from-preorder-and-inorder-traversal"><span class="toc-number">11.3.</span> <span class="toc-text">❀105. Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-construct-binary-tree-from-inorder-and-postorder-traversal"><span class="toc-number">11.4.</span> <span class="toc-text">106. Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1008-construct-binary-search-tree-from-preorder-traversal"><span class="toc-number">11.5.</span> <span class="toc-text">❀1008. Construct Binary Search Tree from Preorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀889-construct-binary-tree-from-preorder-and-postorder-traversal"><span class="toc-number">11.6.</span> <span class="toc-text">❀889. Construct Binary Tree from Preorder and Postorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀95-unique-binary-search-trees-ii"><span class="toc-number">11.7.</span> <span class="toc-text">❀95. Unique Binary Search Trees II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列化"><span class="toc-number">12.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀114-flatten-binary-tree-to-linked-list"><span class="toc-number">12.1.</span> <span class="toc-text">❀114. Flatten Binary Tree to Linked List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀897-increasing-order-search-tree"><span class="toc-number">12.2.</span> <span class="toc-text">❀897. Increasing Order Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀426-convert-bst-to-sorted-doubly-linked-list"><span class="toc-number">12.3.</span> <span class="toc-text">❀426. Convert BST to Sorted Doubly Linked List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#606-construct-string-from-binary-tree"><span class="toc-number">12.4.</span> <span class="toc-text">606. Construct String from Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列判定"><span class="toc-number">13.</span> <span class="toc-text">序列判定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀255-verify-preorder-sequence-in-binary-search-tree"><span class="toc-number">13.1.</span> <span class="toc-text">❀255. Verify Preorder Sequence in Binary Search Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两树关系"><span class="toc-number">14.</span> <span class="toc-text">两树关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀101-symmetric-tree"><span class="toc-number">14.1.</span> <span class="toc-text">❀101. Symmetric Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀100-same-tree"><span class="toc-number">14.2.</span> <span class="toc-text">❀100. Same Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀572-subtree-of-another-tree"><span class="toc-number">14.3.</span> <span class="toc-text">❀572. Subtree of Another Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树操作"><span class="toc-number">15.</span> <span class="toc-text">树操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#617-merge-two-binary-trees"><span class="toc-number">15.1.</span> <span class="toc-text">617. Merge Two Binary Trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-invert-binary-tree"><span class="toc-number">15.2.</span> <span class="toc-text">226. Invert Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#公共祖先"><span class="toc-number">16.</span> <span class="toc-text">公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀235-lowest-common-ancestor-of-a-binary-search-tree"><span class="toc-number">16.1.</span> <span class="toc-text">❀235. Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀236-lowest-common-ancestor-of-a-binary-tree"><span class="toc-number">16.2.</span> <span class="toc-text">❀236. Lowest Common Ancestor of a Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#n叉树"><span class="toc-number">17.</span> <span class="toc-text">n叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀589-n-ary-tree-preorder-traversal"><span class="toc-number">17.1.</span> <span class="toc-text">❀589. N-ary Tree Preorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#590-n-ary-tree-postorder-traversal"><span class="toc-number">17.2.</span> <span class="toc-text">590. N-ary Tree Postorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#429-n-ary-tree-level-order-traversal"><span class="toc-number">17.3.</span> <span class="toc-text">429. N-ary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#690-employee-importance"><span class="toc-number">17.4.</span> <span class="toc-text">690. Employee Importance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#559-maximum-depth-of-n-ary-tree"><span class="toc-number">17.5.</span> <span class="toc-text">559. Maximum Depth of N-ary Tree</span></a></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Linest
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> customized by <a href="#">Linest</a> with <span class="octicon octicon-heart" style="color:red"></span>
				</div>
				<div class="hide">
						<a href="https://clustrmaps.com/site/x7rd" title="Visit tracker"><img src="//clustrmaps.com/map_v2.png?cl=ffffff&w=70&t=n&d=trdgmMc8YDC9aFR4WIBOzfE8f6bNwx_Pq7HA9YiG3sA" /></a>
				</div>
    </div>
  </div>
</footer>

    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true
	}
</script>

<!-- Baidu auto push -->
<script>
(function(){
	var bp = document.createElement('script');
	var curProtocol = window.location.protocol.split(':')[0];
	if (curProtocol === 'https') {
		bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	}
	else {
		bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	}
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(bp, s);
})();
</script>

<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<script>!function(i){var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function r(t,e){var n=new Image,i=t.getAttribute("data-original");n.onload=function(){t.src=i,e&&e()},n.src=i}function t(){for(var t=0;t<o.length;t++)e=o[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(i.innerHeight||document.documentElement.clientHeight)&&r(o[t],function(){o.splice(t,t)});var e,n}t(),i.addEventListener("scroll",t)}(this);</script></body>
</html>