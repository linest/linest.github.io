<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>LeetCode--数组篇 | Blog of Linest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结  关注点  数组长度 有序/部分有序 数值特性  范围 重复    操作  单向遍历 两侧中心遍历 二次正反向遍历 双列同步遍历 二分搜索  技巧  索引访问数组，一定要有前置条件限定范围 先不考虑特例，根据下标修正条件 Arrays.fill(arr, value)初始化 Arrays.copyOf(arr, length)复制 数组转List: Arrays.stream(arr).bo">
<meta property="og:type" content="website">
<meta property="og:title" content="LeetCode--数组篇">
<meta property="og:url" content="http://linest.github.io/leetcode/leetcode-array.html">
<meta property="og:site_name" content="Blog of Linest">
<meta property="og:description" content="总结  关注点  数组长度 有序/部分有序 数值特性  范围 重复    操作  单向遍历 两侧中心遍历 二次正反向遍历 双列同步遍历 二分搜索  技巧  索引访问数组，一定要有前置条件限定范围 先不考虑特例，根据下标修正条件 Arrays.fill(arr, value)初始化 Arrays.copyOf(arr, length)复制 数组转List: Arrays.stream(arr).bo">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-04-08T15:04:49.785Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode--数组篇">
<meta name="twitter:description" content="总结  关注点  数组长度 有序/部分有序 数值特性  范围 重复    操作  单向遍历 两侧中心遍历 二次正反向遍历 双列同步遍历 二分搜索  技巧  索引访问数组，一定要有前置条件限定范围 先不考虑特例，根据下标修正条件 Arrays.fill(arr, value)初始化 Arrays.copyOf(arr, length)复制 数组转List: Arrays.stream(arr).bo">
  
    <link rel="alternative" href="/atom.xml" title="Blog of Linest" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/fonts/octicons/octicons.css">
  <link rel="stylesheet" href="/css/fonts/font-awesome-4.6.3/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Linest</a></h1>
		</hgroup>

		
		<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/doodle">涂鸦</a></li>
				        
							<li><a href="/live2d">云撸猫</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tagcloud">标签&amp;分类</a></li>
				        
						</ul>
					</nav>	
				</section>
				
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">勤奋的懒惰者
爱听故事的人~
Zjuer
</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Linest</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Linest</h1>
			</hgroup>
			
			<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/doodle">涂鸦</a></li>
		        
					<li><a href="/live2d">云撸猫</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tagcloud">标签&amp;分类</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/leetcode/leetcode-array.html" class="article-date">
  	<time datetime="2020-04-08T15:04:49.785Z" itemprop="datePublished">2020-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode--数组篇
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="总结">总结</h1>
<hr>
<h2 id="关注点">关注点</h2>
<ul>
<li>数组长度</li>
<li>有序/部分有序</li>
<li>数值特性
<ul>
<li>范围</li>
<li>重复</li>
</ul>
</li>
</ul>
<h2 id="操作">操作</h2>
<ul>
<li>单向遍历</li>
<li>两侧中心遍历</li>
<li>二次正反向遍历</li>
<li>双列同步遍历</li>
<li>二分搜索</li>
</ul>
<h2 id="技巧">技巧</h2>
<ul>
<li>索引访问数组，一定要有前置条件限定范围</li>
<li>先不考虑特例，根据下标修正条件</li>
<li>Arrays.fill(arr, value)初始化</li>
<li>Arrays.copyOf(arr, length)复制</li>
<li>数组转List: Arrays.stream(arr).boxed().collect(Collectors.toList())</li>
<li>List转数组：list.stream().mapToInt(i-&gt;i).toArray()</li>
</ul>
<h1 id="单调性">单调性</h1>
<hr>
<h2 id="❀896-monotonic-array">❀896. Monotonic Array</h2>
<blockquote>
<p>判断是否单调数组</p>
</blockquote>
<p>维护两个标志单增单减，判断是否违反</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> increase = <span class="keyword">true</span>, decrease = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                decrease = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                increase = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> increase || decrease;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀941-valid-mountain-array">❀941. Valid Mountain Array</h2>
<blockquote>
<p>判断数组是否是山峰形</p>
</blockquote>
<p>分别从左右两端找山顶，判断吃否重合。注意避免单调增减情况，即峰顶不能出现在两端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.length - <span class="number">1</span> &amp;&amp; A[i+<span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; A[j-<span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == j &amp;&amp; i != A.length-<span class="number">1</span> &amp;&amp; j != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀665-non-decreasing-array">❀❀665. Non-decreasing Array</h2>
<blockquote>
<p>判断至多修改一个元素，是否能让数组单调递增</p>
</blockquote>
<p>单向遍历判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="comment">//长度2以下都可以修成递增</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//找到非递增位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="comment">//已经第二次找到，否定</span></span><br><span class="line">                <span class="keyword">if</span>(find) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    find = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//异常点在上侧，∴ 此时i位置在右下，判断排除左边，当前和前面保持递增</span></span><br><span class="line">                    <span class="comment">//特例修正，初始就异常</span></span><br><span class="line">                    <span class="keyword">boolean</span> upper = i == <span class="number">1</span> ? nums[i] &lt;= nums[i+<span class="number">1</span>] : nums[i-<span class="number">2</span>] &lt;= nums[i];</span><br><span class="line">                    <span class="comment">//异常点在下侧，∵ 此时i位置在下方，判断排除当前，左右两边保持递增</span></span><br><span class="line">                    <span class="comment">//特例修正，最后才异常</span></span><br><span class="line">                    <span class="keyword">boolean</span> lower = i == size-<span class="number">1</span> || nums[i-<span class="number">1</span>] &lt;= nums[i+<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//两种都不行，否定</span></span><br><span class="line">                    <span class="keyword">if</span>(!upper &amp;&amp; !lower) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀581-shortest-unsorted-continuous-subarray">❀❀581. Shortest Unsorted Continuous Subarray</h2>
<blockquote>
<p>排序一个子数组使得全局排序，求子数组长度，即求不符合整体递增的区间</p>
</blockquote>
<p>直观解法，先排序，然后比对不一样的区间，复杂度O(nlogn)<br>
O(n)解法，利用动态最大最小值</p>
<ul>
<li>从左向右遍历，如果发现值比当前最大值小，说明最大值错位，从最大值一直到当前都属于乱序，可以暂时认为当前位置为区间结束</li>
<li>从右向左遍历，如果发现值比当前最小值大，说明最小值错位，从最小值一直到当前都属于乱序，可以暂时认为当前位置为区间开始</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>], end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = nums[nums.length-<span class="number">1</span>], start = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; min) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start == -<span class="number">1</span> ? <span class="number">0</span> : end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀135-candy">❀❀135. Candy</h2>
<blockquote>
<p>给权重，要求至少分1颗，权重高的比两侧低的分的多，求最少需要多少糖</p>
</blockquote>
<p>分解为左侧关系和右侧关系<br>
如果元素i为峰顶，那么通过左侧关系，分配比左侧i-1多，而右侧关系i可能进一步增加，但是i-1比i低，不会增加<br>
即左侧建立起来的单调关系不会被右侧关系破坏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(res, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//只考虑左侧</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                res[i] = Math.max(res[i], res[i-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只考虑右侧</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;n-<span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                res[i] = Math.max(res[i], res[i+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            count += res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外建哈希">外建哈希</h1>
<hr>
<h2 id="217-contains-duplicate">217. Contains Duplicate</h2>
<blockquote>
<p>判断数组是否包含重复</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="219-contains-duplicate-ii">219. Contains Duplicate II</h2>
<blockquote>
<p>判断是否有重复，并且索引相距k以内</p>
</blockquote>
<p>维护map存索引,因为索引递增,所以总是更新成最新索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - map.get(nums[i]) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1346-check-if-n-and-its-double-exist">1346. Check If N and Its Double Exist</h2>
<blockquote>
<p>判断数组中是否存在2倍关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfExist</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="comment">//自身的2倍，自身作为其他数的2倍</span></span><br><span class="line">            <span class="keyword">if</span>(seen.contains(<span class="number">2</span>*i) || (i%<span class="number">2</span> == <span class="number">0</span>) &amp;&amp; seen.contains(i/<span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="349-intersection-of-two-arrays">349. Intersection of Two Arrays</h2>
<blockquote>
<p>数组求交集，结果无重复</p>
</blockquote>
<p>第一个数组建set,另一个查询，查到后删除避免重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums1) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.remove(num)) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="350-intersection-of-two-arrays-ii">350. Intersection of Two Arrays II</h2>
<blockquote>
<p>数组求交集，结果要包含重复</p>
</blockquote>
<p>用哈希表统计次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(i, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(i, map.get(i)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1207-unique-number-of-occurrences">1207. Unique Number of Occurrences</h2>
<blockquote>
<p>判断数组频次是否重复</p>
</blockquote>
<p>先map统计频次，再set判断重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : map.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="697-degree-of-an-array">697. Degree of an Array</h2>
<blockquote>
<p>求最高频次数字在数组中的最小长度</p>
</blockquote>
<p>统计数字频次，第一次出现位置，最后一次出现位置<br>
求最高频数字并计算间距</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cntMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; startMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; endMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = nums[i];</span><br><span class="line">            cntMap.put(val, cntMap.getOrDefault(val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            startMap.putIfAbsent(val,i);</span><br><span class="line">            endMap.put(val,i);</span><br><span class="line">            cnt = Math.max(cnt, cntMap.get(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : cntMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cntMap.get(i) == cnt) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = endMap.get(i) - startMap.get(i) + <span class="number">1</span>;</span><br><span class="line">                minLen = Math.min(minLen, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="760-find-anagram-mappings">760. Find Anagram Mappings</h2>
<blockquote>
<p>两个数组顺序不一样，求位置映射，重复元素可以多对一映射</p>
</blockquote>
<p>第二个数组建立哈希表，存新位置，遍历第一个数组联系新旧位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] anagramMappings(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            map.put(B[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            res[i] = map.get(A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="599-minimum-index-sum-of-two-lists">599. Minimum Index Sum of Two Lists</h2>
<blockquote>
<p>求两个无重复数组中索引和最小的公共元素</p>
</blockquote>
<p>哈希表记录第一个数组元素和索引，第二个数组判断条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++) &#123;</span><br><span class="line">            map.put(list1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> minSum = list1.length + list2.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.length; i++) &#123;</span><br><span class="line">            String s = list2[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s)) &#123;</span><br><span class="line">                <span class="keyword">int</span> sumIndex = map.get(s) + i;</span><br><span class="line">                <span class="keyword">if</span>(sumIndex == minSum) &#123;</span><br><span class="line">                    list.add(s);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sumIndex &lt; minSum) &#123;</span><br><span class="line">                    minSum = sumIndex;</span><br><span class="line">                    list.clear();</span><br><span class="line">                    list.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自身哈希">自身哈希</h1>
<hr>
<h2 id="❀448-find-all-numbers-disappeared-in-an-array">❀448. Find All Numbers Disappeared in an Array</h2>
<blockquote>
<p>数组中数字范围1~N，现在其中一些数字重复，导致一部分数字没出现，求没出现数字</p>
</blockquote>
<p>允许哈希表的话很简单，统计出现的数字，然后1-N逐个查找是否出现<br>
在不使用额外结构的话，采用负数的方式把数组自身作为哈希表使用<br>
如果一个数字出现，那么相应索引位上变为负值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//因为有的数字变成负数，需要求绝对值</span></span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀442-find-all-duplicates-in-an-array">❀442. Find All Duplicates in an Array</h2>
<blockquote>
<p>长为n的数组数字范围1~N，有一些出现两次，其他一次，求重复的数字</p>
</blockquote>
<p>出现一次时索引位置变负数，第二次出现可以感知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> original = i &lt; <span class="number">0</span> ? -i : i;</span><br><span class="line">            <span class="keyword">int</span> index = original - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(original);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀645-set-mismatch">❀645. Set Mismatch</h2>
<blockquote>
<p>1~n有一个数字缺失变成了另一个数字，找出重复的数字和缺失的数字</p>
</blockquote>
<p>利用原数组下标作为哈希表，负值标记是否出现，省去了哈希表空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(i) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//已经标为负数，重复</span></span><br><span class="line">                result[<span class="number">0</span>] = index + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//最终还是正数，缺失</span></span><br><span class="line">                result[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀41-first-missing-positive">❀❀41. First Missing Positive</h2>
<blockquote>
<p>可能有负值的n个数字构成数组，求第一个缺失的正数</p>
</blockquote>
<p>如果数组由1-n构成，此时连续，那么第一个缺失正数为n+1<br>
如果数组包含1-n外其他数字，那么缺失范围肯定在1~n内<br>
通常情况下开一个哈希标记，但是范围刚好和下标范围吻合，可以直接利用数组自身无需额外空间，即尝试把数字放在正确的位置上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//尝试每个位置，到不能交换为止</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">//如果在范围内，那么交换到正确位置</span></span><br><span class="line">            <span class="comment">//可能从后面换过来一个尚未判断的数,因此需要再次判断</span></span><br><span class="line">            <span class="keyword">int</span> val = nums[i], idx = val - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; <span class="number">0</span> &amp;&amp; idx &lt; n &amp;&amp; nums[idx] != val) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = val;</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//存在缺失直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组1~n连续无缺失</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="连续分段">连续分段</h1>
<hr>
<h2 id="485-max-consecutive-ones">485. Max Consecutive Ones</h2>
<blockquote>
<p>只包含01的数组，求1最长连续出现次数</p>
</blockquote>
<p>遍历计数，遇0更新最大，注意末尾可能没0最后需要再更新一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cnt = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    max = Math.max(max, cnt);</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="551-student-attendance-record-i">551. Student Attendance Record I</h2>
<blockquote>
<p>判断字符串A不超过1个,连续L长度不超过2个</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRecord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cntA = <span class="number">0</span>, maxL=<span class="number">0</span>, cntL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'A'</span>) &#123;</span><br><span class="line">                cntA++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                cntL++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxL = Math.max(maxL, cntL);</span><br><span class="line">                cntL = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxL = Math.max(maxL, cntL);</span><br><span class="line">        <span class="keyword">return</span> cntA &lt;= <span class="number">1</span> &amp;&amp; maxL &lt;=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="830-positions-of-large-groups">830. Positions of Large Groups</h2>
<blockquote>
<p>连续次数超过3的首尾位置</p>
</blockquote>
<p>尾触发统计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String S) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == S.charAt(i-<span class="number">1</span>)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(i-len, i-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            res.add(Arrays.asList(n-len, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="696-count-binary-substrings">696. Count Binary Substrings</h2>
<blockquote>
<p>统计有多少子串，01数量相等且0和1聚集，多次出现也算</p>
</blockquote>
<p>子串只能出现在分界处，比如0001111包含01,0011,000111，即两侧频次最少值<br>
连续分段统计，尾触发，子串数为两侧最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, pre = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || s.charAt(i) != s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                res += Math.min(cur, pre);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + Math.min(cur, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀443-string-compression">❀443. String Compression</h2>
<blockquote>
<p>连续相同字符用数字表示进行压缩，返回压缩后长度</p>
</blockquote>
<p>逐个字符遍历，尾触发，末尾再处理一遍，注意次数可能多位，需要转字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> prev = chars[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == prev) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                chars[index++] = prev;</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> s : String.valueOf(cnt).toCharArray()) &#123;</span><br><span class="line">                        chars[index++] = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = c;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            chars[index++] = prev;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> s : String.valueOf(cnt).toCharArray()) &#123;</span><br><span class="line">                    chars[index++] = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头触发，每遇到一个字符，统计后续所有相同字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexAns = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; chars.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = chars[index];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//统计后续所有相同字符</span></span><br><span class="line">            <span class="keyword">while</span>(index &lt; chars.length &amp;&amp; chars[index] == currentChar)&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[indexAns++] = currentChar;</span><br><span class="line">            <span class="keyword">if</span>(count != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : Integer.toString(count).toCharArray()) &#123;</span><br><span class="line">                    chars[indexAns++] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀849-maximize-distance-to-closest-person">❀849. Maximize Distance to Closest Person</h2>
<blockquote>
<p>1代表有人，0代表空，求一个位置使得尽可能离人最远，求这个距离</p>
</blockquote>
<p>统计0次数问题，开头0，中间0，尾部0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="keyword">int</span>[] seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> head = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seats.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seats[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//head &amp; middle</span></span><br><span class="line">                max = head ? i : Math.max(max, (cnt+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">                head = <span class="keyword">false</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tail</span></span><br><span class="line">        max = Math.max(max, cnt);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="605-can-place-flowers">605. Can Place Flowers</h2>
<blockquote>
<p>0代表空着，1代表种花，花不能相邻，给一个局面，判断是否还能种下n个花</p>
</blockquote>
<p>实际上是统计连续0次数问题<br>
两个1之间，1-&gt;0, 2-&gt;0, 3-&gt;1, 4-&gt;1, 5-&gt;2, 符合(次数-1)/2<br>
开头0可以假想10开头，转换成两个1之间情况<br>
末尾0，1-&gt;0, 2-&gt;1, 3-&gt;1, 4-&gt;2, 符合次数/2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += (count-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">            result += count/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="674-longest-continuous-increasing-subsequence">674. Longest Continuous Increasing Subsequence</h2>
<blockquote>
<p>最长连续递增序列</p>
</blockquote>
<p>发现下降时触发前面比较，最后收尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxLen = Math.max(maxLen, len);</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxLen,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀978-longest-turbulent-subarray">❀978. Longest Turbulent Subarray</h2>
<blockquote>
<p>波浪队列最长长度</p>
</blockquote>
<p>两种波浪，分别是奇数位/偶数位作为波峰<br>
尾触发，统计延续长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, len1 = <span class="number">1</span>, len2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; A[i] &gt; A[i-<span class="number">1</span>] || i%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; A[i] &lt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                len1++;</span><br><span class="line">                maxLen = Math.max(len1,maxLen);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                len1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; A[i] &gt; A[i-<span class="number">1</span>] || i%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; A[i] &lt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                len2++;</span><br><span class="line">                maxLen = Math.max(len2, maxLen);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                len2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(len1,maxLen);</span><br><span class="line">        maxLen = Math.max(len2,maxLen);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="投票">投票</h1>
<hr>
<h2 id="❀169-majority-element">❀169. Majority Element</h2>
<blockquote>
<p>找出超过半数的元素</p>
</blockquote>
<p>计数pk过程，超过半数肯定最终胜出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = nums[<span class="number">0</span>], count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == element) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                element = i;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀229-majority-element-ii">❀229. Majority Element II</h2>
<blockquote>
<p>超过三分之一的数字</p>
</blockquote>
<p>最多有两个数字满足<br>
投票法，两个位置，如果有空位就上，已在位就增加，如果没空位则两个候选都减<br>
假设有两个数字超过并且在位，那么其他数字小于三分之一，即使其他数字不内耗抵消，也抵消不完<br>
假设有一个数字超过并且在位，那么要抵消这个数字的一个就至少需要两个其他数字即首先要消一轮，然后上位一轮，还是抵消不完，这时留存的两个数字还需要进一步统计验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> can1 = <span class="number">0</span>,can2 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//候选流程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="comment">//vote 1</span></span><br><span class="line">            <span class="keyword">if</span>(cnt1 != <span class="number">0</span> &amp;&amp; i == can1) &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//vote 2</span></span><br><span class="line">            <span class="keyword">if</span>(cnt2 != <span class="number">0</span> &amp;&amp; i == can2) &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//be 1</span></span><br><span class="line">            <span class="keyword">if</span>(cnt1 == <span class="number">0</span>)&#123;</span><br><span class="line">                can1 = i;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//be 2</span></span><br><span class="line">            <span class="keyword">if</span>(cnt2 == <span class="number">0</span>)&#123;</span><br><span class="line">                can2 = i;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//pk</span></span><br><span class="line">            cnt1--;</span><br><span class="line">            cnt2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进一步验证，遍历统计</span></span><br><span class="line">        cnt1 = <span class="number">0</span>;</span><br><span class="line">        cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == can1)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == can2)&#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> th = nums.length/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 &gt; th) &#123;</span><br><span class="line">            res.add(can1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt2 &gt; th) &#123;</span><br><span class="line">            res.add(can2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀961-n-repeated-element-in-size-2n-array">❀961. N-Repeated Element in Size 2N Array</h2>
<blockquote>
<p>一个元素刚好半数次数，其余各不相等，找出这个元素</p>
</blockquote>
<p>先去掉一个元素，如果选对这个元素就是目标，那么其他元素会与之相等；如果选错，那么转化为余下的超过半数，由于其余各不相等，也不用计数直接替换即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chosen = A[<span class="number">0</span>], travel = A[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = A[i];</span><br><span class="line">            <span class="comment">//出现了重复，肯定是目标元素</span></span><br><span class="line">            <span class="keyword">if</span>(curr == chosen || curr == travel) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                travel = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> travel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀277-find-the-celebrity">❀277. Find the Celebrity</h2>
<blockquote>
<p>寻找明星，明星定义是其他人都认识但是不认识其他人</p>
</blockquote>
<p>如果a认识b，那么a不是明星，如果a不认识b那么b不是明星，即每次执行knows(a,b)方法都可以排除掉一个人<br>
第一次遍历，询问每个人是否认识候选，第二次遍历确认候选</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(knows(candidate, i))&#123;</span><br><span class="line">                candidate = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == candidate) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(i, candidate) || knows(candidate, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最值">最值</h1>
<hr>
<h2 id="747-largest-number-at-least-twice-of-others">747. Largest Number At Least Twice of Others</h2>
<blockquote>
<p>正数数组，判断最大值是否是其余值至少两倍，保证最大值唯一</p>
</blockquote>
<p>实际上是求最大和次大，已经保证唯一，无需在位检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>, max = -<span class="number">1</span>, secondMax = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max == -<span class="number">1</span> || nums[i] &gt; max) &#123;</span><br><span class="line">                secondMax = max;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; secondMax) &#123;</span><br><span class="line">                secondMax = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max &gt;= <span class="number">2</span>*secondMax ? index : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀414-third-maximum-number">❀414. Third Maximum Number</h2>
<blockquote>
<p>找第三大的数值，如果没有返回最大值</p>
</blockquote>
<p>保留3个席位，最值不可重复，已经在位则忽略<br>
从高位比较，如果上位，把当前位依次下放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Integer max1 = <span class="keyword">null</span>,max2 = <span class="keyword">null</span>,max3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="comment">//如果和前三任意相等，已经在位，忽略</span></span><br><span class="line">            <span class="keyword">if</span>(max1 !=<span class="keyword">null</span> &amp;&amp; i == max1 </span><br><span class="line">               || max2 !=<span class="keyword">null</span> &amp;&amp; i == max2 </span><br><span class="line">               || max3 !=<span class="keyword">null</span> &amp;&amp; i == max3)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(max1 == <span class="keyword">null</span> || i &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max2 == <span class="keyword">null</span> || i &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max3 == <span class="keyword">null</span> || i &gt; max3) &#123;</span><br><span class="line">                max3 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max3 == <span class="keyword">null</span> ? max1 : max3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="628-maximum-product-of-three-numbers">628. Maximum Product of Three Numbers</h2>
<blockquote>
<p>求三个数最大乘积</p>
</blockquote>
<p>因为有负数，所以最大值可能是最大三个数乘积，也可能是最小两个数和最大数乘积<br>
即求最大三个数和最小两个数，并且最值多次出现可以占多个席位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max1 = -<span class="number">1001</span>, max2 = -<span class="number">1001</span>, max3 = -<span class="number">1001</span>;</span><br><span class="line">        <span class="keyword">int</span> min1 = <span class="number">1001</span>, min2 = <span class="number">1001</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; max3) &#123;</span><br><span class="line">                max3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; min2) &#123;</span><br><span class="line">                min2 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max1 * max2 * max3, min1 * min2 * max1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="908-smallest-range-i">908. Smallest Range I</h2>
<blockquote>
<p>给数组和一个可供加减的数字，修正数组使得最大最小值最接近<br>
实际上就是找最大最小值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = A[<span class="number">0</span>], max = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; min) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> range = max-min-<span class="number">2</span>*K;</span><br><span class="line">        <span class="keyword">return</span> range &gt; <span class="number">0</span> ? range : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第k大数字">第k大数字</h1>
<hr>
<h2 id="❀215-kth-largest-element-in-an-array">❀215. Kth Largest Element in an Array</h2>
<blockquote>
<p>找到数组中第k大的数，保证存在</p>
</blockquote>
<p>利用快排partition思想，如果partition刚好以目标数位支点，那么得到答案<br>
快排每次考虑支点两侧，平均复杂度O(nlogn)，而这里每次舍去一半，1+1/2+1/4+… 平均复杂度O(n)， 最坏O(n2)<br>
BFPRT算法保证稳定O(n),实质上解决了支点选择问题：将数据分成大小为5的组，组内排序选中位数，所有中位数选中位数，以此为支点进行划分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = nums.length - k;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; target) &#123;</span><br><span class="line">                low = index + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &gt; target) &#123;</span><br><span class="line">                high = index -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//反正直接选，直接选尾部，省去交换到尾部操作</span></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[e];</span><br><span class="line">        <span class="keyword">int</span> i = s,j = e;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾部有支点，使用大于等于跳过</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, e);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</h2>
<blockquote>
<p>两个有序数组求中值，如果两个中值取平均</p>
</blockquote>
<p>最直观方法是先合并再找，复杂度O(m+n)<br>
考虑到有序特性，每次可以舍弃部分，复杂度O(log(m+n))<br>
转化为求两数组第K个数, 每个数组尝试取第k/2个数并且比较大小</p>
<ul>
<li>如果长度都够，小的一侧肯定不含，可以舍弃掉</li>
<li>如果一个长度不够，那么另一侧肯定不含，可以舍弃掉<br>
即每次舍弃k/2个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B.length;</span><br><span class="line">        <span class="comment">//左右中值, 第k个,比如4个数,取第2第3作为中值</span></span><br><span class="line">        <span class="comment">//如果奇数个数字,左右中值是同一个</span></span><br><span class="line">        <span class="keyword">int</span> l = (m + n + <span class="number">1</span>) / <span class="number">2</span>, r = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (getkth(A, <span class="number">0</span>, B, <span class="number">0</span>, l) + getkth(A, <span class="number">0</span>, B, <span class="number">0</span>, r)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找两数组第k个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getkth</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> aStart, <span class="keyword">int</span>[] B, <span class="keyword">int</span> bStart, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个数组已用完,从另一个找</span></span><br><span class="line">        <span class="keyword">if</span> (aStart &gt;= A.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> B[bStart + k - <span class="number">1</span>];    </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">if</span> (bStart &gt;= B.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[aStart + k - <span class="number">1</span>];   </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(A[aStart], B[bStart]);  </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> aIndex = aStart + k/<span class="number">2</span> - <span class="number">1</span>, bIndex = bStart + k/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果一边不够, 设为最大值, 舍弃另一边</span></span><br><span class="line">        <span class="keyword">int</span> aMid = aIndex &lt; A.length ? A[aIndex] : Integer.MAX_VALUE; </span><br><span class="line">        <span class="keyword">int</span> bMid = bIndex &lt; B.length ? B[bIndex] : Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//小的一边舍弃</span></span><br><span class="line">        <span class="keyword">if</span> (aMid &lt; bMid) &#123;</span><br><span class="line">            <span class="keyword">return</span> getkth(A, aStart + k/<span class="number">2</span>, B, bStart, k - k/<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> getkth(A, aStart, B, bStart + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="距离">距离</h1>
<hr>
<h2 id="❀243-shortest-word-distance">❀243. Shortest Word Distance</h2>
<blockquote>
<p>给一个单词组，给两个不同单词，求这两个单词最小距离</p>
</blockquote>
<p>设两个元素AB,最短距离无非就是最近的A…B或者B…A，总有一个在后面<br>
只要遍历到某个元素然后和之前的另一元素比较即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1 = -<span class="number">1</span>, idx2 = -<span class="number">1</span>, distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx2 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx1 - idx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                idx2 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx1 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx2 - idx1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="244-shortest-word-distance-ii">244. Shortest Word Distance II</h2>
<blockquote>
<p>多次求任意两个不同单词的最小距离</p>
</blockquote>
<p>因为是多次求，每次全量遍历比较耗时<br>
提前维护哈希表，存储每个单词和它出现的下标列表<br>
取出两个要求单词的位置列表，每次计算差值并舍去较小的一个</p>
<h2 id="❀245-shortest-word-distance-iii">❀245. Shortest Word Distance III</h2>
<blockquote>
<p>单词可以相同，求最短</p>
</blockquote>
<p>如果单词相等，那么原逻辑两个指针每次都会重合，这里加个条件，只计算第一次距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWordDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1 = -<span class="number">1</span>, idx2 = -<span class="number">1</span>, distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> isSame = word1.equals(word2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx2 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx1 - idx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                idx2 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx1 != -<span class="number">1</span> &amp;&amp; !isSame) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx2 - idx1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀821-shortest-distance-to-a-character">❀821. Shortest Distance to a Character</h2>
<blockquote>
<p>输出每个位置到指定字符位置的最短距离</p>
</blockquote>
<p>字符可能有多个，最短可能和左边也可能和右边<br>
两次正反遍历，第一次正向只考虑左边，第二次逆向只考虑右边，每个位置取两次最短</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(res,n);</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == C) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos != -<span class="number">1</span>) &#123;</span><br><span class="line">                res[i] = i - pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == C) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos != -<span class="number">1</span>) &#123;</span><br><span class="line">                res[i] = Math.min(res[i], pos - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="首尾">首尾</h1>
<hr>
<h2 id="977-squares-of-a-sorted-array">977. Squares of a Sorted Array</h2>
<blockquote>
<p>有序数组，生成平方后的有序数组</p>
</blockquote>
<p>绝对值大的肯定在首尾，双指针遍历每次取其一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length-<span class="number">1</span>, n = A.length;</span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = A[i] * A[i], q = A[j] * A[j];</span><br><span class="line">            <span class="keyword">if</span>(p &gt; q) &#123;</span><br><span class="line">                result[n] = p;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[n] = q;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原地交换移位">原地交换移位</h1>
<hr>
<h2 id="❀189-rotate-array">❀189. Rotate Array</h2>
<blockquote>
<p>数组循环右移</p>
</blockquote>
<p>原地操作，部分逆序再整体逆序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len-k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,len-k, len-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀905-sort-array-by-parity">❀905. Sort Array By Parity</h2>
<blockquote>
<p>调整数组使得偶数在前，奇数在后</p>
</blockquote>
<p>双指针两侧交换，注意任何时候注意数组越界检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i&lt;j保证不会越界，最多ij重合，交换也无所谓</span></span><br><span class="line">            <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀922-sort-array-by-parity-ii">❀922. Sort Array By Parity II</h2>
<blockquote>
<p>调整数组使得奇数位置为奇数，偶数位置为偶数</p>
</blockquote>
<p>双指针同侧遍历，一个只遍历奇数位，一个只遍历偶数位，适时交换数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; A.length) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; A.length &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; A.length &amp;&amp; j % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; A.length &amp;&amp; j &lt; A.length) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原地覆写">原地覆写</h1>
<hr>
<h2 id="❀88-merge-sorted-array">❀88. Merge Sorted Array</h2>
<blockquote>
<p>两个有序数组，假设第一个长度足够，把第二个合并进去</p>
</blockquote>
<p>头部被原数据占用，采用从后端进行归并的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m-<span class="number">1</span>, j=n-<span class="number">1</span>, k = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;=<span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀27-remove-element">❀27. Remove Element</h2>
<blockquote>
<p>原地删除指定值，返回新长度</p>
</blockquote>
<p>用后面其他值覆盖掉要删除的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val) &#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀26-remove-duplicates-from-sorted-array">❀26. Remove Duplicates from Sorted Array</h2>
<blockquote>
<p>有序数组原地去重，返回新长度</p>
</blockquote>
<p>判断和已有结果末尾是否重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">0</span> || nums[i] != nums[index-<span class="number">1</span>]) &#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀80-remove-duplicates-from-sorted-array-ii">❀80. Remove Duplicates from Sorted Array II</h2>
<blockquote>
<p>有序数组，原地处理，允许最多出现两次其余删除</p>
</blockquote>
<p>判断已有结果末尾是否已经有两个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">2</span> || i != nums[index-<span class="number">2</span>]) &#123;</span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀283-move-zeroes">❀283. Move Zeroes</h2>
<blockquote>
<p>把0移到末尾，保持其他非0数字相对顺序</p>
</blockquote>
<p>不能收尾交换，会破坏相对顺序<br>
如果一个元素不是0，而且需要移动，那么移动到前面正确位置，当前位置0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//要判断是否已经在正确位置，否则会错误清零</span></span><br><span class="line">                <span class="keyword">if</span>(i != idx) &#123;</span><br><span class="line">                    nums[idx] = nums[i];</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1089-duplicate-zeros">❀1089. Duplicate Zeros</h2>
<blockquote>
<p>每遇到一个0，在后侧插入一个0，后面数据移位，越界的丢弃</p>
</blockquote>
<p>比如120304变为120030[04],4前面2个0需要移动2位，3前面1个0需要移动1位<br>
前面出现几个0，就要最终移几位，先统计0个数<br>
从左向右遍历时右侧插0会影响下一遍历，因此采取从右向左遍历，计算每个数字移位后的下标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, n = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="comment">//后面复制一个0</span></span><br><span class="line">                <span class="keyword">if</span>(i + cnt + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    arr[i + cnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试移动后是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(i + cnt &lt; n) &#123;</span><br><span class="line">                arr[i + cnt] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈辅助">栈辅助</h1>
<hr>
<h2 id="❀739-daily-temperatures">❀739. Daily Temperatures</h2>
<blockquote>
<p>给出每天温度，求每天需要等多少天才能迎来更暖和的天气</p>
</blockquote>
<p>实际是求每个元素距离后方更大元素的距离<br>
遍历元素，当前元素可能是前面元素的更大元素，因此把栈顶小于的都弹出，当前元素后面还未知，当前应进栈等待后面<br>
因为求距离需要下标，因此选择下标进栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = T[i];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; curr &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev = stack.pop();</span><br><span class="line">                res[prev] = i - prev;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀496-next-greater-element-i">❀496. Next Greater Element I</h2>
<blockquote>
<p>数组无重复，num1是num2子集，求每个num1在num2中后面更大的值，没有就-1</p>
</blockquote>
<p>即相当于求所有元素后面最大值，子集num1相当于查询点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//元素下标，更大元素下标</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; num &gt; stack.peek()) &#123;</span><br><span class="line">                hash.put(stack.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="comment">//查询</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = hash.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀946-validate-stack-sequences">❀946. Validate Stack Sequences</h2>
<blockquote>
<p>给定入栈序列，随时可弹出，判断出栈序列合法性</p>
</blockquote>
<p>模拟入栈，匹配弹出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            stack.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == popped.length &amp;&amp; stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀84-largest-rectangle-in-histogram">❀84. Largest Rectangle in Histogram</h2>
<blockquote>
<p>给出数组代表高度，求最大矩形面积</p>
</blockquote>
<p>中心扩展法，以一个高度为基础，向左向右在满足高度条件下扩展，复杂度O(n2)<br>
注意以一个高度作为起始是不对的，比如凹形，结果是以中间为高度贯穿两侧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = heights[i];</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//向左扩展</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; heights[j] &gt;= h; j--) &#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向右扩展</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; heights[j] &gt;= h; j++) &#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;</span><br><span class="line">            area = Math.max(area, w*h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为要计算宽度需要下标差，栈保存下标<br>
当前的比栈顶低，那么栈顶无法向右扩要弹出，因此新来的相当于右边界<br>
每次入栈时，比当前高的都出栈，等同于当前高度向左扩充，那么栈内还留存的相当于左边界<br>
整体思路是以每个尝试向左向右延伸，栈辅助，复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.length; i++) &#123;</span><br><span class="line">            <span class="comment">//尾触发，末尾添加-1，保证遍历结束时把留存的弹出</span></span><br><span class="line">            <span class="keyword">int</span> cur = (i == heights.length) ? -<span class="number">1</span> : heights[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= cur) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = heights[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> rightExcludeBorder = i;</span><br><span class="line">                <span class="comment">//如果栈内没有，说明左边界就是0前面，用-1表示</span></span><br><span class="line">                <span class="keyword">int</span> leftExcludeBorder = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="keyword">int</span> w = rightExcludeBorder - leftExcludeBorder - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="队列辅助">队列辅助</h1>
<hr>
<h2 id="1047-remove-all-adjacent-duplicates-in-string">1047. Remove All Adjacent Duplicates In String</h2>
<blockquote>
<p>相同的成对消除，直到不能消为止</p>
</blockquote>
<p>利用栈保持前面待消除的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == -<span class="number">1</span> || stack[top] != c) &#123;</span><br><span class="line">                stack[++top] = c;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(stack, <span class="number">0</span>, top+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀316-remove-duplicate-letters">❀316. Remove Duplicate Letters</h2>
<blockquote>
<p>每个字母可能出现在多个位置，删除重复字母，并且使得结果字母序最小</p>
</blockquote>
<p>如果发现队尾大，并且后面还有，那么放弃栈里的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] inQueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = (<span class="keyword">int</span>)(s.charAt(i) - <span class="string">'a'</span>);</span><br><span class="line">            count[idx]--;</span><br><span class="line">            <span class="comment">//已经在栈里忽略</span></span><br><span class="line">            <span class="keyword">if</span> (inQueue[idx]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//队列末尾比较大，并且值在后面还有，可以选后面的</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekLast() &gt; idx &amp;&amp; count[dq.peekLast()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                inQueue[dq.pollLast()] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inQueue[idx] = <span class="keyword">true</span>;</span><br><span class="line">            dq.offerLast(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(dq.pollFirst() + <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀239-sliding-window-maximum">❀❀239. Sliding Window Maximum</h2>
<blockquote>
<p>求长度k滑动窗口每个时刻最大值</p>
</blockquote>
<p>维护双端队列，存储索引，之所以存索引是方便判断是否在窗口内<br>
双端队列内下标对应的值时刻保持递减，弹出一个，最大的就在头部<br>
当前值进入窗口</p>
<ul>
<li>将队列头部已经不在窗口的值移除</li>
<li>如果比队列末尾指向的数字小，那么直接进入队列，之所以进入是为了防止前面最大值失效，失效后可以顶上</li>
<li>如果比队列末尾指向的数字大，说明之前队列维护的更小值没用了，从末尾弹出后当前再进入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> resLen = k == <span class="number">0</span> ? <span class="number">0</span> : nums.length-k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[resLen];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> startIndex = i - k + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//一次滑动一格，最多过期一个，无需while</span></span><br><span class="line">            <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; queue.peekFirst() &lt; startIndex) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> curr = nums[i];</span><br><span class="line">            <span class="comment">//把窗口内小于当前的都移除</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; curr) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            <span class="keyword">if</span>(startIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res[startIndex] = nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优先队列">优先队列</h1>
<hr>
<h2 id="1046-last-stone-weight">1046. Last Stone Weight</h2>
<blockquote>
<p>每次取两个最大的相撞，留下差值，求最后留下大小</p>
</blockquote>
<p>优先队列模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; Integer.compare(b,a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : stones) &#123;</span><br><span class="line">            pq.offer(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pq.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> y = pq.poll();</span><br><span class="line">            <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">                pq.offer(x-y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.isEmpty() ? <span class="number">0</span> : pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1198-find-smallest-common-element-in-all-rows">❀1198. Find Smallest Common Element in All Rows</h2>
<blockquote>
<p>每行升序，求所有行最小的公共元素</p>
</blockquote>
<p>合并多个有序队列思路，当堆中最小值等于最大值时，即公共元素<br>
最小值通过小顶堆获取，最大值每次插入时外部维护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestCommonElement</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//元素值，行，列</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mat[i][<span class="number">0</span>],i,<span class="number">0</span>&#125;);</span><br><span class="line">            max = Math.max(max, mat[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.isEmpty() &amp;&amp; max != minHeap.peek()[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] data = minHeap.poll();</span><br><span class="line">            <span class="keyword">int</span> row = data[<span class="number">1</span>], col = data[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(col == n-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> newVal = mat[row][col+<span class="number">1</span>];</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newVal, row, col+<span class="number">1</span>&#125;);</span><br><span class="line">            max = Math.max(max, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者二分搜索，尝试第一行每个元素为目标，在所有行搜索</p>
<h2 id="❀373-find-k-pairs-with-smallest-sums">❀373. Find K Pairs with Smallest Sums</h2>
<blockquote>
<p>两个有序升序数组，求k个最小和值的数对，同一位置可对应另一数组多个位置</p>
</blockquote>
<p>a0b0 a0b1 a0b2 升序  a1b0 a1b1 a1b2 升序 即a每个元素对应一个升序数对列表，有序列表合并问题<br>
将一个数组所有元素和第二个数组首元素组合放入堆，并记录第二个元素位置，相当于第一个数组每个元素形成一个数对组合升序队列，把每个队列头节点加入堆中，每次弹出时，尝试推进第二个元素位置，即把次大值作为候选加入堆<br>
优先队列中始终只有k个，弹出一个补一个，每调整一次O(logn)，整体复杂度O(klogk)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((a,b) -&gt; (a[<span class="number">0</span>] + a[<span class="number">1</span>])- (b[<span class="number">0</span>] + b[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//最多k个就够用，多了没用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//nums1 nums2 nums2index</span></span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; queue.size()&gt;<span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] v = queue.poll();</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">            <span class="comment">//取后续值作为候选加入优先队列</span></span><br><span class="line">            <span class="keyword">int</span> index = v[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(index &lt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v[<span class="number">0</span>],nums2[index+<span class="number">1</span>],index+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分搜索">二分搜索</h1>
<hr>
<p>序列1,2,3</p>
<ul>
<li>搜索2，那么第一次中间就会命中</li>
<li>搜索1，第一次中间，第二次中间就是左侧命中，左右不重合</li>
<li>搜索3，第一次中间，第二次还是中间，第三次左右重合命中<br>
while条件里有等于选项，只要不命中，左右都会相对中点移动，因此会成功终止<br>
如果只有单侧移动的话，循环可以没有等于选项，最后会左右重合收敛到一点，但是要注意两个相邻的索引时的情况，避免死循环</li>
<li>根据默认二分公式，mid会和左边重合，因此左边必须有移动行为，<code>low = mid + 1</code></li>
<li>如果左边没有移动行为，那么可以改良二分公式，<code>mid = (low + high + 1)/2</code>,使得相邻时落在右边</li>
</ul>
<p>分类</p>
<ul>
<li>基础二分</li>
<li>边界二分</li>
<li>无序/部分有序特殊二分</li>
<li>无序范围二分</li>
</ul>
<p>考虑不存在的状况</p>
<h2 id="❀704-binary-search">❀704. Binary Search</h2>
<blockquote>
<p>有序无重复数组搜索目标的下标，没有返回-1</p>
</blockquote>
<p>基础版二分搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="374-guess-number-higher-or-lower">374. Guess Number Higher or Lower</h2>
<blockquote>
<p>提供一个guess接口可以判定，猜出1~n间的数字</p>
</blockquote>
<p>二分搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> result = guess(mid);</span><br><span class="line">            <span class="keyword">if</span>(result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀702-search-in-a-sorted-array-of-unknown-size">❀702. Search in a Sorted Array of Unknown Size</h2>
<blockquote>
<p>未知长度数组搜索,提供ArrayReader.get(k)函数，越界返回整数最大值</p>
</blockquote>
<p>由于未知上界，需要快速估算一个上界，采取2指数方式扩展范围，寻找上界过程中顺便也改动下界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(ArrayReader reader, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(reader.get(high) &lt; target)&#123;</span><br><span class="line">            low = high;</span><br><span class="line">            high *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> val = reader.get(mid);</span><br><span class="line">            <span class="keyword">if</span>(val &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀34-find-first-and-last-position-of-element-in-sorted-array">❀34. Find First and Last Position of Element in Sorted Array</h2>
<blockquote>
<p>有序有重复数组，搜索指定元素的起点和终点，没有返回-1</p>
</blockquote>
<p>分解成两个二分搜索过程<br>
搜索起点时，如果找到元素，前面可能还有，所以调整上界时包含等于<br>
搜索终点时，如果找到元素，后面可能还有，所以调整下界时包含等于<br>
注意调整中点公式，选择左还是右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; searchFirst(nums, target), searchLast(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                <span class="comment">//等于时，自身可能是结果，但是前面可能还有，所以自身作为上界继续搜索</span></span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low] == target ?  low : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//左面可能不动，中心需要改良到右侧</span></span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//等于时，自身可能是结果，但是后面可能还有，所以自身作为上界继续搜索</span></span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low] == target ?  low : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="278-first-bad-version">278. First Bad Version</h2>
<blockquote>
<p>从某一个版本开始坏掉，查找第一个坏掉的版本</p>
</blockquote>
<p>相当于二值000111格式，即求第一个1位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">boolean</span> isBad = isBadVersion(mid);</span><br><span class="line">            <span class="keyword">if</span>(isBad)&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀744-find-smallest-letter-greater-than-target">❀744. Find Smallest Letter Greater Than Target</h2>
<blockquote>
<p>有序字符串，查找大于目标的最小值，没有就返回首字母</p>
</blockquote>
<p>二分搜索，第一个大于位置<br>
下界小于等于，会移动，最终收敛一定是大于目标的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = letters.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &lt;= target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[low] &gt; target ? letters[low] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀35-search-insert-position">❀❀35. Search Insert Position</h2>
<blockquote>
<p>有序无重复数组，找到目标插入位置，插入即占据位置，原位及之后元素都向后移动</p>
</blockquote>
<p>即找到等于或者第一个大于的位置<br>
注意如果不存在的话说明不在已有范围内，需要后面新追加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low] &gt;= target ? low : nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀162-find-peak-element">❀162. Find Peak Element</h2>
<blockquote>
<p>无序数组找其中一个峰值，假定数组两端无限小</p>
</blockquote>
<p>两端无限小，那么左界是上升阶段，右界是下降阶段<br>
一个上升阶段和一个下降阶段中间必有一个峰值，因此二分搜索，找到两个中间值判断阶段取舍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="852-peak-index-in-a-mountain-array">852. Peak Index in a Mountain Array</h2>
<blockquote>
<p>给一个至少三个数据的先上升后下降的数组，求峰顶索引</p>
</blockquote>
<p>初始数组长度不是1，中点后面mid+1确保不会越界，可以用于比较<br>
如果中点后面比中值大，那么中点位置在上升期还没到顶，可以排除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &lt; A[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀540-single-element-in-a-sorted-array">❀540. Single Element in a Sorted Array</h2>
<blockquote>
<p>有序数组，只有一个数出现一次，其他两次，求这个数</p>
</blockquote>
<p>二分能达到O(logn)<br>
一定能找到，不用考虑不存在的情况<br>
这个数两侧都是偶数个，根据中点右侧数量判断目标在哪边<br>
mid和mid+1不用检查越界，因为即使相邻两个数，mid会落在左侧，右侧永远有值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//中点本身和右侧是一对，但是右侧是偶数个说明目标在右侧</span></span><br><span class="line">                <span class="keyword">if</span>((high - mid) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//已知中点成对，全部跳过</span></span><br><span class="line">                    low = mid + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//中点本身和右侧不是一对，右侧偶数个说明右侧无目标</span></span><br><span class="line">                <span class="comment">//中点可能是目标点，不能移动</span></span><br><span class="line">                <span class="keyword">if</span>((high - mid) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    high = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀1060-missing-element-in-sorted-array">❀❀1060. Missing Element in Sorted Array</h2>
<blockquote>
<p>升序数组里第k个缺失的数字</p>
</blockquote>
<p>计算总共缺失个数：上下范围计算应有个数 - 实际有的个数<br>
首先判断缺失的数字在不在数组范围内</p>
<ul>
<li>不在数组范围，直接基于最大值</li>
<li>在数组范围，二分搜索</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">//数组最大值最小值之间应该有的数字个数减去实际有的个数,即数组内缺失的数量</span></span><br><span class="line">        <span class="keyword">int</span> countMissing = (nums[len - <span class="number">1</span>] - nums[<span class="number">0</span>] + <span class="number">1</span>) - len;</span><br><span class="line">        <span class="comment">//数组内缺失的不够，即所求值超出了最大值，从后面找即可</span></span><br><span class="line">        <span class="keyword">if</span> (countMissing &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[len - <span class="number">1</span>] + (k - countMissing);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//low和mid间缺失数量</span></span><br><span class="line">            <span class="keyword">int</span> newCountMissing = (nums[mid] - nums[low] + <span class="number">1</span>) - (mid - low + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//即使等于k个，那中值肯定不是缺的，要缩减</span></span><br><span class="line">            <span class="keyword">if</span> (newCountMissing &gt;= k) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//还需要在新范围内找第k个缺失，k不变</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">                <span class="comment">//跳过一部分，新范围内还缺失的个数</span></span><br><span class="line">                k -= newCountMissing;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终收敛一个数字，在这个数字基础上还缺失剩余的k个</span></span><br><span class="line">        <span class="keyword">return</span> nums[low] + k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀33-search-in-rotated-sorted-array">❀❀33. Search in Rotated Sorted Array</h2>
<blockquote>
<p>无重复的有序数组旋转后，进行特定值搜索</p>
</blockquote>
<p>整体框架是二分，由于被旋转过，需要一定规则指导目标在中值哪一侧，进而决定移动方向<br>
旋转后要么依然不变，要么变成闪电状</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> /  /</span><br><span class="line">/    /</span><br></pre></td></tr></table></figure>
<p>根据比较第一个元素，判断位于哪个分段，如果大于等于则在第一段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//中值小于目标，需要找更大的数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目前中间值在第一段，目标是更大的数，只能向右找</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//目前中值在第二段，更大的数可能在左边也可能右边</span></span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        <span class="comment">//如果目标在第一段，向左找</span></span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//如果目标也在第二段，向右找</span></span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀153-find-minimum-in-rotated-sorted-array">❀153. Find Minimum in Rotated Sorted Array</h2>
<blockquote>
<p>无重复的有序数组旋转后，找最小值</p>
</blockquote>
<p>有序数组旋转后，变成两段升序，也可能还是原样一段升序</p>
<ul>
<li>如果还是升序，那么最小值就在左侧</li>
<li>如果两端升序，在第一段说明最小在后面，跳过并推进，在第二段说最小可能在前面，不跳过</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//没旋转</span></span><br><span class="line">        <span class="keyword">if</span>(nums[low] &lt;= nums[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//旋转两段</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀154-find-minimum-in-rotated-sorted-array-ii">❀❀154. Find Minimum in Rotated Sorted Array II</h2>
<blockquote>
<p>有重复的有序数组旋转后，找最小值</p>
</blockquote>
<p>含有重复值条件下，除了无重复时的两种状态外，还有可能出现收尾相等的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__/  __</span><br><span class="line">    /</span><br></pre></td></tr></table></figure>
<p>依然是和第一元素比较，如果能严格判断出大小关系，那么可以继续二分<br>
如果和第一元素相等，那么可能在左边，也可能在右边，无法知道方向，那么就跳过左右值中较大的值进行范围缩减，最坏退化成O(n)<br>
直接比较首尾已经无法判断是否旋转，如果没旋转，最后会找到最大值，返回值需要修正</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无法判断时，因为要找最小，所以跳过一个大值</span></span><br><span class="line">                <span class="keyword">if</span>(nums[low] &gt; nums[high]) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums[low], nums[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀287-find-the-duplicate-number">❀❀287. Find the Duplicate Number</h2>
<blockquote>
<p>长度n+1的数组，数字范围1~n，其中有一个数字重复若干次，找这个数字</p>
</blockquote>
<p>如果可以计数很简单，题目要求不使用额外空间<br>
虽然数组本身无序，但是可以利用范围遍历统计，复杂度O(nlogn)<br>
重复数字最少出现2次，甚至更多次挤占其他数字</p>
<ul>
<li>如果<code>[1,k]</code>范围内没重复且连续，那么等于k个，有缺失会小于k个</li>
<li>如果<code>[1,k]</code>范围内包含重复数字，那么总数量肯定大于k个</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//目标最小值为1，最大值为n即数组长度减1</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="和值">和值</h1>
<hr>
<h2 id="❀1-two-sum">❀1. Two Sum</h2>
<blockquote>
<p>找到两个数和为指定值，返回一组索引</p>
</blockquote>
<p>哈希查表，存储数字和对应索引<br>
由于最终找到两个数，必然是一前一后，因此边遍历边找即可，遍历时查看之前是否出现过另一值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> other = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(other))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(other), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1010-pairs-of-songs-with-total-durations-divisible-by-60">❀1010. Pairs of Songs With Total Durations Divisible by 60</h2>
<blockquote>
<p>两正数和为60倍数的数对个数</p>
</blockquote>
<p>对60取余，转化为两数和为60问题<br>
特例，如果原本就是60倍数，那么余数为0, 0和0也认为和60<br>
每个数只考虑前面已有结果，即每个数字作为数对中的后者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="keyword">int</span>[] time)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = time[i] % <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">int</span> pair = t == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">60</span> - t;</span><br><span class="line">            cnt += map.getOrDefault(pair, <span class="number">0</span>);</span><br><span class="line">            map.put(t, map.getOrDefault(t,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀167-two-sum-ii-input-array-is-sorted">❀167. Two Sum II - Input array is sorted</h2>
<blockquote>
<p>有序数组，求和等于指定值的两个数字其中一组索引(起始为1)</p>
</blockquote>
<p>双侧指针，向中心收缩<br>
最左侧和最右侧表示最左侧能参与的最大和值，也表示最右侧能参与的最小和值<br>
如果和值小于目标，说明最左侧无法达成，舍弃最左侧<br>
如果和值大于目标，说明最右侧无法达成，舍弃最右侧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>, j+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1099-two-sum-less-than-k">1099. Two Sum Less Than K</h2>
<blockquote>
<p>求两数和值小于K的最大和值</p>
</blockquote>
<p>排序，双端计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoSumLessThanK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = A.length - <span class="number">1</span>, res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = A[left] + A[right];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; K) &#123;</span><br><span class="line">                find = <span class="keyword">true</span>;</span><br><span class="line">                left++;</span><br><span class="line">                res = Math.max(sum, res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀16-3sum-closest">❀16. 3Sum Closest</h2>
<blockquote>
<p>求三个数相加最接近目标的值</p>
</blockquote>
<p>三重循环复杂度太高，首先排序，最接近可能大也可能小<br>
有序后，每次选定最小值，从后面取两个值，类似两数和思路，复杂度O(n2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = num[<span class="number">0</span>] + num[<span class="number">1</span>] + num[<span class="number">2</span>];</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>, end = num.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = num[i] + num[start] + num[end];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123;</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀259-3sum-smaller">❀259. 3Sum Smaller</h2>
<blockquote>
<p>三数和比目标值小，求所有满足的三元组下标个数</p>
</blockquote>
<p>最基础方法，三重循环，复杂O(n3)不满足题目O(n2)要求<br>
先排序，三数求和，由于只求个数，因此下标变化无所谓<br>
即使相同数字，下标也不同，无需去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//i表示第一个数位置，start表示第二个数位置，end表示第三个数位置</span></span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[start] + nums[end];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="comment">//如果发现已经小于，那么第三个数取更小的都满足</span></span><br><span class="line">                    result += (end-start);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="454-4sum-ii">454. 4Sum II</h2>
<blockquote>
<p>四个等长数组，求下标组合(i,j,k,l)使得各取一个数字总和为0</p>
</blockquote>
<p>AB,CD两两双循环遍历求和存成map，转化为类似2Sum问题<br>
另外解法只保存AB结果map, CD边计算边检查AB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; countAB = twoSumCount(A, B);</span><br><span class="line">        Map&lt;Integer, Integer&gt; countCD = twoSumCount(C, D);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ab : countAB.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(countCD.containsKey(-ab)) &#123;</span><br><span class="line">                result += countAB.get(ab) * countCD.get(-ab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title">twoSumCount</span><span class="params">(<span class="keyword">int</span>[] x, <span class="keyword">int</span>[] y)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; sumCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = x.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = x[i] + y[j];</span><br><span class="line">                sumCount.put(sum, sumCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="差分">差分</h1>
<hr>
<h2 id="❀888-fair-candy-swap">❀888. Fair Candy Swap</h2>
<blockquote>
<p>交换两个数组其中一个数字，使两个数组和相等</p>
</blockquote>
<p>先对两个数组求和，算出差值一半就是交换两个数字之差，转化为两数和问题<br>
原始数组x+a=sumA和y+b=sumB, 交换后x+b = y+a, 即sumA-a+b = sumB-b+a即b-a=(sumB-sumA)/2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> sumA = <span class="number">0</span>, sumB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            sumA += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            sumB += B[i];</span><br><span class="line">            set.add(B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = (sumB - sumA)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(A[i] + diff)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[i], A[i]+diff&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1228-missing-number-in-arithmetic-progression">1228. Missing Number In Arithmetic Progression</h2>
<blockquote>
<p>等差数列中间缺了一个数，求缺失数字</p>
</blockquote>
<p>求出等差数列全满时的和值，减去现在和值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> fullSum = (arr[<span class="number">0</span>] + arr[n-<span class="number">1</span>])*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullSum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀724-find-pivot-index">❀724. Find Pivot Index</h2>
<blockquote>
<p>找到第一个支点使两侧和相等</p>
</blockquote>
<p>两次遍历，第一次求总和，第二次判断两侧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum  = <span class="number">0</span>, leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rightSum = sum - nums[i] - leftSum;</span><br><span class="line">            <span class="keyword">if</span>(rightSum == leftSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1013-partition-array-into-three-parts-with-equal-sum">❀1013. Partition Array Into Three Parts With Equal Sum</h2>
<blockquote>
<p>判断是否可以等分成三份</p>
</blockquote>
<p>先第一遍求总和，然后除3作为每一份和，再遍历一次统计<br>
注意和为0时是特例，可能找到多于三份</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> part = sum/<span class="number">3</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span>(sum == part) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀453-minimum-moves-to-equal-array-elements">❀453. Minimum Moves to Equal Array Elements</h2>
<blockquote>
<p>一个数组n个数字，每次让n-1个数字都自增，求让数组相等的最小次数</p>
</blockquote>
<p>暴力解法，每次选一个位置不变，其他增加<br>
实际策略，经过m次操作全部达到x，那么<code>sum+m*(n-1) = n*x</code>，并且最小元素每次都会参与增加，即<code>min+m = x</code><br>
解出<code>m = sum - n*min</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>], min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - nums.length*min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间段操作">区间段操作</h1>
<hr>
<h2 id="❀303-range-sum-query-immutable">❀303. Range Sum Query - Immutable</h2>
<blockquote>
<p>多次查询数组任意下标区间段<code>[i,j]</code>和值</p>
</blockquote>
<p>内部维护前序和，每次查询复杂度O(1)<br>
前序和preSum(i)表示0-i间和值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum[i] = (i == <span class="number">0</span>) ? nums[i] : preSum[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? preSum[j] : preSum[j] - preSum[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀325-maximum-size-subarray-sum-equals-k">❀325. Maximum Size Subarray Sum Equals k</h2>
<blockquote>
<p>含正负数数组连续和为K的子数组最大长度</p>
</blockquote>
<p>前序和，维护哈希表，值是前序和终点索引<br>
以每个数字作为连续数组末端，尝试通过前序和找前端<br>
同一前序和只保留第一个位置即可，这样下标差值更大，区间长度更长</p>
<p>变化:</p>
<ul>
<li>求正负数个数相等的子数组 -&gt; 正数变为1，负数变为-1，转变为求前序和为0</li>
<li>只包含01，求01个数相等的子数组 -&gt; 负数变为-1，转变为求前序和为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//前序和为0，认为下标是-1</span></span><br><span class="line">        preSum.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (preSum.containsKey(sum - k)) &#123;</span><br><span class="line">                res = Math.max(res, i - preSum.get(sum - k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只记录第一次位置</span></span><br><span class="line">            preSum.putIfAbsent(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀560-subarray-sum-equals-k">❀560. Subarray Sum Equals K</h2>
<blockquote>
<p>含正负数连续和为K的子数组个数</p>
</blockquote>
<p>数字可以为负数，不能动态区间遍历<br>
两个前序和的差就是中间部分的和K，因此求前序和，辅助哈希表存储，key为前序和，value为同和数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前序和，出现次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始和为0,出现1次</span></span><br><span class="line">        preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">//检查之前是否出现了前序和小k的位置</span></span><br><span class="line">            <span class="keyword">if</span>(preSum.containsKey(sum-k)) &#123;</span><br><span class="line">                cnt += preSum.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            preSum.put(sum, preSum.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀238-product-of-array-except-self">❀238. Product of Array Except Self</h2>
<blockquote>
<p>求每个位置不包含自身的所有数乘积，要求不能用除法且O(1)</p>
</blockquote>
<p>如果可以使用除法，那么全部乘积，每个位置除自身即可<br>
如果可以使用额外空间，那么可以左右两侧建立前序乘积，每个结果相当于左右两侧乘积<br>
每个前序乘积只用一次，可以进一步优化，不额外保存，直接放在结果位上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = left * nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                right = right * nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀548-split-array-with-equal-sum">❀548. Split Array with Equal Sum</h2>
<blockquote>
<p>数组，取中间3个值作为分割点剔除，判断能否让分割出的四个部分和相等</p>
</blockquote>
<p>计算数组不同范围和值，利用前序和<br>
中间三个点，通常需要三重循环。先以中间点分割，划分为两侧后单独计算，优化为双重循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分割后每段至少有一个数字，总长至少为7</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算前序和</span></span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i] = i == <span class="number">0</span> ? nums[i] : sum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以中间为支点，尝试等分左右两侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt; nums.length - <span class="number">3</span>; j++) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">//左边部分以每个为支点能等分的和值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum1 = sum[i - <span class="number">1</span>], sum2 = sum[j - <span class="number">1</span>] - sum[i];</span><br><span class="line">                <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">                    set.add(sum1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断右边数组能等分和值是否也能左边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">2</span>; k &lt; nums.length - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum3 = sum[nums.length - <span class="number">1</span>] - sum[k], sum4 = sum[k - <span class="number">1</span>] - sum[j];</span><br><span class="line">                <span class="keyword">if</span> (sum3 == sum4 &amp;&amp; set.contains(sum3)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀862-shortest-subarray-with-sum-at-least-k">❀❀862. Shortest Subarray with Sum at Least K</h2>
<blockquote>
<p>和值大于K的最短子数组长度</p>
</blockquote>
<p>前序和，遍历所有起点终点，可以O(n2)<br>
单调双端队列，O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        <span class="keyword">long</span>[] preSum = <span class="keyword">new</span> <span class="keyword">long</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            preSum[i+<span class="number">1</span>] = preSum[i] + (<span class="keyword">long</span>) A[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = N+<span class="number">1</span>;</span><br><span class="line">        Deque&lt;Integer&gt; monoq = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!monoq.isEmpty() &amp;&amp; preSum[i] &lt;= preSum[monoq.getLast()]) &#123;</span><br><span class="line">                monoq.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!monoq.isEmpty() &amp;&amp; preSum[i] - preSum[monoq.getFirst()] &gt;= K) &#123;</span><br><span class="line">                ans = Math.min(ans, i - monoq.removeFirst());</span><br><span class="line">            &#125;</span><br><span class="line">            monoq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= N ? ans : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口">滑动窗口</h1>
<hr>
<p>定长，变长</p>
<h2 id="643-maximum-average-subarray-i">643. Maximum Average Subarray I</h2>
<blockquote>
<p>长度k子数组最大平均值</p>
</blockquote>
<p>定长滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗口扩展阶段</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个窗口值</span></span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="comment">//替换阶段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum = sum + nums[i] - nums[i-k];</span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum/(<span class="keyword">double</span>)k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者单个循环，注意计算和替换的条件略有不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum = Integer.MIN_VALUE, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) &#123;</span><br><span class="line">                sum = sum - nums[i-k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>) &#123;</span><br><span class="line">                maxSum = Math.max(sum, maxSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum/(<span class="keyword">double</span>)k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀567-permutation-in-string">❀567. Permutation in String</h2>
<blockquote>
<p>判断s2是否有一个子串是s1的排列</p>
</blockquote>
<p>定长滑动窗口，判断s2中长为s1的窗口，是否字符计数上同s1一致<br>
为了避免每次判断遍历整个窗口区间，维护一个匹配度指标，增减计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建s1基准计数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line">            cnt.put(c, cnt.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标是每种字母都计数相等</span></span><br><span class="line">        <span class="keyword">int</span> matchedCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(i);</span><br><span class="line">            <span class="comment">//窗口加入新字母，只统计s1中出现过的，由于定长限制，出现非s1字母将导致无法和s1匹配，即不影响匹配度</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(c)) &#123;</span><br><span class="line">                cnt.put(c, cnt.get(c) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    matchedCnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//达到窗口长度，每次需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= s1.length()) &#123;</span><br><span class="line">                c = s2.charAt(i - s1.length());</span><br><span class="line">                <span class="keyword">if</span> (cnt.containsKey(c)) &#123;</span><br><span class="line">                    <span class="comment">//破坏了原来满足的字母</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        matchedCnt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt.put(c, cnt.get(c) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matchedCnt == cnt.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1100-find-k-length-substrings-with-no-repeated-characters">❀1100. Find K-Length Substrings With No Repeated Characters</h2>
<blockquote>
<p>求长为K且不包含重复字符的子串个数</p>
</blockquote>
<p>定长滑动窗口，当长为K且不重复字符也为K时说明满足，长度超过K后每加入一个就收缩一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numKLenSubstrNoRepeats</span><span class="params">(String S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.length() &lt; K) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, kind = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = S.charAt(j);</span><br><span class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//新增了一种字符</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(c) == <span class="number">1</span>) &#123;</span><br><span class="line">                kind++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= K) &#123;</span><br><span class="line">                c = S.charAt(i-K);</span><br><span class="line">                map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//清空了一种字符</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    kind--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//长为k种类数也为k,说明都为单独字符</span></span><br><span class="line">            <span class="keyword">if</span>(kind == K) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀76-minimum-window-substring">❀76. Minimum Window Substring</h2>
<blockquote>
<p>求包含目标串字符的最小子串，没有就返回空串</p>
</blockquote>
<p>变长滑动窗口，不断收集字符，满足后尝试收缩<br>
目标是所有字母计数值为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            cnt.put(c, cnt.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标是包含所有t中字母, 即降为0</span></span><br><span class="line">        <span class="keyword">int</span> needCnt = t.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, minLen = Integer.MAX_VALUE;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(c)) &#123;</span><br><span class="line">                <span class="comment">//获取目标字母，如果已经0或者负数，说明冗余</span></span><br><span class="line">                <span class="keyword">if</span> (cnt.get(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    needCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt.put(c, cnt.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经足够，可以尝试收缩</span></span><br><span class="line">            <span class="keyword">while</span>(needCnt == <span class="number">0</span> &amp;&amp; i &lt;= j) &#123;</span><br><span class="line">                <span class="comment">//截取当前结果</span></span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = j-i+<span class="number">1</span>;</span><br><span class="line">                    res = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                c = s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (cnt.containsKey(c)) &#123;</span><br><span class="line">                    cnt.put(c, cnt.get(c) + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//破坏了原来满足的字母</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt.get(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        needCnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀209-minimum-size-subarray-sum">❀209. Minimum Size Subarray Sum</h2>
<blockquote>
<p>正数数组，求大于等于某个和值的子数组最小长度</p>
</blockquote>
<p>可能不存在，返回长度0<br>
正数数组和值递增，可以滑动窗口，超过则舍弃前面，O(n)<br>
建立前序和，因为正数数组因此前序和递增，可以循环二分搜索O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s) &#123;</span><br><span class="line">                min = Math.min(min, j-i+<span class="number">1</span>);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀3-longest-substring-without-repeating-characters">❀3. Longest Substring Without Repeating Characters</h2>
<blockquote>
<p>无重复的最长连续子串的长度</p>
</blockquote>
<p>滑动窗口，使用set判定是否重复，set中就是正在统计的子串，set大小可直接作为当前长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">            <span class="keyword">while</span> (set.contains(c))&#123;</span><br><span class="line">                <span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">                set.remove(head);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            len = Math.max(len, end-start+<span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以维护map，记录每个字母最后一次出现的位置，这样滑动时可以直接跳跃</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">//map不清除，包含不一定代表窗口内重复，上一次出现可能已经在窗口外了</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                start = Math.max(start, map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, i);</span><br><span class="line">            max = Math.max(max, i-start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀159-longest-substring-with-at-most-two-distinct-characters">❀159 Longest Substring with At Most Two Distinct Characters</h2>
<blockquote>
<p>最多只包含两种字母的最长子串长度</p>
</blockquote>
<p>滑动窗口，计数，超过两种字符就收缩，相当于对于每个起点，找尽可能长的串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(end);</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//收缩</span></span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, end - start + <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="904-fruit-into-baskets">904. Fruit Into Baskets</h2>
<blockquote>
<p>每颗树不同类型水果，两个篮子能放两种水果，从任意树出发，向右走求最多收集多少水果</p>
</blockquote>
<p>不超过2的最长子数组长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tree.length;</span><br><span class="line">        <span class="keyword">if</span> (tree.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = tree[end];</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> head = tree[start];</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, end - start + <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="340-longest-substring-with-at-most-k-distinct-characters">340. Longest Substring with At Most K Distinct Characters</h2>
<blockquote>
<p>最多只包含K种字母的最长子串长度</p>
</blockquote>
<p>滑动窗口，计数，超过K种字符就收缩</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(end);</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, end - start + <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀992-subarrays-with-k-different-integers">❀❀992. Subarrays with K Different Integers</h2>
<blockquote>
<p>求精确包含K种不同数字的子数组个数，子数组内数字可重复</p>
</blockquote>
<p>不能直接滑动窗口，超过k种就收缩会漏掉很多内容，比如12123求2种数字，中间的21,212等不好求解<br>
转变为至多包含K个数字的子数组个数与至多K-1个数字的子数组个数之差<br>
至多包含K个数字子数组可以用滑动窗口计算，每找到一个区间，以终点为基准之间的所有起点都可以满足</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfAtMostKDistinct(A,K) - numOfAtMostKDistinct(A,K-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfAtMostKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; A.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A[end];</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">int</span> head = A[start];</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += end -start + <span class="number">1</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀395-longest-substring-with-at-least-k-repeating-characters">❀❀395. Longest Substring with At Least K Repeating Characters</h2>
<blockquote>
<p>最长序列长度，满足序列内每个字母最少出现k次</p>
</blockquote>
<p>滑动窗口，通常都是判断窗口内种类数，这个是次数<br>
转化为种数，每次判定含有不同字母数的最长序列，最多26个，所以还是O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h &lt;= <span class="number">26</span>; h++) &#123;</span><br><span class="line">            max = Math.max(max, longestSubstring(s,k,h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n个不同字母，每个出现k次</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, unique = <span class="number">0</span>, noLessThanK = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unique &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = s.charAt(j) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                    unique++;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[idx]++;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == k) &#123;</span><br><span class="line">                    noLessThanK++;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == k) &#123;</span><br><span class="line">                    noLessThanK--;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[idx]--;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                    unique--;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (unique == n &amp;&amp; unique == noLessThanK) &#123;</span><br><span class="line">                max = Math.max(j - i, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序">排序</h1>
<hr>
<h2 id="❀❀912-sort-an-array">❀❀912. Sort an Array</h2>
<blockquote>
<p>实现数组排序</p>
</blockquote>
<p>快速排序，划分, 时间复杂度O(nlogn),不稳定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, s, e);</span><br><span class="line">        quickSort(nums, s, p-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums, p+<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回位置已放正确，左侧小，右边大于等于</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择支点，这里简单的选取最后一个</span></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[e];</span><br><span class="line">        <span class="keyword">int</span> i = s, j = e;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大于等于跳过，所以初始右侧支点也会跳过</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换支点</span></span><br><span class="line">        swap(nums, i, e);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序，二分合并，时间复杂度O(nlogn),空间复杂度O(n),稳定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (s + e)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, s, mid);</span><br><span class="line">        mergeSort(nums, mid+<span class="number">1</span>, e);</span><br><span class="line">        merge(nums, s, mid, mid+<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个相邻数组，各自有序，合并成整体有序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s1, <span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[e1-s1+<span class="number">1</span> + e2-s2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = s1, j = s2, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= e1 &amp;&amp; j &lt;= e2) &#123;</span><br><span class="line">            <span class="comment">//小于等于，保持稳定性</span></span><br><span class="line">            tmp[index++] = (nums[i] &lt;= nums[j]) ? nums[i++] : nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= e1) &#123;</span><br><span class="line">            tmp[index++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= e2) &#123;</span><br><span class="line">            tmp[index++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tmp.length; k++) &#123;</span><br><span class="line">            nums[s1+k] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序,时间复杂度O(nlogn),不稳定<br>
下标i的左子为<code>2*i+1</code>,右子为<code>2*i+2</code><br>
总体思路是建堆，然后每次把堆顶交换到最后，堆顶下沉<br>
建堆也可以复用下沉，从最后的非叶节点开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        heapSort(nums, nums.length);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建堆，从最后的非叶节点开始下沉，最后非叶为n/2-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(nums, i, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//堆顶交换到最后</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            adjustHeap(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要调整的节点下标以及范围大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//待下沉的堆顶</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        <span class="comment">//有左子就继续, k表示子节点下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i*<span class="number">2</span>+<span class="number">1</span>; k &lt; n; k=k*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//左右子选较大的</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span> &lt; n &amp;&amp; nums[k] &lt; nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//能下沉则空缺位置变更，不能下沉则已找到位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; tmp) &#123;</span><br><span class="line">                <span class="comment">//填充原位置</span></span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                <span class="comment">//当前位置k变为新的待填充位置</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序,时间复杂度O(n2),不稳定<br>
每次选一个后续最小的，作为当前排序值，即不断的寻找最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        selectionSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序,时间复杂度O(n2),稳定<br>
每轮从头开始，把大值推到末尾，进行n-1轮即可，外层循环轮次控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        bubbleSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//后面已经排好，不断缩减范围</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序,时间复杂度O(n2),稳定<br>
前面有序，每次把当前元素尝试往前面交换，直到送到正确位置<br>
外围循环控制当前要排的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        insertionSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀75-sort-colors">❀75. Sort Colors</h2>
<blockquote>
<p>三种数字012排序</p>
</blockquote>
<p>基于覆写，计数排序，第一次计数，第二次写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            cnt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">                cnt[<span class="number">0</span>]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">                cnt[<span class="number">1</span>]--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于交换，一次遍历，基于三指针交换双向增长，左指向已有0的下一位，右指向已有2的前一位，当前指针遍历，尝试两侧向中心生长<br>
由于从左边起换，遇到0放到合适位置，因此左边肯定只能换到1，而遇到2可能右边换到的也是2，不能跳过需要从新判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] == <span class="number">2</span>) &#123;</span><br><span class="line">                nums[idx] = nums[j];</span><br><span class="line">                nums[j] = <span class="number">2</span>;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀347-top-k-frequent-elements">❀❀347. Top K Frequent Elements</h2>
<blockquote>
<p>频次最高的前K个数字</p>
</blockquote>
<p>桶排序，首先每个数字进行计数<br>
由于n长度数组，每个数字频率范围为0-n，因此可以以频率为桶<br>
把数字计数放置在对应频率上，从大到小收集即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            freq.put(n, freq.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个频率开一个桶</span></span><br><span class="line">        List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> List[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : freq.keySet()) &#123;</span><br><span class="line">            bucket[freq.get(key)].add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bucket.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.addAll(bucket[i]);</span><br><span class="line">            <span class="keyword">if</span> (res.size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀506-relative-ranks">❀506. Relative Ranks</h2>
<blockquote>
<p>输出每个数字的顺位</p>
</blockquote>
<p>结果要求原始顺序，而排序后数组位置变动会丢失原始顺序，因此提前记录下来原始位置<br>
原生类型无法直接降序排列，注意变通为逆向遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRelativeRanks(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        String[] res = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index =  map.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == n-<span class="number">1</span>)&#123;</span><br><span class="line">                res[index] = <span class="string">"Gold Medal"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">2</span>)&#123;</span><br><span class="line">                res[index] = <span class="string">"Silver Medal"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">3</span>) &#123;</span><br><span class="line">                res[index] = <span class="string">"Bronze Medal"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index] = String.valueOf(n-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1086-high-five">1086. High Five</h2>
<blockquote>
<p>统计每个学生最高的5门课平均分，保证多于5门</p>
</blockquote>
<p>排序，尾触发统计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] highFive(<span class="keyword">int</span>[][] items) &#123;</span><br><span class="line">        <span class="comment">//学号升序，成绩降序</span></span><br><span class="line">        Arrays.sort(items, (a,b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? (a[<span class="number">0</span>] - b[<span class="number">0</span>]) : (b[<span class="number">1</span>] - a[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> n = items.length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; avg = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> id = items[<span class="number">0</span>][<span class="number">0</span>], score = items[<span class="number">0</span>][<span class="number">1</span>], cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(items[i][<span class="number">0</span>] == id &amp;&amp; cnt &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                score += items[i][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(items[i][<span class="number">0</span>] != id)&#123;</span><br><span class="line">                avg.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;id, score/<span class="number">5</span>&#125;);</span><br><span class="line">                id = items[i][<span class="number">0</span>];</span><br><span class="line">                score = items[i][<span class="number">1</span>];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        avg.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;id, score/<span class="number">5</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> avg.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[avg.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1122-relative-sort-array">❀1122. Relative Sort Array</h2>
<blockquote>
<p>数组2包含部分不重复数据，将数组1按照数组2排序，数组2内不存在的升序排在后面</p>
</blockquote>
<p>桶排序，先统计数组1内各个数字出现次数，按照数组2顺序写入，最后写入不存在的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">            buckets[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr2) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr1[idx++] = i;</span><br><span class="line">                buckets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr1[idx++] = i;</span><br><span class="line">                buckets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1051-height-checker">1051. Height Checker</h2>
<blockquote>
<p>调整成非降序，求有多少个数据在错误位置</p>
</blockquote>
<p>复制一份数组排列好，对比两数组几个位置不同，O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = Arrays.copyOf(heights, heights.length);</span><br><span class="line">        Arrays.sort(tmp);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] != heights[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者桶排序O(n)，判断每个位置应该排什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : heights) &#123;</span><br><span class="line">            buckets[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[idx] != i) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                buckets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀945-minimum-increment-to-make-array-unique">❀945. Minimum Increment to Make Array Unique</h2>
<blockquote>
<p>一次操作可以使单个数组位增加，求达到每个元素唯一的最小操作次数</p>
</blockquote>
<p>先排序，后续应该至少比前面大1，求出每一位应该的值后计算差值<br>
由于不改动原数组，因此额外维护前序值作为基准</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, prev = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> expect = prev + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//不符合预期需要增加到预期，后续判断基准为预期值</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; expect) &#123;</span><br><span class="line">                res += expect - A[i];</span><br><span class="line">                prev = expect;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//已经超出预期，当前值作为后续基准</span></span><br><span class="line">                prev = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1200-minimum-absolute-difference">1200. Minimum Absolute Difference</h2>
<blockquote>
<p>求相差的绝对值最小的所有数对</p>
</blockquote>
<p>先排序，绝对值最小数对只限于相邻</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> minAbs = Integer.MAX_VALUE;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> abs = arr[i] - arr[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(abs == minAbs) &#123;</span><br><span class="line">                result.add(Arrays.asList(arr[i-<span class="number">1</span>],arr[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(abs &lt; minAbs) &#123;</span><br><span class="line">                result.clear();</span><br><span class="line">                minAbs = abs;</span><br><span class="line">                result.add(Arrays.asList(arr[i-<span class="number">1</span>],arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀315-count-of-smaller-numbers-after-self">❀❀315. Count of Smaller Numbers After Self</h2>
<blockquote>
<p>统计每个元素后面小于的元素个数</p>
</blockquote>
<p>融合mergeSort，两个数组合并时，左侧原本在前，右侧在后</p>
<ul>
<li>如果从右侧取，说明右侧小，计数</li>
<li>如果从左侧取，此时右侧提前的个数就是后面小于的个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            indexes[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        mergesort(nums, indexes, count, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(count).boxed().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] indexes, <span class="keyword">int</span>[] count, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt;= start)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergesort(nums, indexes, count, start, mid);</span><br><span class="line">        mergesort(nums, indexes, count, mid + <span class="number">1</span>, end);</span><br><span class="line">        merge(nums, indexes, count, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] indexes, <span class="keyword">int</span>[] count, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = mid+<span class="number">1</span>, rightcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> resIdx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= mid &amp;&amp; right &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[indexes[right]] &lt; nums[indexes[left]])&#123;</span><br><span class="line">                res[resIdx] = indexes[right];</span><br><span class="line">                rightcount++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[resIdx] = indexes[left];</span><br><span class="line">                count[indexes[left]] += rightcount;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            resIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= mid)&#123;</span><br><span class="line">            res[resIdx] = indexes[left];</span><br><span class="line">            count[indexes[left]] += rightcount;</span><br><span class="line">            left++;</span><br><span class="line">            resIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right &lt;= end)&#123;</span><br><span class="line">            res[resIdx] = indexes[right];</span><br><span class="line">            right++;</span><br><span class="line">            resIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排好序写回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            indexes[i] = res[i - start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀406-queue-reconstruction-by-height">❀406. Queue Reconstruction by Height</h2>
<blockquote>
<p>每个人身高和前面更高的人数，重建队列</p>
</blockquote>
<p>按身高降序，相同按位置升序，这样每次排时已经排好的都是比自身更高的<br>
实际上为插入排序，前面人数可以作为插入索引，采取链表维护队列减少插入开销</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.sort(people, (a,b) -&gt; a[<span class="number">0</span>]!=b[<span class="number">0</span>] ? b[<span class="number">0</span>] - a[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] p : people) &#123;</span><br><span class="line">            list.add(p[<span class="number">1</span>],p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1057-campus-bikes">❀1057. Campus Bikes</h2>
<blockquote>
<p>自行车和工人，二维坐标，车多因此每个人能分一辆，曼哈顿距离就近分配，同距离多个工人编号小优先，人同距离多个车车编号小优先</p>
</blockquote>
<p>排序，优先队列解法，生成所有组合，依次考虑距离，工人编号，车编号，加入队列<br>
弹出时检查工人和车是否分配过，没分配就进行分配，共MN个配对，复杂度O(MNlogMN)<br>
由于车和人坐标在0~1000之间，距离上限在2000，可以桶排序降低复杂度到O(MN)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] assignBikes(<span class="keyword">int</span>[][] workers, <span class="keyword">int</span>[][] bikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = workers.length, b = bikes.length;</span><br><span class="line">        <span class="comment">//每个距离一个桶</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt;[] dists = <span class="keyword">new</span> List[<span class="number">2001</span>];</span><br><span class="line">        <span class="comment">//记录是否已经分配过</span></span><br><span class="line">        <span class="keyword">int</span>[] wo = <span class="keyword">new</span> <span class="keyword">int</span>[w], bi = <span class="keyword">new</span> <span class="keyword">int</span>[b];</span><br><span class="line">        Arrays.fill(wo, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(bi, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//每个车和人进行组合，计算出距离</span></span><br><span class="line">        <span class="comment">//人编号从小到大，车编号从小到大，组合满足优先顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] worker = workers[i];</span><br><span class="line">                <span class="keyword">int</span>[] bike = bikes[j];</span><br><span class="line">                <span class="keyword">int</span> dist = Math.abs(worker[<span class="number">0</span>] - bike[<span class="number">0</span>]) + Math.abs(worker[<span class="number">1</span>] - bike[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (dists[dist] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dists[dist] = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                dists[dist].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> assigned = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2000</span> &amp;&amp; assigned &lt; w; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dists[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] pair : dists[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wo[pair[<span class="number">0</span>]] == -<span class="number">1</span> &amp;&amp; bi[pair[<span class="number">1</span>]] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    wo[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>];</span><br><span class="line">                    bi[pair[<span class="number">1</span>]] = pair[<span class="number">0</span>];</span><br><span class="line">                    assigned++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子序列">子序列</h1>
<hr>
<p>子序列不要求连续，仅保持元素间相对顺序</p>
<h2 id="594-longest-harmonious-subsequence">594. Longest Harmonious Subsequence</h2>
<blockquote>
<p>求最长子序列，序列内最大最小值差为1</p>
</blockquote>
<p>建map统计次数，查找相邻，次数和就是子序列长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map &lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key + <span class="number">1</span>)) &#123;</span><br><span class="line">                res = Math.max(res, map.get(key) + map.get(key + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀128-longest-consecutive-sequence">❀128. Longest Consecutive Sequence</h2>
<blockquote>
<p>无序数组，能够成的连续数字子序列长度</p>
</blockquote>
<p>双哈希，同时记录起点和终点双向映射<br>
每次遍历到新数字，判断是否可以把已有连续区间连接起来<br>
遇到数字位于已有区间内，不影响，因为不会影响外边界，最终哈希表内可能出现区间套区间的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//起始元素，终止元素</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; startMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; endMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(startMap.containsKey(i) || endMap.containsKey(i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> next = i+<span class="number">1</span>, prev = i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newStart = i, newEnd = i;</span><br><span class="line">            <span class="keyword">if</span>(startMap.containsKey(next) &amp;&amp; endMap.containsKey(prev)) &#123;</span><br><span class="line">                newStart = endMap.get(prev);</span><br><span class="line">                newEnd = startMap.get(next);</span><br><span class="line">                startMap.remove(next);</span><br><span class="line">                endMap.remove(prev);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(startMap.containsKey(next)) &#123;</span><br><span class="line">                newEnd = startMap.get(next);</span><br><span class="line">                startMap.remove(next);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(endMap.containsKey(prev)) &#123;</span><br><span class="line">                newStart = endMap.get(prev);</span><br><span class="line">                endMap.remove(prev);</span><br><span class="line">            &#125;</span><br><span class="line">            startMap.put(newStart, newEnd);</span><br><span class="line">            endMap.put(newEnd, newStart);</span><br><span class="line">            result = Math.max(result, newEnd-newStart+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单哈希版本，区间(5,6,7)同时记起始结束点和长度(5,3),(7,3)<br>
因为数据不删除，包含去重逻辑，所以6不会再处理，边界5和7只能通过4和8左右单侧连接，长度不会造成混淆，可以利用长度反推已有区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起始元素或者终止元素，长度</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : num) &#123;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个数字都添加进去，用于去重</span></span><br><span class="line">        map.put(i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prev = i - <span class="number">1</span>, next = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = i, begin = i;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(next)) &#123;</span><br><span class="line">            end = i + map.get(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(prev)) &#123;</span><br><span class="line">            begin = i - map.get(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newLen = end - begin + <span class="number">1</span>;</span><br><span class="line">        map.put(end, newLen);</span><br><span class="line">        map.put(begin, newLen);</span><br><span class="line">        result = Math.max(result, newLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间">区间</h1>
<hr>
<h2 id="252-meeting-rooms">252. Meeting Rooms</h2>
<blockquote>
<p>给出所有会议开始和结束时间，判断是否能参加全部</p>
</blockquote>
<p>判断区间是否重叠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照起始时间排序</span></span><br><span class="line">        Arrays.sort(intervals, (i1, i2) -&gt; Integer.compare(i1[<span class="number">0</span>], i2[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="comment">//起始时间小于前面结束时间</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i-<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀56-merge-intervals">❀56. Merge Intervals</h2>
<blockquote>
<p>区间合并</p>
</blockquote>
<p>按照起始位置排序，遍历判断是否重叠合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按起点排序</span></span><br><span class="line">        Arrays.sort(intervals, (i1, i2) -&gt; Integer.compare(i1[<span class="number">0</span>], i2[<span class="number">0</span>]));</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] prev = intervals[<span class="number">0</span>];</span><br><span class="line">        result.add(prev);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] curr : intervals) &#123;</span><br><span class="line">            <span class="comment">//当前起点小于上一个终点，重合</span></span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">0</span>] &lt;= prev[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//取最长的终点</span></span><br><span class="line">                prev[<span class="number">1</span>] = Math.max(prev[<span class="number">1</span>], curr[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不重合，新开一个区间</span></span><br><span class="line">                prev = curr;</span><br><span class="line">                result.add(prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="986-interval-list-intersections">986. Interval List Intersections</h2>
<blockquote>
<p>两个升序不相交区间列表，求交集</p>
</blockquote>
<p>比较头部，谁先结束跳过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || B == <span class="keyword">null</span> || B.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B.length, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> startMax = Math.max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> endMin = Math.min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//有重叠,后开始的小于前结束</span></span><br><span class="line">            <span class="keyword">if</span> (startMax &lt;= endMin) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;startMax, endMin&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先结束的跳过</span></span><br><span class="line">            <span class="keyword">if</span> (A[i][<span class="number">1</span>] == endMin) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B[j][<span class="number">1</span>] == endMin) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀253-meeting-rooms-ii">❀253. Meeting Rooms II</h2>
<blockquote>
<p>给出所有会议开始和结束时间，判断全部安排需要几个会议室</p>
</blockquote>
<p>按起始位置排序<br>
小顶堆维护结束时间，每个堆内元素相当于一个会议室</p>
<ul>
<li>如果顶部能容纳，那么弹出顶部，插入新的，相当于更新</li>
<li>如果顶部不能容纳，那么直接插入新的，相当于新开会议室</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">//起始时间大于堆顶结束时间，无重叠可以安排</span></span><br><span class="line">            <span class="keyword">if</span> (!minHeap.isEmpty() &amp;&amp; intervals[i][<span class="number">0</span>] &gt;= minHeap.peek()) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.offer(intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀435-non-overlapping-intervals">❀435. Non-overlapping Intervals</h2>
<blockquote>
<p>给一组区间，求最少删除数能使得无重叠</p>
</blockquote>
<p>转变求最大可安排的不重叠区间数<br>
贪心，按照结束时间升序，如果两个区间重叠，那么选结束时间早的，因为同样是一个区间，结束早就给后面留出更大空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照结束时间升序</span></span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(i -&gt; i[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, lastend = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] in : intervals) &#123;</span><br><span class="line">            <span class="comment">//起点比最后终点大，无重叠</span></span><br><span class="line">            <span class="keyword">if</span> (in[<span class="number">0</span>] &gt;= lastend) &#123;</span><br><span class="line">                lastend = in[<span class="number">1</span>];</span><br><span class="line">                max++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀452-minimum-number-of-arrows-to-burst-balloons">❀❀452. Minimum Number of Arrows to Burst Balloons</h2>
<blockquote>
<p>气球水平可能重叠，垂直射箭，全射爆最少需要几支箭</p>
</blockquote>
<p>区间选点问题，即每个区间至少选一个点<br>
贪心，按结束位置排序，如果区间不重合，就把结束位置加入，越后加入越可能与后面重合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(points, (a,b) -&gt; a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, last = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; last) &#123;</span><br><span class="line">                last = points[i][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顺序模拟">顺序模拟</h1>
<hr>
<h2 id="717-1-bit-and-2-bit-characters">717. 1-bit and 2-bit Characters</h2>
<blockquote>
<p>一串01序列最后为0，解析方式有10,11或者单个0,判断最后0是否单个解析</p>
</blockquote>
<p>从头开始解析，只要遇见1肯定控制下一位走两步，遇到0走一步，那么记录最后是哪一种即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; bits.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bits[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                step = <span class="number">2</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="806-number-of-lines-to-write-string">806. Number of Lines To Write String</h2>
<blockquote>
<p>每个字母长度不等，每行长度最多100，求字符串占几行以及最后一行多长</p>
</blockquote>
<p>注意写不下换行，每行不一定占满</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numberOfLines(<span class="keyword">int</span>[] widths, String S) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>, line = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = widths[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(length + w &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                length = length + w;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                length = w;</span><br><span class="line">                line++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123; line, length &#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="657-robot-return-to-origin">657. Robot Return to Origin</h2>
<blockquote>
<p>上下左右操作后，判断是否回原点</p>
</blockquote>
<p>水平垂直变量计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeCircle</span><span class="params">(String moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vertical = <span class="number">0</span>, horizontal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : moves.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'U'</span>) &#123;</span><br><span class="line">                vertical++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'D'</span>) &#123;</span><br><span class="line">                vertical--; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                horizontal--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'R'</span>) &#123;</span><br><span class="line">                horizontal++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vertical == <span class="number">0</span> &amp;&amp; horizontal == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他">其他</h1>
<hr>
<h2 id="❀11-container-with-most-water">❀11. Container With Most Water</h2>
<blockquote>
<p>不同高度板子，任选两个连同底部作为容器，求能装最大水量</p>
</blockquote>
<p>水高度被较低的板子制约<br>
最左边板子L,最右边R,此时底部最长，为了寻找更大水量，只能缩短底部，即移动隔板<br>
左边L比较低并且固定，那么不管右边怎么移，即使再高的板子也受制于左边，即宽度减少但是高度不会增加，总量也不会增加，因此移动左边L才能可能寻求更大总量，即策略是哪个低移动哪个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> amount = (j-i) * Math.min(height[i], height[j]);</span><br><span class="line">            result = Math.max(result, amount);</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀42-trapping-rain-water">❀❀42. Trapping Rain Water</h2>
<blockquote>
<p>给出不同高度，求能容纳水量</p>
</blockquote>
<p>每个位置能存水高度取决于左右两侧到此位置的最大高度<br>
比如位置高1，左侧3右侧5，那么总高度只能是3，刨除自身高度能存2<br>
直观方法是分别存储左右两边最大高度数组，然后每个位置综合求解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n], rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i-<span class="number">1</span>], height[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i+<span class="number">1</span>], height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span>(border &gt; height[i]) &#123;</span><br><span class="line">                res += border - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以左右双端移动，无需额外存储，那边低就移动那边，因为低的这边已经受到制约可以求解了，同时更新记录两侧最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[i]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[j]);</span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">                result += leftMax - height[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result += rightMax - height[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀❀407-trapping-rain-water-ii">❀❀407. Trapping Rain Water II</h2>
<blockquote>
<p>3D高度，求能容纳水量</p>
</blockquote>
<p>总体思路还是受低方向制约，矩形范围低方向不好求，借助堆<br>
首先把边界都加入，每次找一个最低的，判断邻接，把邻接作为新边界加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heightMap == <span class="keyword">null</span> || heightMap.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = heightMap.length, n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//行下标，列下标，高度</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右边界入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, <span class="number">0</span>, heightMap[i][<span class="number">0</span>]&#125;);</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, n - <span class="number">1</span>, heightMap[i][n - <span class="number">1</span>]&#125;);</span><br><span class="line">            visited[i][<span class="number">0</span>] = visited[i][n - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上下边界入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, j, heightMap[<span class="number">0</span>][j]&#125;);</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;m - <span class="number">1</span>, j, heightMap[m - <span class="number">1</span>][j]&#125;);</span><br><span class="line">            visited[<span class="number">0</span>][j] = visited[m - <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cell = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cell[<span class="number">0</span>] + d[<span class="number">0</span>], j = cell[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    res += Math.max(<span class="number">0</span>, cell[<span class="number">2</span>] - heightMap[i][j]);</span><br><span class="line">                    <span class="comment">//使用更高的边界</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j, Math.max(heightMap[i][j], cell[<span class="number">2</span>])&#125;);</span><br><span class="line">                    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
    <div class="donate_module">
        <div id="donate_board" class="donate_bar">
            <br>
            <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
        </div>
        <div id="donate_guide" class="donate_bar hidden">
            <br>
            <a href="/assets/reward/wechat_code.jpg"  class="fancybox">
                <img src="/assets/reward/wechat_code.jpg" title="微信打赏" height="190px" width="auto"/>
            </a>
            <span class="donate_space"></span>
            <a href="/assets/reward/alipay_code.jpg"  class="fancybox">
                <img src="/assets/reward/alipay_code.jpg" title="支付宝打赏" height="190px" width="auto"/>
            </a>
        </div>
        <span class="donate_txt">一分也是爱~</span> 
    </div>

        <div class="breakword">
    <hr>
    <p><strong>版权声明</strong></p>
    <p><img src="/assets/copyright/cc.png" alt=""></p>
    <p><a href="http://linest.github.io/leetcode/leetcode-array.html">This site</a> by <a href="mailto:xlinest@gmail.com">Linest</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.
    <br>由<a href="mailto:xlinest@gmail.com">Linest</a>创作并维护的博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
    <p>本文永久链接：<a href="http://linest.github.io/leetcode/leetcode-array.html">http://linest.github.io/leetcode/leetcode-array.html</a></p>
</div>
      
    </div>
    
  </div>
  
    
  
</article>
<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关注点"><span class="toc-number">1.1.</span> <span class="toc-text">关注点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作"><span class="toc-number">1.2.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧"><span class="toc-number">1.3.</span> <span class="toc-text">技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单调性"><span class="toc-number">2.</span> <span class="toc-text">单调性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀896-monotonic-array"><span class="toc-number">2.1.</span> <span class="toc-text">❀896. Monotonic Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀941-valid-mountain-array"><span class="toc-number">2.2.</span> <span class="toc-text">❀941. Valid Mountain Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀665-non-decreasing-array"><span class="toc-number">2.3.</span> <span class="toc-text">❀❀665. Non-decreasing Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀581-shortest-unsorted-continuous-subarray"><span class="toc-number">2.4.</span> <span class="toc-text">❀❀581. Shortest Unsorted Continuous Subarray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀135-candy"><span class="toc-number">2.5.</span> <span class="toc-text">❀❀135. Candy</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#外建哈希"><span class="toc-number">3.</span> <span class="toc-text">外建哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#217-contains-duplicate"><span class="toc-number">3.1.</span> <span class="toc-text">217. Contains Duplicate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#219-contains-duplicate-ii"><span class="toc-number">3.2.</span> <span class="toc-text">219. Contains Duplicate II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1346-check-if-n-and-its-double-exist"><span class="toc-number">3.3.</span> <span class="toc-text">1346. Check If N and Its Double Exist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#349-intersection-of-two-arrays"><span class="toc-number">3.4.</span> <span class="toc-text">349. Intersection of Two Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#350-intersection-of-two-arrays-ii"><span class="toc-number">3.5.</span> <span class="toc-text">350. Intersection of Two Arrays II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1207-unique-number-of-occurrences"><span class="toc-number">3.6.</span> <span class="toc-text">1207. Unique Number of Occurrences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#697-degree-of-an-array"><span class="toc-number">3.7.</span> <span class="toc-text">697. Degree of an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#760-find-anagram-mappings"><span class="toc-number">3.8.</span> <span class="toc-text">760. Find Anagram Mappings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#599-minimum-index-sum-of-two-lists"><span class="toc-number">3.9.</span> <span class="toc-text">599. Minimum Index Sum of Two Lists</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自身哈希"><span class="toc-number">4.</span> <span class="toc-text">自身哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀448-find-all-numbers-disappeared-in-an-array"><span class="toc-number">4.1.</span> <span class="toc-text">❀448. Find All Numbers Disappeared in an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀442-find-all-duplicates-in-an-array"><span class="toc-number">4.2.</span> <span class="toc-text">❀442. Find All Duplicates in an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀645-set-mismatch"><span class="toc-number">4.3.</span> <span class="toc-text">❀645. Set Mismatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀41-first-missing-positive"><span class="toc-number">4.4.</span> <span class="toc-text">❀❀41. First Missing Positive</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连续分段"><span class="toc-number">5.</span> <span class="toc-text">连续分段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#485-max-consecutive-ones"><span class="toc-number">5.1.</span> <span class="toc-text">485. Max Consecutive Ones</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#551-student-attendance-record-i"><span class="toc-number">5.2.</span> <span class="toc-text">551. Student Attendance Record I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#830-positions-of-large-groups"><span class="toc-number">5.3.</span> <span class="toc-text">830. Positions of Large Groups</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#696-count-binary-substrings"><span class="toc-number">5.4.</span> <span class="toc-text">696. Count Binary Substrings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀443-string-compression"><span class="toc-number">5.5.</span> <span class="toc-text">❀443. String Compression</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀849-maximize-distance-to-closest-person"><span class="toc-number">5.6.</span> <span class="toc-text">❀849. Maximize Distance to Closest Person</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#605-can-place-flowers"><span class="toc-number">5.7.</span> <span class="toc-text">605. Can Place Flowers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#674-longest-continuous-increasing-subsequence"><span class="toc-number">5.8.</span> <span class="toc-text">674. Longest Continuous Increasing Subsequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀978-longest-turbulent-subarray"><span class="toc-number">5.9.</span> <span class="toc-text">❀978. Longest Turbulent Subarray</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#投票"><span class="toc-number">6.</span> <span class="toc-text">投票</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀169-majority-element"><span class="toc-number">6.1.</span> <span class="toc-text">❀169. Majority Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀229-majority-element-ii"><span class="toc-number">6.2.</span> <span class="toc-text">❀229. Majority Element II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀961-n-repeated-element-in-size-2n-array"><span class="toc-number">6.3.</span> <span class="toc-text">❀961. N-Repeated Element in Size 2N Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀277-find-the-celebrity"><span class="toc-number">6.4.</span> <span class="toc-text">❀277. Find the Celebrity</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最值"><span class="toc-number">7.</span> <span class="toc-text">最值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#747-largest-number-at-least-twice-of-others"><span class="toc-number">7.1.</span> <span class="toc-text">747. Largest Number At Least Twice of Others</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀414-third-maximum-number"><span class="toc-number">7.2.</span> <span class="toc-text">❀414. Third Maximum Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#628-maximum-product-of-three-numbers"><span class="toc-number">7.3.</span> <span class="toc-text">628. Maximum Product of Three Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#908-smallest-range-i"><span class="toc-number">7.4.</span> <span class="toc-text">908. Smallest Range I</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第k大数字"><span class="toc-number">8.</span> <span class="toc-text">第k大数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀215-kth-largest-element-in-an-array"><span class="toc-number">8.1.</span> <span class="toc-text">❀215. Kth Largest Element in an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-median-of-two-sorted-arrays"><span class="toc-number">8.2.</span> <span class="toc-text">4. Median of Two Sorted Arrays</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#距离"><span class="toc-number">9.</span> <span class="toc-text">距离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀243-shortest-word-distance"><span class="toc-number">9.1.</span> <span class="toc-text">❀243. Shortest Word Distance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#244-shortest-word-distance-ii"><span class="toc-number">9.2.</span> <span class="toc-text">244. Shortest Word Distance II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀245-shortest-word-distance-iii"><span class="toc-number">9.3.</span> <span class="toc-text">❀245. Shortest Word Distance III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀821-shortest-distance-to-a-character"><span class="toc-number">9.4.</span> <span class="toc-text">❀821. Shortest Distance to a Character</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#首尾"><span class="toc-number">10.</span> <span class="toc-text">首尾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#977-squares-of-a-sorted-array"><span class="toc-number">10.1.</span> <span class="toc-text">977. Squares of a Sorted Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原地交换移位"><span class="toc-number">11.</span> <span class="toc-text">原地交换移位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀189-rotate-array"><span class="toc-number">11.1.</span> <span class="toc-text">❀189. Rotate Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀905-sort-array-by-parity"><span class="toc-number">11.2.</span> <span class="toc-text">❀905. Sort Array By Parity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀922-sort-array-by-parity-ii"><span class="toc-number">11.3.</span> <span class="toc-text">❀922. Sort Array By Parity II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原地覆写"><span class="toc-number">12.</span> <span class="toc-text">原地覆写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀88-merge-sorted-array"><span class="toc-number">12.1.</span> <span class="toc-text">❀88. Merge Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀27-remove-element"><span class="toc-number">12.2.</span> <span class="toc-text">❀27. Remove Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀26-remove-duplicates-from-sorted-array"><span class="toc-number">12.3.</span> <span class="toc-text">❀26. Remove Duplicates from Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀80-remove-duplicates-from-sorted-array-ii"><span class="toc-number">12.4.</span> <span class="toc-text">❀80. Remove Duplicates from Sorted Array II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀283-move-zeroes"><span class="toc-number">12.5.</span> <span class="toc-text">❀283. Move Zeroes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1089-duplicate-zeros"><span class="toc-number">12.6.</span> <span class="toc-text">❀1089. Duplicate Zeros</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈辅助"><span class="toc-number">13.</span> <span class="toc-text">栈辅助</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀739-daily-temperatures"><span class="toc-number">13.1.</span> <span class="toc-text">❀739. Daily Temperatures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀496-next-greater-element-i"><span class="toc-number">13.2.</span> <span class="toc-text">❀496. Next Greater Element I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀946-validate-stack-sequences"><span class="toc-number">13.3.</span> <span class="toc-text">❀946. Validate Stack Sequences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀84-largest-rectangle-in-histogram"><span class="toc-number">13.4.</span> <span class="toc-text">❀84. Largest Rectangle in Histogram</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列辅助"><span class="toc-number">14.</span> <span class="toc-text">队列辅助</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1047-remove-all-adjacent-duplicates-in-string"><span class="toc-number">14.1.</span> <span class="toc-text">1047. Remove All Adjacent Duplicates In String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀316-remove-duplicate-letters"><span class="toc-number">14.2.</span> <span class="toc-text">❀316. Remove Duplicate Letters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀239-sliding-window-maximum"><span class="toc-number">14.3.</span> <span class="toc-text">❀❀239. Sliding Window Maximum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优先队列"><span class="toc-number">15.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1046-last-stone-weight"><span class="toc-number">15.1.</span> <span class="toc-text">1046. Last Stone Weight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1198-find-smallest-common-element-in-all-rows"><span class="toc-number">15.2.</span> <span class="toc-text">❀1198. Find Smallest Common Element in All Rows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀373-find-k-pairs-with-smallest-sums"><span class="toc-number">15.3.</span> <span class="toc-text">❀373. Find K Pairs with Smallest Sums</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二分搜索"><span class="toc-number">16.</span> <span class="toc-text">二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀704-binary-search"><span class="toc-number">16.1.</span> <span class="toc-text">❀704. Binary Search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#374-guess-number-higher-or-lower"><span class="toc-number">16.2.</span> <span class="toc-text">374. Guess Number Higher or Lower</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀702-search-in-a-sorted-array-of-unknown-size"><span class="toc-number">16.3.</span> <span class="toc-text">❀702. Search in a Sorted Array of Unknown Size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀34-find-first-and-last-position-of-element-in-sorted-array"><span class="toc-number">16.4.</span> <span class="toc-text">❀34. Find First and Last Position of Element in Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#278-first-bad-version"><span class="toc-number">16.5.</span> <span class="toc-text">278. First Bad Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀744-find-smallest-letter-greater-than-target"><span class="toc-number">16.6.</span> <span class="toc-text">❀744. Find Smallest Letter Greater Than Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀35-search-insert-position"><span class="toc-number">16.7.</span> <span class="toc-text">❀❀35. Search Insert Position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀162-find-peak-element"><span class="toc-number">16.8.</span> <span class="toc-text">❀162. Find Peak Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#852-peak-index-in-a-mountain-array"><span class="toc-number">16.9.</span> <span class="toc-text">852. Peak Index in a Mountain Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀540-single-element-in-a-sorted-array"><span class="toc-number">16.10.</span> <span class="toc-text">❀540. Single Element in a Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀1060-missing-element-in-sorted-array"><span class="toc-number">16.11.</span> <span class="toc-text">❀❀1060. Missing Element in Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀33-search-in-rotated-sorted-array"><span class="toc-number">16.12.</span> <span class="toc-text">❀❀33. Search in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀153-find-minimum-in-rotated-sorted-array"><span class="toc-number">16.13.</span> <span class="toc-text">❀153. Find Minimum in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀154-find-minimum-in-rotated-sorted-array-ii"><span class="toc-number">16.14.</span> <span class="toc-text">❀❀154. Find Minimum in Rotated Sorted Array II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀287-find-the-duplicate-number"><span class="toc-number">16.15.</span> <span class="toc-text">❀❀287. Find the Duplicate Number</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#和值"><span class="toc-number">17.</span> <span class="toc-text">和值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1-two-sum"><span class="toc-number">17.1.</span> <span class="toc-text">❀1. Two Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1010-pairs-of-songs-with-total-durations-divisible-by-60"><span class="toc-number">17.2.</span> <span class="toc-text">❀1010. Pairs of Songs With Total Durations Divisible by 60</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀167-two-sum-ii-input-array-is-sorted"><span class="toc-number">17.3.</span> <span class="toc-text">❀167. Two Sum II - Input array is sorted</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1099-two-sum-less-than-k"><span class="toc-number">17.4.</span> <span class="toc-text">1099. Two Sum Less Than K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀16-3sum-closest"><span class="toc-number">17.5.</span> <span class="toc-text">❀16. 3Sum Closest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀259-3sum-smaller"><span class="toc-number">17.6.</span> <span class="toc-text">❀259. 3Sum Smaller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#454-4sum-ii"><span class="toc-number">17.7.</span> <span class="toc-text">454. 4Sum II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#差分"><span class="toc-number">18.</span> <span class="toc-text">差分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀888-fair-candy-swap"><span class="toc-number">18.1.</span> <span class="toc-text">❀888. Fair Candy Swap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1228-missing-number-in-arithmetic-progression"><span class="toc-number">18.2.</span> <span class="toc-text">1228. Missing Number In Arithmetic Progression</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀724-find-pivot-index"><span class="toc-number">18.3.</span> <span class="toc-text">❀724. Find Pivot Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1013-partition-array-into-three-parts-with-equal-sum"><span class="toc-number">18.4.</span> <span class="toc-text">❀1013. Partition Array Into Three Parts With Equal Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀453-minimum-moves-to-equal-array-elements"><span class="toc-number">18.5.</span> <span class="toc-text">❀453. Minimum Moves to Equal Array Elements</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区间段操作"><span class="toc-number">19.</span> <span class="toc-text">区间段操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀303-range-sum-query-immutable"><span class="toc-number">19.1.</span> <span class="toc-text">❀303. Range Sum Query - Immutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀325-maximum-size-subarray-sum-equals-k"><span class="toc-number">19.2.</span> <span class="toc-text">❀325. Maximum Size Subarray Sum Equals k</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀560-subarray-sum-equals-k"><span class="toc-number">19.3.</span> <span class="toc-text">❀560. Subarray Sum Equals K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀238-product-of-array-except-self"><span class="toc-number">19.4.</span> <span class="toc-text">❀238. Product of Array Except Self</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀548-split-array-with-equal-sum"><span class="toc-number">19.5.</span> <span class="toc-text">❀548. Split Array with Equal Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀862-shortest-subarray-with-sum-at-least-k"><span class="toc-number">19.6.</span> <span class="toc-text">❀❀862. Shortest Subarray with Sum at Least K</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#滑动窗口"><span class="toc-number">20.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#643-maximum-average-subarray-i"><span class="toc-number">20.1.</span> <span class="toc-text">643. Maximum Average Subarray I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀567-permutation-in-string"><span class="toc-number">20.2.</span> <span class="toc-text">❀567. Permutation in String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1100-find-k-length-substrings-with-no-repeated-characters"><span class="toc-number">20.3.</span> <span class="toc-text">❀1100. Find K-Length Substrings With No Repeated Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀76-minimum-window-substring"><span class="toc-number">20.4.</span> <span class="toc-text">❀76. Minimum Window Substring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀209-minimum-size-subarray-sum"><span class="toc-number">20.5.</span> <span class="toc-text">❀209. Minimum Size Subarray Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀3-longest-substring-without-repeating-characters"><span class="toc-number">20.6.</span> <span class="toc-text">❀3. Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀159-longest-substring-with-at-most-two-distinct-characters"><span class="toc-number">20.7.</span> <span class="toc-text">❀159 Longest Substring with At Most Two Distinct Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#904-fruit-into-baskets"><span class="toc-number">20.8.</span> <span class="toc-text">904. Fruit Into Baskets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#340-longest-substring-with-at-most-k-distinct-characters"><span class="toc-number">20.9.</span> <span class="toc-text">340. Longest Substring with At Most K Distinct Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀992-subarrays-with-k-different-integers"><span class="toc-number">20.10.</span> <span class="toc-text">❀❀992. Subarrays with K Different Integers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀395-longest-substring-with-at-least-k-repeating-characters"><span class="toc-number">20.11.</span> <span class="toc-text">❀❀395. Longest Substring with At Least K Repeating Characters</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">21.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀912-sort-an-array"><span class="toc-number">21.1.</span> <span class="toc-text">❀❀912. Sort an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀75-sort-colors"><span class="toc-number">21.2.</span> <span class="toc-text">❀75. Sort Colors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀347-top-k-frequent-elements"><span class="toc-number">21.3.</span> <span class="toc-text">❀❀347. Top K Frequent Elements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀506-relative-ranks"><span class="toc-number">21.4.</span> <span class="toc-text">❀506. Relative Ranks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1086-high-five"><span class="toc-number">21.5.</span> <span class="toc-text">1086. High Five</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1122-relative-sort-array"><span class="toc-number">21.6.</span> <span class="toc-text">❀1122. Relative Sort Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1051-height-checker"><span class="toc-number">21.7.</span> <span class="toc-text">1051. Height Checker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀945-minimum-increment-to-make-array-unique"><span class="toc-number">21.8.</span> <span class="toc-text">❀945. Minimum Increment to Make Array Unique</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1200-minimum-absolute-difference"><span class="toc-number">21.9.</span> <span class="toc-text">1200. Minimum Absolute Difference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀315-count-of-smaller-numbers-after-self"><span class="toc-number">21.10.</span> <span class="toc-text">❀❀315. Count of Smaller Numbers After Self</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀406-queue-reconstruction-by-height"><span class="toc-number">21.11.</span> <span class="toc-text">❀406. Queue Reconstruction by Height</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1057-campus-bikes"><span class="toc-number">21.12.</span> <span class="toc-text">❀1057. Campus Bikes</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子序列"><span class="toc-number">22.</span> <span class="toc-text">子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#594-longest-harmonious-subsequence"><span class="toc-number">22.1.</span> <span class="toc-text">594. Longest Harmonious Subsequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀128-longest-consecutive-sequence"><span class="toc-number">22.2.</span> <span class="toc-text">❀128. Longest Consecutive Sequence</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区间"><span class="toc-number">23.</span> <span class="toc-text">区间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#252-meeting-rooms"><span class="toc-number">23.1.</span> <span class="toc-text">252. Meeting Rooms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀56-merge-intervals"><span class="toc-number">23.2.</span> <span class="toc-text">❀56. Merge Intervals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#986-interval-list-intersections"><span class="toc-number">23.3.</span> <span class="toc-text">986. Interval List Intersections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀253-meeting-rooms-ii"><span class="toc-number">23.4.</span> <span class="toc-text">❀253. Meeting Rooms II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀435-non-overlapping-intervals"><span class="toc-number">23.5.</span> <span class="toc-text">❀435. Non-overlapping Intervals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀452-minimum-number-of-arrows-to-burst-balloons"><span class="toc-number">23.6.</span> <span class="toc-text">❀❀452. Minimum Number of Arrows to Burst Balloons</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#顺序模拟"><span class="toc-number">24.</span> <span class="toc-text">顺序模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#717-1-bit-and-2-bit-characters"><span class="toc-number">24.1.</span> <span class="toc-text">717. 1-bit and 2-bit Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#806-number-of-lines-to-write-string"><span class="toc-number">24.2.</span> <span class="toc-text">806. Number of Lines To Write String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#657-robot-return-to-origin"><span class="toc-number">24.3.</span> <span class="toc-text">657. Robot Return to Origin</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">25.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀11-container-with-most-water"><span class="toc-number">25.1.</span> <span class="toc-text">❀11. Container With Most Water</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀42-trapping-rain-water"><span class="toc-number">25.2.</span> <span class="toc-text">❀❀42. Trapping Rain Water</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀❀407-trapping-rain-water-ii"><span class="toc-number">25.3.</span> <span class="toc-text">❀❀407. Trapping Rain Water II</span></a></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Linest
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> customized by <a href="#">Linest</a> with <span class="octicon octicon-heart" style="color:red"></span>
				</div>
				<div class="hide">
						<a href="https://clustrmaps.com/site/x7rd" title="Visit tracker"><img src="//clustrmaps.com/map_v2.png?cl=ffffff&w=70&t=n&d=trdgmMc8YDC9aFR4WIBOzfE8f6bNwx_Pq7HA9YiG3sA" /></a>
				</div>
    </div>
  </div>
</footer>

    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true
	}
</script>

<!-- Baidu auto push -->
<script>
(function(){
	var bp = document.createElement('script');
	var curProtocol = window.location.protocol.split(':')[0];
	if (curProtocol === 'https') {
		bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	}
	else {
		bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	}
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(bp, s);
})();
</script>

<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



  </div>
<script>!function(i){var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function r(t,e){var n=new Image,i=t.getAttribute("data-original");n.onload=function(){t.src=i,e&&e()},n.src=i}function t(){for(var t=0;t<o.length;t++)e=o[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(i.innerHeight||document.documentElement.clientHeight)&&r(o[t],function(){o.splice(t,t)});var e,n}t(),i.addEventListener("scroll",t)}(this);</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>