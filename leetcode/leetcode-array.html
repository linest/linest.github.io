<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>LeetCode--数组篇 | Blog of Linest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结  关注点  数组长度 有序/部分有序 数值特性  范围 重复    操作  单向遍历 两侧中心遍历 二次正反向遍历 双列同步遍历 二分搜索  技巧  索引访问数组，一定要有前置条件限定范围 先不考虑特例，根据下标修正条件 Arrays.fill(arr, value)初始化 Arrays.copyOf(arr, length)复制  单调性  ❀896. Monotonic Array  判">
<meta property="og:type" content="website">
<meta property="og:title" content="LeetCode--数组篇">
<meta property="og:url" content="http://linest.github.io/leetcode/leetcode-array.html">
<meta property="og:site_name" content="Blog of Linest">
<meta property="og:description" content="总结  关注点  数组长度 有序/部分有序 数值特性  范围 重复    操作  单向遍历 两侧中心遍历 二次正反向遍历 双列同步遍历 二分搜索  技巧  索引访问数组，一定要有前置条件限定范围 先不考虑特例，根据下标修正条件 Arrays.fill(arr, value)初始化 Arrays.copyOf(arr, length)复制  单调性  ❀896. Monotonic Array  判">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-01T02:31:21.321Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode--数组篇">
<meta name="twitter:description" content="总结  关注点  数组长度 有序/部分有序 数值特性  范围 重复    操作  单向遍历 两侧中心遍历 二次正反向遍历 双列同步遍历 二分搜索  技巧  索引访问数组，一定要有前置条件限定范围 先不考虑特例，根据下标修正条件 Arrays.fill(arr, value)初始化 Arrays.copyOf(arr, length)复制  单调性  ❀896. Monotonic Array  判">
  
    <link rel="alternative" href="/atom.xml" title="Blog of Linest" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/fonts/octicons/octicons.css">
  <link rel="stylesheet" href="/css/fonts/font-awesome-4.6.3/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Linest</a></h1>
		</hgroup>

		
		<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/doodle">涂鸦</a></li>
				        
							<li><a href="/live2d">云撸猫</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tagcloud">标签&amp;分类</a></li>
				        
						</ul>
					</nav>	
				</section>
				
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">勤奋的懒惰者，爱听故事的人~ Zjuer</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Linest</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/assets/avatar/pika.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Linest</h1>
			</hgroup>
			
			<p class="header-subtitle">试验田|小黑屋|百宝箱|里程碑</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/doodle">涂鸦</a></li>
		        
					<li><a href="/live2d">云撸猫</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tagcloud">标签&amp;分类</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/linest" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:xlinest@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/leetcode/leetcode-array.html" class="article-date">
  	<time datetime="2019-12-01T02:31:21.321Z" itemprop="datePublished">2019-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode--数组篇
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="总结">总结</h1>
<hr>
<h2 id="关注点">关注点</h2>
<ul>
<li>数组长度</li>
<li>有序/部分有序</li>
<li>数值特性
<ul>
<li>范围</li>
<li>重复</li>
</ul>
</li>
</ul>
<h2 id="操作">操作</h2>
<ul>
<li>单向遍历</li>
<li>两侧中心遍历</li>
<li>二次正反向遍历</li>
<li>双列同步遍历</li>
<li>二分搜索</li>
</ul>
<h2 id="技巧">技巧</h2>
<ul>
<li>索引访问数组，一定要有前置条件限定范围</li>
<li>先不考虑特例，根据下标修正条件</li>
<li>Arrays.fill(arr, value)初始化</li>
<li>Arrays.copyOf(arr, length)复制</li>
</ul>
<h1 id="单调性">单调性</h1>
<hr>
<h2 id="❀896-monotonic-array">❀896. Monotonic Array</h2>
<blockquote>
<p>判断是否单调数组</p>
</blockquote>
<p>维护两个标志单增单减，判断是否违反</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> increase = <span class="keyword">true</span>, decrease = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                decrease = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                increase = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> increase || decrease;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="941-valid-mountain-array">941. Valid Mountain Array</h2>
<blockquote>
<p>判断数组是否是山峰形</p>
</blockquote>
<p>分别从左右两端找山顶，判断吃否重合。注意避免单调增减情况，即峰顶不能出现在两端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.length - <span class="number">1</span> &amp;&amp; A[i+<span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; A[j-<span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == j &amp;&amp; i != A.length-<span class="number">1</span> &amp;&amp; j != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀665-non-decreasing-array">❀665. Non-decreasing Array</h2>
<blockquote>
<p>判断至多修改一个元素，是否能让数组单调递增</p>
</blockquote>
<p>单向遍历判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="comment">//长度2以下都可以修成递增</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//找到非递增位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="comment">//已经第二次找到，否定</span></span><br><span class="line">                <span class="keyword">if</span>(find) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    find = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//异常点在上侧，∴ 此时i位置在右下，判断排除左边，当前和前面保持递增</span></span><br><span class="line">                    <span class="comment">//特例修正，初始就异常</span></span><br><span class="line">                    <span class="keyword">boolean</span> upper = i == <span class="number">1</span> ? nums[i] &lt;= nums[i+<span class="number">1</span>] : nums[i-<span class="number">2</span>] &lt;= nums[i];</span><br><span class="line">                    <span class="comment">//异常点在下侧，∵ 此时i位置在下方，判断排除当前，左右两边保持递增</span></span><br><span class="line">                    <span class="comment">//特例修正，最后才异常</span></span><br><span class="line">                    <span class="keyword">boolean</span> lower = i == size-<span class="number">1</span> || nums[i-<span class="number">1</span>] &lt;= nums[i+<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//两种都不行，否定</span></span><br><span class="line">                    <span class="keyword">if</span>(!upper &amp;&amp; !lower) &#123;</span><br><span class="line">                    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀581-shortest-unsorted-continuous-subarray">❀581. Shortest Unsorted Continuous Subarray</h2>
<blockquote>
<p>排序一个子数组使得全局排序，求子数组长度，即求不符合整体递增的区间</p>
</blockquote>
<p>直观解法，先排序，然后比对不一样的区间，复杂度O(nlogn)<br>
O(n)解法，利用动态最大最小值</p>
<ul>
<li>从左向右遍历，如果发现值比当前最大值小，说明最大值错位，当前在应该排序范围内，设为区间结束</li>
<li>从右向左遍历，如果发现值比当前最小值大，说明最小值错位，当前在应该排序范围内，设为区间开始</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>], end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = nums[nums.length-<span class="number">1</span>], start = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; min) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start == -<span class="number">1</span> ? <span class="number">0</span> : end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外建哈希">外建哈希</h1>
<hr>
<h2 id="217-contains-duplicate">217. Contains Duplicate</h2>
<blockquote>
<p>判断数组是否包含重复</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="219-contains-duplicate-ii">219. Contains Duplicate II</h2>
<blockquote>
<p>判断是否有重复，并且索引相距k以内</p>
</blockquote>
<p>维护map存索引,因为索引递增,所以总是更新成最新索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - map.get(nums[i]) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="349-intersection-of-two-arrays">349. Intersection of Two Arrays</h2>
<blockquote>
<p>数组求交集，结果无重复</p>
</blockquote>
<p>第一个数组建set,另一个查询，查到后删除避免重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums1) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.remove(num)) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="350-intersection-of-two-arrays-ii">350. Intersection of Two Arrays II</h2>
<blockquote>
<p>数组求交集，结果要包含重复</p>
</blockquote>
<p>用哈希表统计次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(i, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(i, map.get(i)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1207-unique-number-of-occurrences">1207. Unique Number of Occurrences</h2>
<blockquote>
<p>判断数组频次是否重复</p>
</blockquote>
<p>先map统计频次，再set判断重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : map.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="697-degree-of-an-array">697. Degree of an Array</h2>
<blockquote>
<p>求最高频次数字在数组中的最小长度</p>
</blockquote>
<p>统计，最高频，最小间距</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cntMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; startMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; endMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = nums[i];</span><br><span class="line">            cntMap.put(val, cntMap.getOrDefault(val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            startMap.putIfAbsent(val,i);</span><br><span class="line">            endMap.put(val,i);</span><br><span class="line">            cnt = Math.max(cnt, cntMap.get(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : cntMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cntMap.get(i) == cnt) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = endMap.get(i) - startMap.get(i) + <span class="number">1</span>;</span><br><span class="line">                minLen = Math.min(minLen, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="760-find-anagram-mappings">760. Find Anagram Mappings</h2>
<blockquote>
<p>两个数组顺序不一样，求位置映射，重复元素可以多对一映射</p>
</blockquote>
<p>第二个数组建立哈希表，存新位置，遍历第一个数组联系新旧位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] anagramMappings(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            map.put(B[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            res[i] = map.get(A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="599-minimum-index-sum-of-two-lists">599. Minimum Index Sum of Two Lists</h2>
<blockquote>
<p>求两个无重复数组中索引和最小的公共元素</p>
</blockquote>
<p>哈希表记录第一个数组元素和索引，第二个数组判断条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++) &#123;</span><br><span class="line">            map.put(list1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> minSum = list1.length + list2.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.length; i++) &#123;</span><br><span class="line">            String s = list2[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s)) &#123;</span><br><span class="line">                <span class="keyword">int</span> sumIndex = map.get(s) + i;</span><br><span class="line">                <span class="keyword">if</span>(sumIndex == minSum) &#123;</span><br><span class="line">                    list.add(s);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sumIndex &lt; minSum) &#123;</span><br><span class="line">                    minSum = sumIndex;</span><br><span class="line">                    list.clear();</span><br><span class="line">                    list.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自身哈希">自身哈希</h1>
<hr>
<h2 id="❀448-find-all-numbers-disappeared-in-an-array">❀448. Find All Numbers Disappeared in an Array</h2>
<blockquote>
<p>数组中数字范围1~N，现在其中一些数字重复，导致一部分数字没出现，求没出现数字</p>
</blockquote>
<p>允许哈希表的话很简单，在不使用额外结构的话，采用负数的方式把数组自身作为哈希表使用<br>
如果一个数字出现，那么相应索引位上变为负值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀645-set-mismatch">❀645. Set Mismatch</h2>
<blockquote>
<p>1~n有一个数字缺失变成了另一个数字，找出重复的数字和缺失的数字</p>
</blockquote>
<p>利用原数组下标作为哈希表，负值标记是否出现，省去了哈希表空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(i) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = index+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀41-first-missing-positive">❀41. First Missing Positive</h2>
<blockquote>
<p>可能有负值的n个数字构成数组，求第一个缺失的正数</p>
</blockquote>
<p>如果数组由1~n构成，此时连续，那么第一个缺失正数为n+1<br>
如果数组包含1<sub>n外其他数字，那么缺失范围肯定在1</sub>n内<br>
通常情况下开一个哈希标记，但是范围刚好和下标范围吻合，可以直接利用数组自身无需额外空间，即尝试把数字放在正确的位置上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//尝试每个位置，到不能交换为止</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">//如果在范围内，那么交换到正确位置</span></span><br><span class="line">            <span class="comment">//可能从后面换过来一个尚未判断的数,因此需要再次判断</span></span><br><span class="line">            <span class="keyword">int</span> val = nums[i], idx = val - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; <span class="number">0</span> &amp;&amp; idx &lt; n &amp;&amp; nums[idx] != val) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[idx];</span><br><span class="line">                nums[idx] = val;</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//存在缺失直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组1~n连续无缺失</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="连续分段">连续分段</h1>
<hr>
<h2 id="485-max-consecutive-ones">485. Max Consecutive Ones</h2>
<blockquote>
<p>只包含01的数组，求1最长连续出现次数</p>
</blockquote>
<p>遍历计数，遇0更新最大，注意末尾可能没0最后需要再更新一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, cnt = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    max = Math.max(max, cnt);</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="551-student-attendance-record-i">551. Student Attendance Record I</h2>
<blockquote>
<p>判断字符串A不超过1个,连续L长度不超过2个</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRecord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cntA = <span class="number">0</span>, maxL=<span class="number">0</span>, cntL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'A'</span>) &#123;</span><br><span class="line">                cntA++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                cntL++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxL = Math.max(maxL, cntL);</span><br><span class="line">                cntL = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxL = Math.max(maxL, cntL);</span><br><span class="line">        <span class="keyword">return</span> cntA &lt;= <span class="number">1</span> &amp;&amp; maxL &lt;=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="830-positions-of-large-groups">830. Positions of Large Groups</h2>
<blockquote>
<p>连续次数超过3的首尾位置</p>
</blockquote>
<p>尾触发统计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String S) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == S.charAt(i-<span class="number">1</span>)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(i-len, i-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            res.add(Arrays.asList(n-len, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="696-count-binary-substrings">696. Count Binary Substrings</h2>
<blockquote>
<p>统计有多少子串，01数量相等且0和1聚集，多次出现也算</p>
</blockquote>
<p>子串只能出现在分界处，比如0001111包含01,0011,000111，即两侧频次最少值<br>
连续分段统计，尾触发，子串数为两侧最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, pre = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || s.charAt(i) != s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                res += Math.min(cur, pre);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + Math.min(cur, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="674-longest-continuous-increasing-subsequence">674. Longest Continuous Increasing Subsequence</h2>
<blockquote>
<p>最长连续递增序列</p>
</blockquote>
<p>发现下降时触发前面比较，最后收尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxLen = Math.max(maxLen, len);</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxLen,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀443-string-compression">❀443. String Compression</h2>
<blockquote>
<p>连续相同字符用数字表示进行压缩，返回压缩后长度</p>
</blockquote>
<p>逐个字符遍历，尾触发，末尾再处理一遍，注意次数可能多位，需要转字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> prev = chars[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == prev) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                chars[index++] = prev;</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> s : String.valueOf(cnt).toCharArray()) &#123;</span><br><span class="line">                        chars[index++] = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = c;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            chars[index++] = prev;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> s : String.valueOf(cnt).toCharArray()) &#123;</span><br><span class="line">                    chars[index++] = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外围逐个串遍历，头触发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexAns = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; chars.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = chars[index];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; chars.length &amp;&amp; chars[index] == currentChar)&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[indexAns++] = currentChar;</span><br><span class="line">            <span class="keyword">if</span>(count != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : Integer.toString(count).toCharArray()) &#123;</span><br><span class="line">                    chars[indexAns++] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexAns;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀849-maximize-distance-to-closest-person">❀849. Maximize Distance to Closest Person</h2>
<blockquote>
<p>1代表有人，0代表空，求一个位置使得尽可能离人最远，求这个距离</p>
</blockquote>
<p>统计0次数问题，开头0，中间0，尾部0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="keyword">int</span>[] seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> head = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seats.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seats[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//head &amp; middle</span></span><br><span class="line">                max = head ? i : Math.max(max, (cnt+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">                head = <span class="keyword">false</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tail</span></span><br><span class="line">        max = Math.max(max, cnt);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="605-can-place-flowers">605. Can Place Flowers</h2>
<blockquote>
<p>0代表空着，1代表种花，花不能相邻，给一个局面，判断是否还能种下n个花</p>
</blockquote>
<p>实际上是统计连续0次数问题<br>
两个1之间，1-&gt;0, 2-&gt;0, 3-&gt;1, 4-&gt;1, 5-&gt;2, 符合(次数-1)/2<br>
开头0可以假想10开头，转换成两个1之间情况<br>
末尾0，1-&gt;0, 2-&gt;1, 3-&gt;1, 4-&gt;2, 符合次数/2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += (count-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">            result += count/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="投票">投票</h1>
<hr>
<h2 id="❀169-majority-element">❀169. Majority Element</h2>
<blockquote>
<p>找出超过半数的元素</p>
</blockquote>
<p>计数pk过程，超过半数肯定最终胜出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = nums[<span class="number">0</span>], count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == element) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                element = i;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀229-majority-element-ii">❀229. Majority Element II</h2>
<blockquote>
<p>超过三分之一的数字</p>
</blockquote>
<p>最多有两个数字满足<br>
投票法，两个位置，如果有空位就上，已在位就增加，如果没空位则两个候选都减<br>
假设有两个数字超过并且在位，那么其他数字小于三分之一，即使其他数字不内耗抵消，也抵消不完<br>
假设有一个数字超过并且在位，那么要抵消这个数字的一个就至少需要两个其他数字即首先要消一轮，然后上位一轮，还是抵消不完，这时留存的两个数字还需要进一步统计验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> can1 = <span class="number">0</span>,can2 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//候选流程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="comment">//vote 1</span></span><br><span class="line">			<span class="keyword">if</span>(cnt1 != <span class="number">0</span> &amp;&amp; i == can1) &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//vote 2</span></span><br><span class="line">            <span class="keyword">if</span>(cnt2 != <span class="number">0</span> &amp;&amp; i == can2) &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//be 1</span></span><br><span class="line">            <span class="keyword">if</span>(cnt1 == <span class="number">0</span>)&#123;</span><br><span class="line">                can1 = i;</span><br><span class="line">                cnt1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//be 2</span></span><br><span class="line">            <span class="keyword">if</span>(cnt2 == <span class="number">0</span>)&#123;</span><br><span class="line">                can2 = i;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//pk</span></span><br><span class="line">            cnt1--;</span><br><span class="line">            cnt2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进一步验证，遍历统计</span></span><br><span class="line">        cnt1 = <span class="number">0</span>;</span><br><span class="line">        cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == can1)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == can2)&#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> th = nums.length/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 &gt; th) &#123;</span><br><span class="line">            res.add(can1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt2 &gt; th) &#123;</span><br><span class="line">            res.add(can2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀961-n-repeated-element-in-size-2n-array">❀961. N-Repeated Element in Size 2N Array</h2>
<blockquote>
<p>一个元素刚好半数次数，其余各不相等，找出这个元素</p>
</blockquote>
<p>先去掉一个元素，如果选对这个元素就是目标，那么其他元素会与之相等；如果选错，那么转化为余下的超过半数，由于其余各不相等，也不用计数直接替换即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chosen = A[<span class="number">0</span>], travel = A[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = A[i];</span><br><span class="line">            <span class="keyword">if</span>(curr == chosen || curr == travel) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                travel = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> travel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最值">最值</h1>
<hr>
<h2 id="747-largest-number-at-least-twice-of-others">747. Largest Number At Least Twice of Others</h2>
<blockquote>
<p>正数数组，判断最大值是否是其余值至少两倍，保证最大值唯一</p>
</blockquote>
<p>实际上是求最大和次大，已经保证唯一，无需在位检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>, max = -<span class="number">1</span>, secondMax = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max == -<span class="number">1</span> || nums[i] &gt; max) &#123;</span><br><span class="line">                secondMax = max;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; secondMax) &#123;</span><br><span class="line">                secondMax = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max &gt;= <span class="number">2</span>*secondMax ? index : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀414-third-maximum-number">❀414. Third Maximum Number</h2>
<blockquote>
<p>找第三大的数值，如果没有返回最大值</p>
</blockquote>
<p>保留3个席位，最值不可重复，已经在位则忽略<br>
从高位比较，如果上位，把当前位依次下放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Integer max1 = <span class="keyword">null</span>,max2 = <span class="keyword">null</span>,max3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="comment">//如果和前三任意相等，已经在位，忽略</span></span><br><span class="line">            <span class="keyword">if</span>(max1 !=<span class="keyword">null</span> &amp;&amp; i == max1 </span><br><span class="line">               || max2 !=<span class="keyword">null</span> &amp;&amp; i == max2 </span><br><span class="line">               || max3 !=<span class="keyword">null</span> &amp;&amp; i == max3)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(max1 == <span class="keyword">null</span> || i &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max2 == <span class="keyword">null</span> || i &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max3 == <span class="keyword">null</span> || i &gt; max3) &#123;</span><br><span class="line">                max3 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max3 == <span class="keyword">null</span> ? max1 : max3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="628-maximum-product-of-three-numbers">628. Maximum Product of Three Numbers</h2>
<blockquote>
<p>求三个数最大乘积</p>
</blockquote>
<p>因为有负数，所以最大值可能是最大三个数乘积，也可能是最小两个数和最大数乘积<br>
即求最大三个数和最小两个数，并且最值多次出现可以占多个席位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max1 = -<span class="number">1001</span>, max2 = -<span class="number">1001</span>, max3 = -<span class="number">1001</span>;</span><br><span class="line">        <span class="keyword">int</span> min1 = <span class="number">1001</span>, min2 = <span class="number">1001</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; max3) &#123;</span><br><span class="line">                max3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; min2) &#123;</span><br><span class="line">                min2 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max1 * max2 * max3, min1 * min2 * max1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀215-kth-largest-element-in-an-array">❀215. Kth Largest Element in an Array</h2>
<blockquote>
<p>找到数组中第k大的数，保证存在</p>
</blockquote>
<p>利用快排partition思想，如果partition刚好以目标数位支点，那么得到答案<br>
快排每次考虑支点两侧，平均复杂度O(nlogn)，而这里每次舍去一半，平均复杂度O(n)， 最坏O(n2)<br>
BFPRT算法保证稳定O(n),实质上解决了支点选择问题：将数据分成大小为5的组，组内排序选中位数，所有中位数选中位数，以此为支点进行划分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = nums.length - k;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; target) &#123;</span><br><span class="line">                low = index + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &gt; target) &#123;</span><br><span class="line">                high = index -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//反正直接选，直接选尾部，省去交换到尾部操作</span></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[e];</span><br><span class="line">        <span class="keyword">int</span> i = s,j = e;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾部有支点，使用大于等于跳过</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, e);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="908-smallest-range-i">908. Smallest Range I</h2>
<blockquote>
<p>给数组和一个可供加减的数字，修正数组使得最大最小值最接近<br>
实际上就是找最大最小值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = A[<span class="number">0</span>], max = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; min) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> range = max-min-<span class="number">2</span>*K;</span><br><span class="line">        <span class="keyword">return</span> range &gt; <span class="number">0</span> ? range : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="距离">距离</h1>
<hr>
<h2 id="❀243-shortest-word-distance">❀243. Shortest Word Distance</h2>
<blockquote>
<p>给一个单词组，给两个不同单词，求这两个单词最小距离</p>
</blockquote>
<p>设两个元素AB,最短距离无非就是最近的A…B或者B…A，总有一个在后面<br>
只要遍历到某个元素然后和之前的另一元素比较即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1 = -<span class="number">1</span>, idx2 = -<span class="number">1</span>, distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx2 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx1 - idx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                idx2 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx1 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx2 - idx1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="244-shortest-word-distance-ii">244. Shortest Word Distance II</h2>
<blockquote>
<p>多次求任意两个不同单词的最小距离</p>
</blockquote>
<p>因为是多次求，每次全量遍历比较耗时<br>
提前维护哈希表，存储每个单词和它出现的下标列表<br>
取出两个要求单词的位置列表，每次计算差值并舍去较小的一个</p>
<h2 id="❀245-shortest-word-distance-iii">❀245. Shortest Word Distance III</h2>
<blockquote>
<p>单词可以相同，求最短</p>
</blockquote>
<p>如果单词相等，那么原逻辑两个指针每次都会重合，这里加个条件，只计算第一次距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1 = -<span class="number">1</span>, idx2 = -<span class="number">1</span>, distance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> isSame = word1.equals(word2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word1))&#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx2 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx1 - idx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(word2))&#123;</span><br><span class="line">                idx2 = i;</span><br><span class="line">                <span class="keyword">if</span>(idx1 != -<span class="number">1</span> &amp;&amp; !isSame) &#123;</span><br><span class="line">                    distance = Math.min(distance, idx2 - idx1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀821-shortest-distance-to-a-character">❀821. Shortest Distance to a Character</h2>
<blockquote>
<p>输出每个位置到指定字符位置的最短距离</p>
</blockquote>
<p>字符可能有多个，最短可能和左边也可能和右边<br>
两次正反遍历，第一次正向只考虑左边，第二次逆向只考虑右边，每个位置取两次最短</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(res,n);</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == C) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos != -<span class="number">1</span>) &#123;</span><br><span class="line">                res[i] = i - pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == C) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos != -<span class="number">1</span>) &#123;</span><br><span class="line">                res[i] = Math.min(res[i], pos - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="首尾">首尾</h1>
<hr>
<h2 id="977-squares-of-a-sorted-array">977. Squares of a Sorted Array</h2>
<blockquote>
<p>有序数组，生成平方后的有序数组</p>
</blockquote>
<p>绝对值大的肯定在首尾，双指针遍历每次取其一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length-<span class="number">1</span>, n = A.length;</span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = A[i] * A[i], q = A[j] * A[j];</span><br><span class="line">            <span class="keyword">if</span>(p &gt; q) &#123;</span><br><span class="line">                result[n] = p;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[n] = q;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原地交换移位">原地交换移位</h1>
<hr>
<h2 id="❀189-rotate-array">❀189. Rotate Array</h2>
<blockquote>
<p>数组循环右移</p>
</blockquote>
<p>原地操作，部分逆序再整体逆序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len-k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,len-k, len-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀905-sort-array-by-parity">❀905. Sort Array By Parity</h2>
<blockquote>
<p>调整数组使得偶数在前，奇数在后</p>
</blockquote>
<p>双指针两侧交换，注意任何时候注意数组越界检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i&lt;j保证不会越界，最多ij重合，交换也无所谓</span></span><br><span class="line">            <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀922-sort-array-by-parity-ii">❀922. Sort Array By Parity II</h2>
<blockquote>
<p>调整数组使得奇数位置为奇数，偶数位置为偶数</p>
</blockquote>
<p>双指针同侧遍历，一个只遍历奇数位，一个只遍历偶数位，适时交换数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; A.length) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; A.length &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; A.length &amp;&amp; j % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; A.length &amp;&amp; j &lt; A.length) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原地覆写">原地覆写</h1>
<hr>
<h2 id="❀88-merge-sorted-array">❀88. Merge Sorted Array</h2>
<blockquote>
<p>两个有序数组，假设第一个长度足够，把第二个合并进去</p>
</blockquote>
<p>头部被原数据占用，采用从后端进行归并的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m-<span class="number">1</span>, j=n-<span class="number">1</span>, k = m+n-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &gt;=<span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		    nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀27-remove-element">❀27. Remove Element</h2>
<blockquote>
<p>原地删除指定值，返回新长度</p>
</blockquote>
<p>用后面其他值覆盖掉要删除的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val) &#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀26-remove-duplicates-from-sorted-array">❀26. Remove Duplicates from Sorted Array</h2>
<blockquote>
<p>有序数组原地去重，返回新长度</p>
</blockquote>
<p>判断和已有结果末尾是否重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">0</span> || nums[i] != nums[index-<span class="number">1</span>]) &#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀80-remove-duplicates-from-sorted-array-ii">❀80. Remove Duplicates from Sorted Array II</h2>
<blockquote>
<p>有序数组，原地处理，允许最多出现两次其余删除</p>
</blockquote>
<p>判断已有结果末尾是否已经有两个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">2</span> || i != nums[index-<span class="number">2</span>]) &#123;</span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀283-move-zeroes">❀283. Move Zeroes</h2>
<blockquote>
<p>把0移到末尾，保持其他非0数字相对顺序</p>
</blockquote>
<p>不能收尾交换，会破坏相对顺序<br>
如果一个元素不是0，而且需要移动，那么移动到前面正确位置，当前位置0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//要判断是否已经在正确位置，否则会错误清零</span></span><br><span class="line">                <span class="keyword">if</span>(i != idx) &#123;</span><br><span class="line">                    nums[idx] = nums[i];</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1089-duplicate-zeros">❀1089. Duplicate Zeros</h2>
<blockquote>
<p>每遇到一个0，在后侧插入一个0，后面数据移位，越界的丢弃</p>
</blockquote>
<p>比如120304变为120030[04],4前面2个0需要移动2位，3前面1个0需要移动1位<br>
前面出现几个0，就要最终移几位，先统计0个数<br>
从左向右遍历时右侧插0会影响下一遍历，因此采取从右向左遍历，计算每个数字移位后的下标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, n = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="comment">//后面复制一个0</span></span><br><span class="line">                <span class="keyword">if</span>(i + cnt + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    arr[i + cnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试移动后是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(i + cnt &lt; n) &#123;</span><br><span class="line">                arr[i + cnt] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈辅助">栈辅助</h1>
<hr>
<h2 id="❀496-next-greater-element-i">❀496. Next Greater Element I</h2>
<blockquote>
<p>数组无重复，num1是num2子集，求每个num1在num2中后面更大的值，没有就-1</p>
</blockquote>
<p>扫描过程中，不知道下个更大值，先放到栈里，一个值可能是前面很多数的下一更大值，循环弹出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">            <span class="comment">//检查是否是前面值的下一更大值</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek()&lt;num) &#123;</span><br><span class="line">                hash.put(stack.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后面还未知，进栈等待</span></span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = hash.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1047-remove-all-adjacent-duplicates-in-string">1047. Remove All Adjacent Duplicates In String</h2>
<blockquote>
<p>相同的成对消除，直到不能消为止</p>
</blockquote>
<p>利用栈保持前面待消除的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == -<span class="number">1</span> || stack[top] != c) &#123;</span><br><span class="line">                stack[++top] = c;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(stack, <span class="number">0</span>, top+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀946-validate-stack-sequences">❀946. Validate Stack Sequences</h2>
<blockquote>
<p>给定入栈序列，随时可弹出，判断出栈序列合法性</p>
</blockquote>
<p>模拟入栈，匹配弹出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            stack.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == popped.length &amp;&amp; stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀84-largest-rectangle-in-histogram">❀84. Largest Rectangle in Histogram</h2>
<blockquote>
<p>给出数组代表高度，求最大矩形面积</p>
</blockquote>
<p>中心扩展法，以一个高度为基础，向左向右在满足高度条件下扩展，复杂度O(n2)<br>
注意以一个高度作为起始是不对的，比如凹形，结果是以中间为高度贯穿两侧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = heights[i];</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//向左扩展</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; heights[j] &gt;= h; j--) &#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向右扩展</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; heights[j] &gt;= h; j++) &#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125;</span><br><span class="line">            area = Math.max(area, w*h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为要计算宽度需要下标差，栈保存下标<br>
当前的比栈顶低，那么栈顶无法向右扩，因此新来的相当于右边界<br>
每次入栈时，比当前高的都出栈，等同于向左扩充，那么站内留存的相当于左边界<br>
即入栈时决定了左边界，出栈时决定了右边界，栈辅助，复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.length; i++) &#123;</span><br><span class="line">            <span class="comment">//尾触发，末尾添加-1，保证遍历结束时把留存的弹出</span></span><br><span class="line">            <span class="keyword">int</span> cur = (i == heights.length) ? -<span class="number">1</span> : heights[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= cur) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = heights[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> rightExcludeBorder = i;</span><br><span class="line">                <span class="comment">//如果栈内没有，说明左边界就是0前面，用-1表示</span></span><br><span class="line">                <span class="keyword">int</span> leftExcludeBorder = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="keyword">int</span> w = rightExcludeBorder - leftExcludeBorder - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, h * w);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀32-longest-valid-parentheses">❀32. Longest Valid Parentheses</h2>
<blockquote>
<p>求最长括号匹配子串长度</p>
</blockquote>
<p>匹配出栈，遇到不匹配就入栈<br>
栈顶就是上个不匹配的位置视为左界，如果新进不匹配则为右界，两个界限之间长度就是中间匹配长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), len = Integer.MIN_VALUE;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//尾触发，随便添加一个字符</span></span><br><span class="line">            <span class="keyword">char</span> curr = (i == n) ? <span class="string">'x'</span> : s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="string">')'</span> &amp;&amp; !stack.empty() &amp;&amp; s.charAt(stack.peek())== <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="comment">//成功匹配，出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                    <span class="comment">//栈空，说明前面都是匹配的</span></span><br><span class="line">                    len = Math.max(len, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//栈顶就是之前的不匹配界限，当前是新的不匹配界限，之间就是匹配段</span></span><br><span class="line">                    len = Math.max(len, i-stack.peek()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优先队列">优先队列</h1>
<hr>
<h2 id="1046-last-stone-weight">1046. Last Stone Weight</h2>
<blockquote>
<p>每次取两个最大的相撞，留下差值，求最后留下大小</p>
</blockquote>
<p>优先队列模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; Integer.compare(b,a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : stones) &#123;</span><br><span class="line">            pq.offer(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pq.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> y = pq.poll();</span><br><span class="line">            <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">                pq.offer(x-y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.isEmpty() ? <span class="number">0</span> : pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀373-find-k-pairs-with-smallest-sums">❀373. Find K Pairs with Smallest Sums</h2>
<blockquote>
<p>两个有序升序数组，求k个最小和值的数对，同一位置可对应另一数组多个位置</p>
</blockquote>
<p>维护最小堆，每调整一次O(logn)<br>
不需要全部数对放入堆中，利用有序性缩减候选<br>
直观上看，每个数组只有前k个有用，即使无重复利用，可以进一步优化成线性<br>
将一个数组所有元素和第二个数组首元素组合放入堆，并记录第二个元素位置，相当于第一个数组每个元素形成一个数对组合升序队列，把每个队列头节点加入堆中，每次弹出时，尝试推进第二个元素位置，即把次大值作为候选加入堆，问题转化为多个有序队列取topK，优先队列中始终只有k个，弹出一个补一个，整体复杂度O(klogk)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((a,b) -&gt; (a[<span class="number">0</span>] + a[<span class="number">1</span>])- (b[<span class="number">0</span>] + b[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//nums1 nums2 nums2index</span></span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; queue.size()&gt;<span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] v = queue.poll();</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">            <span class="keyword">int</span> index = v[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(index &lt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v[<span class="number">0</span>],nums2[index+<span class="number">1</span>],index+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分搜索">二分搜索</h1>
<hr>
<p>序列1,2,3</p>
<ul>
<li>搜索2，那么第一次中间就会命中</li>
<li>搜索1，第一次中间，第二次中间就是左侧命中，左右不重合</li>
<li>搜索3，第一次中间，第二次还是中间，第三次左右重合命中<br>
while条件里有等于选项，只要不命中，左右都会相对中点移动，因此会成功终止<br>
如果只有单侧移动的话，循环可以没有等于选项，最后会左右重合收敛到一点，但是要注意两个相邻的索引时的情况，避免死循环</li>
<li>根据默认二分公式，mid会和左边重合，因此左边必须有移动行为，<code>low = mid + 1</code></li>
<li>如果左边没有移动行为，那么可以改良二分公式，<code>mid = (low + high + 1)/2</code>,使得相邻时落在右边</li>
</ul>
<p>分类</p>
<ul>
<li>严格有序 vs 近似有序</li>
<li>单点查找 vs 边界查找</li>
</ul>
<h2 id="❀704-binary-search">❀704. Binary Search</h2>
<blockquote>
<p>有序无重复数组搜索目标的下标，没有返回-1</p>
</blockquote>
<p>基础版二分搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀34-find-first-and-last-position-of-element-in-sorted-array">❀34. Find First and Last Position of Element in Sorted Array</h2>
<blockquote>
<p>有序有重复数组，搜索指定元素的起点和终点，没有返回-1</p>
</blockquote>
<p>分解成两个二分搜索过程<br>
搜索起点时，如果找到元素，前面可能还有，所以调整上界时包含等于<br>
搜索终点时，如果找到元素，后面可能还有，所以调整下界时包含等于<br>
注意调整中点公式，选择左还是右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; searchFirst(nums, target), searchLast(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">                <span class="comment">//等于时，自身可能是结果，但是前面可能还有，所以自身作为上界继续搜索</span></span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low] == target ?  low : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//左面可能不动，中心需要改良到右侧</span></span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//等于时，自身可能是结果，但是后面可能还有，所以自身作为上界继续搜索</span></span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low] == target ?  low : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="278-first-bad-version">278. First Bad Version</h2>
<blockquote>
<p>从某一个版本开始坏掉，查找第一个坏掉的版本</p>
</blockquote>
<p>相当于二值000111格式，即求第一个1位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">boolean</span> isBad = isBadVersion(mid);</span><br><span class="line">            <span class="keyword">if</span>(isBad)&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="744-find-smallest-letter-greater-than-target">744. Find Smallest Letter Greater Than Target</h2>
<blockquote>
<p>有序字符串，查找大于目标的最小值</p>
</blockquote>
<p>二分搜索，第一个大于位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= letters[letters.length-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(letters,target,<span class="number">0</span>,letters.length);</span><br><span class="line">        <span class="keyword">return</span> letters[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &lt;= target) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀35-search-insert-position">❀35. Search Insert Position</h2>
<blockquote>
<p>有序无重复数组，找到目标插入位置</p>
</blockquote>
<p>即找到等于或者第一个大于的位置<br>
如果没找到，最后左右相邻，左值比目标小，右值比目标大，中心落在左边，左向右移左右重合<br>
重合后，中心比目标大，因此右向左移，因此最后左刚好是第一个大于的位置，右刚好是第一个小于的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀162-find-peak-element">❀162. Find Peak Element</h2>
<blockquote>
<p>无序数组找其中一个峰值，假定数组两端无限小</p>
</blockquote>
<p>两端无限小，那么左界是上升阶段，右界是下降阶段<br>
一个上升阶段和一个下降阶段中间必有一个峰值，因此二分搜索，找到两个中间值判断阶段取舍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="852-peak-index-in-a-mountain-array">852. Peak Index in a Mountain Array</h2>
<blockquote>
<p>给一个至少三个数据的先上升后下降的数组，求峰顶索引</p>
</blockquote>
<p>初始数组长度不是1，中点后面mid+1确保不会越界，可以用于比较<br>
如果中点后面比中值大，那么中点位置在上升期还没到顶，可以排除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &lt; A[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀540-single-element-in-a-sorted-array">❀540. Single Element in a Sorted Array</h2>
<blockquote>
<p>有序数组，只有一个数出现一次，其他两次，求这个数</p>
</blockquote>
<p>这个数两侧都是偶数个，根据中点右侧数量判断目标在哪边<br>
mid和mid+1不用检查越界，因为即使相邻两个数，mid会落在左侧，右侧永远有值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//中点本身和右侧是一对，但是右侧是偶数个说明目标在右侧</span></span><br><span class="line">                <span class="keyword">if</span>((high - mid) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//已知中点成对，全部跳过</span></span><br><span class="line">                    low = mid + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//中点本身和右侧不是一对，右侧偶数个说明右侧无目标</span></span><br><span class="line">                <span class="comment">//中点可能是目标点，不能移动</span></span><br><span class="line">                <span class="keyword">if</span>((high - mid) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    high = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀33-search-in-rotated-sorted-array">❀33. Search in Rotated Sorted Array</h2>
<blockquote>
<p>无重复的有序数组旋转后，进行特定值搜索</p>
</blockquote>
<p>整体框架是二分，由于被旋转过，需要一定规则指导目标在中值哪一侧，进而决定移动方向<br>
旋转后要么依然不变，要么变成闪电状</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> /  /</span><br><span class="line">/    /</span><br></pre></td></tr></table></figure>
<p>根据比较第一个元素，判断位于哪个分段，如果大于等于则在第一段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀153-find-minimum-in-rotated-sorted-array">❀153. Find Minimum in Rotated Sorted Array</h2>
<blockquote>
<p>无重复的有序数组旋转后，找最小值</p>
</blockquote>
<p>有序数组旋转后，变成两段升序，也可能还是原样一段升序</p>
<ul>
<li>如果还是升序，那么最小值就在左侧</li>
<li>如果两端升序，在第一段说明最小在后面，跳过并推进，在第二段说最小可能在前面，不跳过</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//没旋转</span></span><br><span class="line">        <span class="keyword">if</span>(nums[low] &lt;= nums[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀154-find-minimum-in-rotated-sorted-array-ii">❀154. Find Minimum in Rotated Sorted Array II</h2>
<blockquote>
<p>有重复的有序数组旋转后，找最小值</p>
</blockquote>
<p>含有重复值条件下，除了无重复时的两种状态外，还有可能出现收尾相等的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__/  __</span><br><span class="line">    /</span><br></pre></td></tr></table></figure>
<p>依然是和第一元素比较，如果能严格判断出大小关系，那么可以继续二分<br>
如果和第一元素相等，那么可能在左边，也可能在右边，无法知道方向，那么就跳过左右值中较大的值进行范围缩减，最坏退化成O(n)<br>
直接比较首尾已经无法判断是否旋转，如果没旋转，最后会找到最大值，返回值需要修正</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[low] &gt; nums[high]) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums[low], nums[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="和值">和值</h1>
<hr>
<h2 id="❀1-two-sum">❀1. Two Sum</h2>
<blockquote>
<p>找到两个数和为指定值，返回索引</p>
</blockquote>
<p>哈希查表，存储数字和对应索引<br>
遍历时，查看之前是否出现过另一值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> other = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(other))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(other), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀167-two-sum-ii-input-array-is-sorted">❀167. Two Sum II - Input array is sorted</h2>
<blockquote>
<p>有序数组，求和等于指定值的两个数字索引(起始为1)</p>
</blockquote>
<p>双侧指针，向中心收缩</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>, j+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1010-pairs-of-songs-with-total-durations-divisible-by-60">1010. Pairs of Songs With Total Durations Divisible by 60</h2>
<blockquote>
<p>两正数和为60倍数的数对个数</p>
</blockquote>
<p>对60取余，转化为两数和为60问题<br>
特例，如果原本就是60倍数，那么余数为0, 0和0也认为和60</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="keyword">int</span>[] time)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = time[i] % <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">int</span> pair = t == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">60</span> - t;</span><br><span class="line">            cnt += map.getOrDefault(pair, <span class="number">0</span>);</span><br><span class="line">            map.put(t, map.getOrDefault(t,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="454-4sum-ii">454. 4Sum II</h2>
<blockquote>
<p>四个等长数组，求下标组合(i,j,k,l)使得各取一个数字总和为0</p>
</blockquote>
<p>AB,CD两两双循环遍历求和存成map，转化为类似2Sum问题<br>
另外解法只保存AB结果map, CD边计算边检查AB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; countAB = twoSumCount(A, B);</span><br><span class="line">        Map&lt;Integer, Integer&gt; countCD = twoSumCount(C, D);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ab : countAB.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(countCD.containsKey(-ab)) &#123;</span><br><span class="line">                result += countAB.get(ab) * countCD.get(-ab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title">twoSumCount</span><span class="params">(<span class="keyword">int</span>[] x, <span class="keyword">int</span>[] y)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; sumCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = x.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = x[i] + y[j];</span><br><span class="line">                sumCount.put(sum, sumCount.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀548-split-array-with-equal-sum">❀548. Split Array with Equal Sum</h2>
<blockquote>
<p>数组，取中间3个值作为分割点剔除，判断能否让分割出的四个部分和相等</p>
</blockquote>
<p>计算数组不同范围和值，利用前序和<br>
中间三个点，通常需要三重循环。先以中间点分割，划分为两侧后单独计算，优化为双重循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分割后每段至少有一个数字，总长至少为7</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算前序和</span></span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i] = i == <span class="number">0</span>？ nums[i] : sum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以中间为支点，尝试等分左右两侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt; nums.length - <span class="number">3</span>; j++) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum1 = sum[i - <span class="number">1</span>], sum2 = sum[j - <span class="number">1</span>] - sum[i];</span><br><span class="line">                <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">                    set.add(sum1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">2</span>; k &lt; nums.length - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum3 = sum[nums.length - <span class="number">1</span>] - sum[k], sum4 = sum[k - <span class="number">1</span>] - sum[j];</span><br><span class="line">                <span class="keyword">if</span> (sum3 == sum4 &amp;&amp; set.contains(sum3)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="差分">差分</h1>
<hr>
<h2 id="888-fair-candy-swap">888. Fair Candy Swap</h2>
<blockquote>
<p>交换两个数组其中一个数字，使两个数组和相等</p>
</blockquote>
<p>先对两个数组求和，算出差值一半就是交换两个数字之差，转化为两数和问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> sumA = <span class="number">0</span>, sumB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            sumA += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            sumB += B[i];</span><br><span class="line">            set.add(B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = (sumB - sumA)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(A[i] + diff)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[i], A[i]+diff&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀724-find-pivot-index">❀724. Find Pivot Index</h2>
<blockquote>
<p>找到第一个支点使两侧和相等</p>
</blockquote>
<p>两次遍历，第一次求总和，第二次判断两侧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum  = <span class="number">0</span>, leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rightSum = sum - nums[i] - leftSum;</span><br><span class="line">            <span class="keyword">if</span>(rightSum == leftSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1013-partition-array-into-three-parts-with-equal-sum">1013. Partition Array Into Three Parts With Equal Sum</h2>
<blockquote>
<p>判断是否可以等分成三份</p>
</blockquote>
<p>先第一遍求总和，然后除3作为每一份和，再遍历一次统计<br>
注意和为0时是特例，可能找到多于三份</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> part = sum/<span class="number">3</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span>(sum == part) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间和">区间和</h1>
<hr>
<h2 id="❀303-range-sum-query-immutable">❀303. Range Sum Query - Immutable</h2>
<blockquote>
<p>多次查询数组任意区间段和值</p>
</blockquote>
<p>内部维护前序和，每次查询复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum[i] = (i == <span class="number">0</span>) ? nums[i] : preSum[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span>? preSum[j] : preSum[j] - preSum[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀560-subarray-sum-equals-k">❀560. Subarray Sum Equals K</h2>
<blockquote>
<p>含正负数连续和为K的子数组个数</p>
</blockquote>
<p>数字可以为负数，不能动态区间遍历<br>
两个前序和的差就是中间部分的和K，因此求前序和，辅助哈希表存储，key为前序和，value为同和数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前序和，出现次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始和为0,出现1次</span></span><br><span class="line">        preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">//检查之前是否出现了前序和小k的位置</span></span><br><span class="line">            <span class="keyword">if</span>(preSum.containsKey(sum-k)) &#123;</span><br><span class="line">                cnt += preSum.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            preSum.put(sum, preSum.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀325-maximum-size-subarray-sum-equals-k">❀325. Maximum Size Subarray Sum Equals k</h2>
<blockquote>
<p>含正负数数组连续和为K的子数组最大长度</p>
</blockquote>
<p>前序和，维护哈希表，值是前序和终点索引<br>
同一前序和只保留第一个位置即可，这样下标差值更大，区间长度更长</p>
<p>变化:</p>
<ul>
<li>求正负数个数相等的子数组 -&gt; 正数变为1，负数变为-1，转变为求前序和为0</li>
<li>只包含01，求01个数相等的子数组 -&gt; 负数变为-1，转变为求前序和为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//前序和为0，认为下标是-1</span></span><br><span class="line">        preSum.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (preSum.containsKey(sum - k)) &#123;</span><br><span class="line">                res = Math.max(res, i - preSum.get(sum - k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只记录第一次位置</span></span><br><span class="line">            preSum.putIfAbsent(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口">滑动窗口</h1>
<hr>
<p>定长，变长</p>
<h2 id="643-maximum-average-subarray-i">643. Maximum Average Subarray I</h2>
<blockquote>
<p>长度k子数组最大平均值</p>
</blockquote>
<p>定长滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum = sum + nums[i] - nums[i-k];</span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum/(<span class="keyword">double</span>)k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀239-sliding-window-maximum">❀239. Sliding Window Maximum</h2>
<blockquote>
<p>求长度k滑动窗口每个时刻最大值</p>
</blockquote>
<p>维护双端队列，存储索引，之所以存索引是方便判断是否在窗口内<br>
双端队列内下标对应的值时刻保持递减，弹出一个，最大的就在头部<br>
当前值进入窗口</p>
<ul>
<li>将队列头部已经不在窗口的值移除</li>
<li>如果比队列末尾指向的数字小，那么直接进入队列，之所以进入是为了防止前面最大值失效，失效后可以顶上</li>
<li>如果比队列末尾指向的数字大，说明之前队列维护的更小值没用了，从末尾弹出后当前再进入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> resLen = k == <span class="number">0</span> ? <span class="number">0</span> : nums.length-k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[resLen];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> startIndex = i - k + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//一次滑动一格，最多过期一个，无需while</span></span><br><span class="line">            <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; queue.peekFirst() &lt; startIndex) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> curr = nums[i];</span><br><span class="line">            <span class="comment">//remove prev less</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; curr) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            <span class="keyword">if</span>(startIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res[startIndex] = nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀567-permutation-in-string">❀567. Permutation in String</h2>
<blockquote>
<p>判断s2是否有一个子串是s1的排列</p>
</blockquote>
<p>定长滑动窗口，判断s2中长为s1的窗口，是否字符计数上同s1一致<br>
为了避免每次判断遍历整个窗口区间，维护一个匹配度指标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建s1基准计数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line">            cnt.put(c, cnt.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标是每种字母都计数相等</span></span><br><span class="line">        <span class="keyword">int</span> matchedCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(i);</span><br><span class="line">            <span class="comment">//窗口加入新字母，只统计s1中出现过的，由于定长限制，出现非s1字母将导致无法和s1匹配，即不影响匹配度</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(c)) &#123;</span><br><span class="line">                cnt.put(c, cnt.get(c) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    matchedCnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//达到窗口长度，每次需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= s1.length()) &#123;</span><br><span class="line">                c = s2.charAt(i - s1.length());</span><br><span class="line">                <span class="keyword">if</span> (cnt.containsKey(c)) &#123;</span><br><span class="line">                    <span class="comment">//破坏了原来满足的字母</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        matchedCnt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt.put(c, cnt.get(c) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matchedCnt == cnt.keySet().size()) &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀209-minimum-size-subarray-sum">❀209. Minimum Size Subarray Sum</h2>
<blockquote>
<p>正数数组，求大于等于某个和值的子数组最小长度</p>
</blockquote>
<p>正数数组和值递增，可以滑动窗口，超过则舍弃前面，O(n)<br>
建立前序和，因为正数数组因此前序和递增，可以循环二分搜索O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s) &#123;</span><br><span class="line">                min = Math.min(min, j-i+<span class="number">1</span>);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀395-longest-substring-with-at-least-k-repeating-characters">❀395. Longest Substring with At Least K Repeating Characters</h2>
<blockquote>
<p>最长序列长度，满足序列内每个字母最少出现k次</p>
</blockquote>
<p>滑动窗口，每次判定含有不同字母数的最长序列，最多26个，所以还是O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h &lt;= <span class="number">26</span>; h++) &#123;</span><br><span class="line">            max = Math.max(max, longestSubstring(s,k,h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n个不同字母，每个出现k次</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, unique = <span class="number">0</span>, noLessThanK = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unique &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = s.charAt(j) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                    unique++;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[idx]++;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == k) &#123;</span><br><span class="line">                    noLessThanK++;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == k) &#123;</span><br><span class="line">                    noLessThanK--;</span><br><span class="line">                &#125;</span><br><span class="line">                counts[idx]--;</span><br><span class="line">                <span class="keyword">if</span> (counts[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                    unique--;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (unique == n &amp;&amp; unique == noLessThanK) &#123;</span><br><span class="line">                max = Math.max(j - i, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀3-longest-substring-without-repeating-characters">❀3. Longest Substring Without Repeating Characters</h2>
<blockquote>
<p>无重复的最长连续子串的长度</p>
</blockquote>
<p>滑动窗口，使用set判定是否重复，set中就是正在统计的子串，set大小可直接作为当前长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">            <span class="keyword">while</span> (set.contains(c))&#123;</span><br><span class="line">                <span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">                set.remove(head);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">            len = Math.max(len, end-start+<span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以维护map，记录每个字母最后一次出现的位置，这样滑动时可以直接跳跃</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">//map不清除，包含不一定代表窗口内重复</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                start = Math.max(start, map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, i);</span><br><span class="line">            max = Math.max(max, i-start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀159-longest-substring-with-at-most-two-distinct-characters">❀159 Longest Substring with At Most Two Distinct Characters</h2>
<blockquote>
<p>最多只包含两种字母的最长子串长度</p>
</blockquote>
<p>滑动窗口，计数，超过两种字符就收缩，相当于对于每个起点，找尽可能长的串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(end);</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//收缩</span></span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, end - start + <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="904-fruit-into-baskets">904. Fruit Into Baskets</h2>
<blockquote>
<p>每颗树不同类型水果，两个篮子能放两种水果，从任意树出发，向右走求最多收集多少水果</p>
</blockquote>
<p>不超过2的最长子数组长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tree.length;</span><br><span class="line">        <span class="keyword">if</span> (tree.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = tree[end];</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> head = tree[start];</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, end - start + <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="340-longest-substring-with-at-most-k-distinct-characters">340. Longest Substring with At Most K Distinct Characters</h2>
<blockquote>
<p>最多只包含K种字母的最长子串长度</p>
</blockquote>
<p>滑动窗口，计数，超过K种字符就收缩</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(end);</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            len = Math.max(len, end - start + <span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀992-subarrays-with-k-different-integers">❀992. Subarrays with K Different Integers</h2>
<blockquote>
<p>求精确包含K个不同数字的子数组个数</p>
</blockquote>
<p>转变为至多包含K个数字的子数组个数与至多K-1个数字的子数组个数之差<br>
至多包含K个数字子数组可以用滑动窗口计算，每次找到起点start能都延伸的最大长度end, 那么end在此区间内任何位置都能满足</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfAtMostKDistinct(A,K) - numOfAtMostKDistinct(A,K-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfAtMostKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; A.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A[end];</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">int</span> head = A[start];</span><br><span class="line">                map.put(head, map.get(head) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(head) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(head);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += end -start + <span class="number">1</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序">排序</h1>
<hr>
<h2 id="❀912-sort-an-array">❀912. Sort an Array</h2>
<blockquote>
<p>实现数组排序</p>
</blockquote>
<p>快速排序，划分, 时间复杂度O(nlogn),不稳定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, s, e);</span><br><span class="line">        quickSort(nums, s, p-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums, p+<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回位置已放正确，左侧小，右边大于等于</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择支点，这里简单的选取最后一个</span></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[e];</span><br><span class="line">        <span class="keyword">int</span> i = s, j = e;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换支点</span></span><br><span class="line">        swap(nums, i, e);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序，二分合并，时间复杂度O(nlogn),空间复杂度O(n),稳定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (s + e)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, s, mid);</span><br><span class="line">        mergeSort(nums, mid+<span class="number">1</span>, e);</span><br><span class="line">        merge(nums, s, mid, mid+<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个相邻数组，各自有序，合并成整体有序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s1, <span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[e1-s1+<span class="number">1</span> + e2-s2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = s1, j = s2, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= e1 &amp;&amp; j &lt;= e2) &#123;</span><br><span class="line">            tmp[index++] = (nums[i] &lt; nums[j]) ? nums[i++] : nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= e1) &#123;</span><br><span class="line">            tmp[index++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= e2) &#123;</span><br><span class="line">            tmp[index++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tmp.length; k++) &#123;</span><br><span class="line">            nums[s1+k] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序,时间复杂度O(n2),不稳定<br>
每次选一个后续最小的，作为当前排序值，即不断的寻找最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        selectionSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序,时间复杂度O(n2),稳定<br>
每轮从头开始，把大值推到末尾，进行n-1轮即可，外层循环轮次控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        bubbleSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序,时间复杂度O(n2),稳定<br>
前面有序，每次把当前元素尝试往前面交换，直到送到正确位置<br>
外围循环控制当前要排的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        insertionSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀75-sort-colors">❀75. Sort Colors</h2>
<blockquote>
<p>三种数字012排序</p>
</blockquote>
<p>基于覆写，计数排序，第一次计数，第二次写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            cnt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">                cnt[<span class="number">0</span>]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">                cnt[<span class="number">1</span>]--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于交换，一次遍历，基于三指针交换双向增长，左指向已有0的下一位，右指向已有2的前一位，当前指针遍历，尝试两侧向中心生长<br>
由于从左边起换，前面序列只能是<code>0*1*</code>，换左边只能换出0或者1，而遇到2可能右边换到的也是2，不能跳过需要从新判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] == <span class="number">2</span>) &#123;</span><br><span class="line">                nums[idx] = nums[j];</span><br><span class="line">                nums[j] = <span class="number">2</span>;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[idx] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀179-largest-number">❀179. Largest Number</h2>
<blockquote>
<p>给一组非负数，求能组成的最大数字</p>
</blockquote>
<ul>
<li>按字符排序，注意不是字符序大的一定在前，比如&quot;3&quot;和&quot;32&quot;,“32&quot;大于&quot;3&quot;但是&quot;323&quot;小于&quot;332”，因此要按组合排序</li>
<li>整数数组不能直接排序，因为基本类型无泛型，需要先转字符串数组</li>
<li>全0情况，要去掉前面的0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span>) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		String[] strNum = <span class="keyword">new</span> String[num.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">		    strNum[i] = String.valueOf(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照拼接组合，从大到小排序</span></span><br><span class="line">		Arrays.sort(strNum, (a,b) -&gt; (b+a).compareTo(a+b));</span><br><span class="line">        <span class="keyword">if</span>(strNum[<span class="number">0</span>].charAt(<span class="number">0</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(String s: strNum) &#123;</span><br><span class="line">	        sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀506-relative-ranks">❀506. Relative Ranks</h2>
<blockquote>
<p>输出每个数字的顺位</p>
</blockquote>
<p>排序后数组位置变动，会丢失原始顺序，因此记录下来原始位置<br>
原生类型无法直接降序排列，注意变通为逆向遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRelativeRanks(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        String[] res = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index =  map.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == n-<span class="number">1</span>)&#123;</span><br><span class="line">                res[index] = <span class="string">"Gold Medal"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">2</span>)&#123;</span><br><span class="line">                res[index] = <span class="string">"Silver Medal"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">3</span>) &#123;</span><br><span class="line">                res[index] = <span class="string">"Bronze Medal"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index] = String.valueOf(n-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1029-two-city-scheduling">❀1029. Two City Scheduling</h2>
<blockquote>
<p>有2N个人，到两地的开销存为数组，每地分N个人，求最小开销</p>
</blockquote>
<p>不考虑平均分，那么两地那个开销小就去哪个<br>
如果其中一地人多，那么势必要剔除掉，原则是选增加开销小的，即差值小<br>
所有人按照AB地差值升序排序，排在前面是负值即A比B开销小，那么前一半适合去A和后一半适合去B</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(costs, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (a[<span class="number">0</span>] - a[<span class="number">1</span>]) - (b[<span class="number">0</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; ++i) &#123;</span><br><span class="line">            sum += (i &lt; costs.length / <span class="number">2</span>) ? costs[i][<span class="number">0</span>] : costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-maximize-sum-of-array-after-k-negations">1005. Maximize Sum Of Array After K Negations</h2>
<blockquote>
<p>一个数组，经过K次对单个元素取负数操作，能达到的最大和值</p>
</blockquote>
<p>如果有负数，那么负数变成正数，对和有贡献，优先绝对值大的负数<br>
如果有0，可以消耗掉任意次数的取负操作<br>
如果正数，可以消耗偶数次操作，如果奇数那么变成操作1次，和绝对值最近负数权衡<br>
排序，实现上述策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span> &amp;&amp; K &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sum += -A[i];</span><br><span class="line">                K--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//全部抵消剩余次数</span></span><br><span class="line">                K = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span> &amp;&amp; K % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//剩余奇数次，势必要有一个变负数</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                    sum += -A[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sum += (A[i] + A[i-<span class="number">1</span>] &lt; <span class="number">0</span>) ?  -A[i] : A[i] + <span class="number">2</span>*A[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                K = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀1122-relative-sort-array">❀1122. Relative Sort Array</h2>
<blockquote>
<p>数组2包含部分不重复数据，将数组1按照数组2排序，数组2内不存在的升序排在后面</p>
</blockquote>
<p>桶排序，先统计数组1内各个数字出现次数，按照数组2顺序写入，最后写入不存在的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">            buckets[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr2) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr1[idx++] = i;</span><br><span class="line">                buckets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr1[idx++] = i;</span><br><span class="line">                buckets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1051-height-checker">1051. Height Checker</h2>
<blockquote>
<p>调整成非降序，求有多少个数据在错误位置</p>
</blockquote>
<p>复制一份数组排列好，对比两数组几个位置不同，O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = Arrays.copyOf(heights, heights.length);</span><br><span class="line">        Arrays.sort(tmp);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] != heights[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者桶排序O(n)，判断每个位置应该排什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : heights) &#123;</span><br><span class="line">            buckets[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[idx] != i) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                buckets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1200-minimum-absolute-difference">1200. Minimum Absolute Difference</h2>
<blockquote>
<p>求相差的绝对值最小的所有数对</p>
</blockquote>
<p>先排序，绝对值最小数对只限于相邻</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> minAbs = Integer.MAX_VALUE;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> abs = arr[i] - arr[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(abs == minAbs) &#123;</span><br><span class="line">                result.add(Arrays.asList(arr[i-<span class="number">1</span>],arr[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(abs &lt; minAbs) &#123;</span><br><span class="line">                result.clear();</span><br><span class="line">                minAbs = abs;</span><br><span class="line">                result.add(Arrays.asList(arr[i-<span class="number">1</span>],arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀455-assign-cookies">❀455. Assign Cookies</h2>
<blockquote>
<p>s表示供给饼干数量，g表示需求数量，求能构成数组s数字大于等于数组g数字的最多数对</p>
</blockquote>
<p>两个数组排序，针对每个g，挑选s。因为如果当前s不能满足当前g，那么后面g更大必然不满足，s舍弃</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; g.length &amp;&amp; j &lt; s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &gt;= g[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子序列">子序列</h1>
<hr>
<p>子序列不要求连续，仅保持元素间相对顺序</p>
<h2 id="594-longest-harmonious-subsequence">594. Longest Harmonious Subsequence</h2>
<blockquote>
<p>求最长子序列，序列内最大最小值差为1</p>
</blockquote>
<p>建map统计次数，查找相邻，次数和就是子序列长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map &lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key + <span class="number">1</span>)) &#123;</span><br><span class="line">                res = Math.max(res, map.get(key) + map.get(key + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀128-longest-consecutive-sequence">❀128. Longest Consecutive Sequence</h2>
<blockquote>
<p>无序数组，能够成的连续数字子序列长度</p>
</blockquote>
<p>双哈希，同时记录起点和终点双向映射<br>
每次遍历到新数字，判断是否可以把已有连续区间连接起来<br>
遇到数字位于已有区间内，不影响，因为不会影响外边界，最终哈希表内可能出现区间套区间的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//起始元素，终止元素</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; startMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; endMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(startMap.containsKey(i) || endMap.containsKey(i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> next = i+<span class="number">1</span>, prev = i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newStart = i, newEnd = i;</span><br><span class="line">            <span class="keyword">if</span>(startMap.containsKey(next) &amp;&amp; endMap.containsKey(prev)) &#123;</span><br><span class="line">                newStart = endMap.get(prev);</span><br><span class="line">                newEnd = startMap.get(next);</span><br><span class="line">                startMap.remove(next);</span><br><span class="line">                endMap.remove(prev);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(startMap.containsKey(next)) &#123;</span><br><span class="line">                newEnd = startMap.get(next);</span><br><span class="line">                startMap.remove(next);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(endMap.containsKey(prev)) &#123;</span><br><span class="line">                newStart = endMap.get(prev);</span><br><span class="line">                endMap.remove(prev);</span><br><span class="line">            &#125;</span><br><span class="line">            startMap.put(newStart, newEnd);</span><br><span class="line">            endMap.put(newEnd, newStart);</span><br><span class="line">            result = Math.max(result, newEnd-newStart+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单哈希版本，区间(5,6,7)同时记起始结束点和长度(5,3),(7,3)<br>
因为数据不删除，包含去重逻辑，所以6不会再处理，边界5和7只能通过4和8左右单侧连接，长度不会造成混淆，可以利用长度反推已有区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 起始元素或者终止元素，长度</span></span><br><span class="line">	Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : num) &#123;</span><br><span class="line">		<span class="comment">// 去重</span></span><br><span class="line">		<span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 每个数字都添加进去，用于去重</span></span><br><span class="line">		map.put(i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> prev = i - <span class="number">1</span>, next = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> end = i, begin = i;</span><br><span class="line">		<span class="keyword">if</span> (map.containsKey(next)) &#123;</span><br><span class="line">			end = i + map.get(next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (map.containsKey(prev)) &#123;</span><br><span class="line">			begin = i - map.get(prev);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> newLen = end - begin + <span class="number">1</span>;</span><br><span class="line">		map.put(end, newLen);</span><br><span class="line">		map.put(begin, newLen);</span><br><span class="line">		result = Math.max(result, newLen);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="时间序列">时间序列</h1>
<hr>
<h2 id="❀121-best-time-to-buy-and-sell-stock">❀121. Best Time to Buy and Sell Stock</h2>
<blockquote>
<p>给定价格序列，进行一次买卖，求最大收益，即求子序列中最大差值</p>
</blockquote>
<p>全局最小和全局最大不适合，因为时间限制无法保证最小在最大之前出现<br>
假想每个时间都是卖点，那么最大收益是和目前的最小值的差值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minSofar = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minSofar) &#123;</span><br><span class="line">                minSofar = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                profit = Math.max(profit, prices[i]-minSofar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种思路，以手中持有金钱为考量，买入相当于负数，买入越低，负数越大<br>
只进行一次交易，买入基准始终是0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> buy = Integer.MIN_VALUE, sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            <span class="comment">//每一点尝试卖出都基于先前的买入</span></span><br><span class="line">            sell = Math.max(sell, p + buy);</span><br><span class="line">            buy = Math.max(buy, <span class="number">0</span>-p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀122-best-time-to-buy-and-sell-stock-ii">❀122. Best Time to Buy and Sell Stock II</h2>
<blockquote>
<p>给定价格序列，进行多次买卖，求最大收益</p>
</blockquote>
<p>贪心算法，最大收益即所有上升区间都进行一次交易<br>
最低到最高差值可以拆解成区间内相邻差值的和，因此只考虑相邻数字即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                profit += (prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种思路，买入基于前面卖出<br>
多次操作，每次买入基准是上次卖出值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> buy = Integer.MIN_VALUE, sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            <span class="comment">//基于前次买入，能获得的最大收益，发生替换可以理解为本次执行卖出</span></span><br><span class="line">            sell = Math.max(sell, p + buy);</span><br><span class="line">            <span class="comment">//发生替换可以理解如果没卖出前面买入不算换更低价格买；已卖出则理解为再次买进</span></span><br><span class="line">            buy = Math.max(buy, sell - p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀123-best-time-to-buy-and-sell-stock-iii">❀123. Best Time to Buy and Sell Stock III</h2>
<blockquote>
<p>最多只能买卖两次，并且不能重叠</p>
</blockquote>
<p>依赖顺序，第二次卖-&gt;第二次买-&gt;第一次卖-&gt;第一次买</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oneBuy = Integer.MIN_VALUE, oneBuyOneSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> twoBuy = Integer.MIN_VALUE, twoBuyTwoSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            twoBuyTwoSell = Math.max(twoBuyTwoSell, p + twoBuy);</span><br><span class="line">            <span class="comment">//在第一次交易的基础上买入</span></span><br><span class="line">            twoBuy = Math.max(twoBuy, oneBuyOneSell - p);</span><br><span class="line">            <span class="comment">//目前为止第一次交易能达到的最大值</span></span><br><span class="line">            oneBuyOneSell = Math.max(oneBuyOneSell, p + oneBuy);</span><br><span class="line">            oneBuy = Math.max(oneBuy, -p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(oneBuyOneSell, twoBuyTwoSell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间">区间</h1>
<hr>
<h2 id="❀56-merge-intervals">❀56. Merge Intervals</h2>
<blockquote>
<p>区间合并</p>
</blockquote>
<p>按照起始位置排序，遍历判断是否重叠合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">		<span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按起点排序</span></span><br><span class="line">		Arrays.sort(intervals, (i1, i2) -&gt; Integer.compare(i1[<span class="number">0</span>], i2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">		List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span>[] prev = intervals[<span class="number">0</span>];</span><br><span class="line">		result.add(prev);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] curr : intervals) &#123;</span><br><span class="line">			<span class="comment">//当前起点小于上一个终点，重合</span></span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">0</span>] &lt;= prev[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//取最长的终点</span></span><br><span class="line">				prev[<span class="number">1</span>] = Math.max(prev[<span class="number">1</span>], curr[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不重合，新开一个区间</span></span><br><span class="line">				prev = curr;</span><br><span class="line">				result.add(prev);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀435-non-overlapping-intervals">❀435. Non-overlapping Intervals</h2>
<blockquote>
<p>给一组区间，求最少删除数能使得无重叠</p>
</blockquote>
<p>转变求最大可安排的不重叠区间数<br>
贪心，按照结束时间升序，如果两个区间重叠，那么选结束时间早的，因为同样是一个区间，结束早就给后面留出更大空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照结束时间升序</span></span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(i -&gt; i[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, lastend = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] in : intervals) &#123;</span><br><span class="line">            <span class="comment">//起点比最后终点大，无重叠</span></span><br><span class="line">            <span class="keyword">if</span> (in[<span class="number">0</span>] &gt;= lastend) &#123;</span><br><span class="line">                lastend = in[<span class="number">1</span>];</span><br><span class="line">                max++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顺序模拟">顺序模拟</h1>
<hr>
<h2 id="717-1-bit-and-2-bit-characters">717. 1-bit and 2-bit Characters</h2>
<blockquote>
<p>一串01序列最后为0，解析方式有10,11或者单个0,判断最后0是否单个解析</p>
</blockquote>
<p>从头开始解析，只要遇见1肯定控制下一位走两步，遇到0走一步，那么记录最后是哪一种即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; bits.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bits[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                step = <span class="number">2</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="806-number-of-lines-to-write-string">806. Number of Lines To Write String</h2>
<blockquote>
<p>每个字母长度不等，每行长度最多100，求字符串占几行以及最后一行多长</p>
</blockquote>
<p>注意写不下换行，每行不一定占满</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numberOfLines(<span class="keyword">int</span>[] widths, String S) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>, line = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = widths[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(length + w &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                length = length + w;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                length = w;</span><br><span class="line">                line++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123; line, length &#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="657-robot-return-to-origin">657. Robot Return to Origin</h2>
<blockquote>
<p>上下左右操作后，判断是否回原点</p>
</blockquote>
<p>水平垂直变量计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeCircle</span><span class="params">(String moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vertical = <span class="number">0</span>, horizontal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : moves.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'U'</span>) &#123;</span><br><span class="line">                vertical++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'D'</span>) &#123;</span><br><span class="line">                vertical--; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                horizontal--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'R'</span>) &#123;</span><br><span class="line">                horizontal++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vertical == <span class="number">0</span> &amp;&amp; horizontal == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他">其他</h1>
<hr>
<h2 id="❀11-container-with-most-water">❀11. Container With Most Water</h2>
<blockquote>
<p>不同高度板子，任选两个连同底部作为容器，求能装最大水量</p>
</blockquote>
<p>水高度被较低的板子制约<br>
最左边板子L,最右边R,此时底部最长，为了寻找更大水量，只能缩短底部，即移动隔板<br>
左边L比较低并且固定，那么不管右边怎么移，即使再高的板子也受制于左边，即宽度减少但是高度不会增加，总量也不会增加，因此移动左边L才能可能寻求更大总量，即策略是哪个低移动哪个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> amount = (j-i) * Math.min(height[i], height[j]);</span><br><span class="line">            result = Math.max(result, amount);</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="❀42-trapping-rain-water">❀42. Trapping Rain Water</h2>
<blockquote>
<p>给出不同高度，求能容纳水量</p>
</blockquote>
<p>水高度被较低的一侧制约<br>
左右双端移动，同时记录两侧最大值<br>
那边低就移动那边，单个位置容纳水量为低侧最高高度与当前地形高度置差</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[i]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[j]);</span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt; rightMax) &#123;</span><br><span class="line">                result += leftMax - height[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result += rightMax - height[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
    <div class="donate_module">
        <div id="donate_board" class="donate_bar">
            <br>
            <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
        </div>
        <div id="donate_guide" class="donate_bar hidden">
            <br>
            <a href="/assets/reward/wechat_code.jpg"  class="fancybox">
                <img src="/assets/reward/wechat_code.jpg" title="微信打赏" height="190px" width="auto"/>
            </a>
            <span class="donate_space"></span>
            <a href="/assets/reward/alipay_code.jpg"  class="fancybox">
                <img src="/assets/reward/alipay_code.jpg" title="支付宝打赏" height="190px" width="auto"/>
            </a>
        </div>
        <span class="donate_txt">一分也是爱~</span> 
    </div>

        <div class="breakword">
    <hr>
    <p><strong>版权声明</strong></p>
    <p><img src="/assets/copyright/cc.png" alt=""></p>
    <p><a href="http://linest.github.io/leetcode/leetcode-array.html">This site</a> by <a href="mailto:xlinest@gmail.com">Linest</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.
    <br>由<a href="mailto:xlinest@gmail.com">Linest</a>创作并维护的博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
    <p>本文永久链接：<a href="http://linest.github.io/leetcode/leetcode-array.html">http://linest.github.io/leetcode/leetcode-array.html</a></p>
</div>
      
    </div>
    
  </div>
  
    
  
</article>
<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关注点"><span class="toc-number">1.1.</span> <span class="toc-text">关注点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作"><span class="toc-number">1.2.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧"><span class="toc-number">1.3.</span> <span class="toc-text">技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单调性"><span class="toc-number">2.</span> <span class="toc-text">单调性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀896-monotonic-array"><span class="toc-number">2.1.</span> <span class="toc-text">❀896. Monotonic Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#941-valid-mountain-array"><span class="toc-number">2.2.</span> <span class="toc-text">941. Valid Mountain Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀665-non-decreasing-array"><span class="toc-number">2.3.</span> <span class="toc-text">❀665. Non-decreasing Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀581-shortest-unsorted-continuous-subarray"><span class="toc-number">2.4.</span> <span class="toc-text">❀581. Shortest Unsorted Continuous Subarray</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#外建哈希"><span class="toc-number">3.</span> <span class="toc-text">外建哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#217-contains-duplicate"><span class="toc-number">3.1.</span> <span class="toc-text">217. Contains Duplicate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#219-contains-duplicate-ii"><span class="toc-number">3.2.</span> <span class="toc-text">219. Contains Duplicate II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#349-intersection-of-two-arrays"><span class="toc-number">3.3.</span> <span class="toc-text">349. Intersection of Two Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#350-intersection-of-two-arrays-ii"><span class="toc-number">3.4.</span> <span class="toc-text">350. Intersection of Two Arrays II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1207-unique-number-of-occurrences"><span class="toc-number">3.5.</span> <span class="toc-text">1207. Unique Number of Occurrences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#697-degree-of-an-array"><span class="toc-number">3.6.</span> <span class="toc-text">697. Degree of an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#760-find-anagram-mappings"><span class="toc-number">3.7.</span> <span class="toc-text">760. Find Anagram Mappings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#599-minimum-index-sum-of-two-lists"><span class="toc-number">3.8.</span> <span class="toc-text">599. Minimum Index Sum of Two Lists</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自身哈希"><span class="toc-number">4.</span> <span class="toc-text">自身哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀448-find-all-numbers-disappeared-in-an-array"><span class="toc-number">4.1.</span> <span class="toc-text">❀448. Find All Numbers Disappeared in an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀645-set-mismatch"><span class="toc-number">4.2.</span> <span class="toc-text">❀645. Set Mismatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀41-first-missing-positive"><span class="toc-number">4.3.</span> <span class="toc-text">❀41. First Missing Positive</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连续分段"><span class="toc-number">5.</span> <span class="toc-text">连续分段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#485-max-consecutive-ones"><span class="toc-number">5.1.</span> <span class="toc-text">485. Max Consecutive Ones</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#551-student-attendance-record-i"><span class="toc-number">5.2.</span> <span class="toc-text">551. Student Attendance Record I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#830-positions-of-large-groups"><span class="toc-number">5.3.</span> <span class="toc-text">830. Positions of Large Groups</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#696-count-binary-substrings"><span class="toc-number">5.4.</span> <span class="toc-text">696. Count Binary Substrings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#674-longest-continuous-increasing-subsequence"><span class="toc-number">5.5.</span> <span class="toc-text">674. Longest Continuous Increasing Subsequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀443-string-compression"><span class="toc-number">5.6.</span> <span class="toc-text">❀443. String Compression</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀849-maximize-distance-to-closest-person"><span class="toc-number">5.7.</span> <span class="toc-text">❀849. Maximize Distance to Closest Person</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#605-can-place-flowers"><span class="toc-number">5.8.</span> <span class="toc-text">605. Can Place Flowers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#投票"><span class="toc-number">6.</span> <span class="toc-text">投票</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀169-majority-element"><span class="toc-number">6.1.</span> <span class="toc-text">❀169. Majority Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀229-majority-element-ii"><span class="toc-number">6.2.</span> <span class="toc-text">❀229. Majority Element II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀961-n-repeated-element-in-size-2n-array"><span class="toc-number">6.3.</span> <span class="toc-text">❀961. N-Repeated Element in Size 2N Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最值"><span class="toc-number">7.</span> <span class="toc-text">最值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#747-largest-number-at-least-twice-of-others"><span class="toc-number">7.1.</span> <span class="toc-text">747. Largest Number At Least Twice of Others</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀414-third-maximum-number"><span class="toc-number">7.2.</span> <span class="toc-text">❀414. Third Maximum Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#628-maximum-product-of-three-numbers"><span class="toc-number">7.3.</span> <span class="toc-text">628. Maximum Product of Three Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀215-kth-largest-element-in-an-array"><span class="toc-number">7.4.</span> <span class="toc-text">❀215. Kth Largest Element in an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#908-smallest-range-i"><span class="toc-number">7.5.</span> <span class="toc-text">908. Smallest Range I</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#距离"><span class="toc-number">8.</span> <span class="toc-text">距离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀243-shortest-word-distance"><span class="toc-number">8.1.</span> <span class="toc-text">❀243. Shortest Word Distance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#244-shortest-word-distance-ii"><span class="toc-number">8.2.</span> <span class="toc-text">244. Shortest Word Distance II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀245-shortest-word-distance-iii"><span class="toc-number">8.3.</span> <span class="toc-text">❀245. Shortest Word Distance III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀821-shortest-distance-to-a-character"><span class="toc-number">8.4.</span> <span class="toc-text">❀821. Shortest Distance to a Character</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#首尾"><span class="toc-number">9.</span> <span class="toc-text">首尾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#977-squares-of-a-sorted-array"><span class="toc-number">9.1.</span> <span class="toc-text">977. Squares of a Sorted Array</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原地交换移位"><span class="toc-number">10.</span> <span class="toc-text">原地交换移位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀189-rotate-array"><span class="toc-number">10.1.</span> <span class="toc-text">❀189. Rotate Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀905-sort-array-by-parity"><span class="toc-number">10.2.</span> <span class="toc-text">❀905. Sort Array By Parity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀922-sort-array-by-parity-ii"><span class="toc-number">10.3.</span> <span class="toc-text">❀922. Sort Array By Parity II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原地覆写"><span class="toc-number">11.</span> <span class="toc-text">原地覆写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀88-merge-sorted-array"><span class="toc-number">11.1.</span> <span class="toc-text">❀88. Merge Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀27-remove-element"><span class="toc-number">11.2.</span> <span class="toc-text">❀27. Remove Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀26-remove-duplicates-from-sorted-array"><span class="toc-number">11.3.</span> <span class="toc-text">❀26. Remove Duplicates from Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀80-remove-duplicates-from-sorted-array-ii"><span class="toc-number">11.4.</span> <span class="toc-text">❀80. Remove Duplicates from Sorted Array II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀283-move-zeroes"><span class="toc-number">11.5.</span> <span class="toc-text">❀283. Move Zeroes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1089-duplicate-zeros"><span class="toc-number">11.6.</span> <span class="toc-text">❀1089. Duplicate Zeros</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈辅助"><span class="toc-number">12.</span> <span class="toc-text">栈辅助</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀496-next-greater-element-i"><span class="toc-number">12.1.</span> <span class="toc-text">❀496. Next Greater Element I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1047-remove-all-adjacent-duplicates-in-string"><span class="toc-number">12.2.</span> <span class="toc-text">1047. Remove All Adjacent Duplicates In String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀946-validate-stack-sequences"><span class="toc-number">12.3.</span> <span class="toc-text">❀946. Validate Stack Sequences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀84-largest-rectangle-in-histogram"><span class="toc-number">12.4.</span> <span class="toc-text">❀84. Largest Rectangle in Histogram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀32-longest-valid-parentheses"><span class="toc-number">12.5.</span> <span class="toc-text">❀32. Longest Valid Parentheses</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优先队列"><span class="toc-number">13.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1046-last-stone-weight"><span class="toc-number">13.1.</span> <span class="toc-text">1046. Last Stone Weight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀373-find-k-pairs-with-smallest-sums"><span class="toc-number">13.2.</span> <span class="toc-text">❀373. Find K Pairs with Smallest Sums</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二分搜索"><span class="toc-number">14.</span> <span class="toc-text">二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀704-binary-search"><span class="toc-number">14.1.</span> <span class="toc-text">❀704. Binary Search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀34-find-first-and-last-position-of-element-in-sorted-array"><span class="toc-number">14.2.</span> <span class="toc-text">❀34. Find First and Last Position of Element in Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#278-first-bad-version"><span class="toc-number">14.3.</span> <span class="toc-text">278. First Bad Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#744-find-smallest-letter-greater-than-target"><span class="toc-number">14.4.</span> <span class="toc-text">744. Find Smallest Letter Greater Than Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀35-search-insert-position"><span class="toc-number">14.5.</span> <span class="toc-text">❀35. Search Insert Position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀162-find-peak-element"><span class="toc-number">14.6.</span> <span class="toc-text">❀162. Find Peak Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#852-peak-index-in-a-mountain-array"><span class="toc-number">14.7.</span> <span class="toc-text">852. Peak Index in a Mountain Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀540-single-element-in-a-sorted-array"><span class="toc-number">14.8.</span> <span class="toc-text">❀540. Single Element in a Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀33-search-in-rotated-sorted-array"><span class="toc-number">14.9.</span> <span class="toc-text">❀33. Search in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀153-find-minimum-in-rotated-sorted-array"><span class="toc-number">14.10.</span> <span class="toc-text">❀153. Find Minimum in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀154-find-minimum-in-rotated-sorted-array-ii"><span class="toc-number">14.11.</span> <span class="toc-text">❀154. Find Minimum in Rotated Sorted Array II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#和值"><span class="toc-number">15.</span> <span class="toc-text">和值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1-two-sum"><span class="toc-number">15.1.</span> <span class="toc-text">❀1. Two Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀167-two-sum-ii-input-array-is-sorted"><span class="toc-number">15.2.</span> <span class="toc-text">❀167. Two Sum II - Input array is sorted</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1010-pairs-of-songs-with-total-durations-divisible-by-60"><span class="toc-number">15.3.</span> <span class="toc-text">1010. Pairs of Songs With Total Durations Divisible by 60</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#454-4sum-ii"><span class="toc-number">15.4.</span> <span class="toc-text">454. 4Sum II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀548-split-array-with-equal-sum"><span class="toc-number">15.5.</span> <span class="toc-text">❀548. Split Array with Equal Sum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#差分"><span class="toc-number">16.</span> <span class="toc-text">差分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#888-fair-candy-swap"><span class="toc-number">16.1.</span> <span class="toc-text">888. Fair Candy Swap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀724-find-pivot-index"><span class="toc-number">16.2.</span> <span class="toc-text">❀724. Find Pivot Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1013-partition-array-into-three-parts-with-equal-sum"><span class="toc-number">16.3.</span> <span class="toc-text">1013. Partition Array Into Three Parts With Equal Sum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区间和"><span class="toc-number">17.</span> <span class="toc-text">区间和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀303-range-sum-query-immutable"><span class="toc-number">17.1.</span> <span class="toc-text">❀303. Range Sum Query - Immutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀560-subarray-sum-equals-k"><span class="toc-number">17.2.</span> <span class="toc-text">❀560. Subarray Sum Equals K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀325-maximum-size-subarray-sum-equals-k"><span class="toc-number">17.3.</span> <span class="toc-text">❀325. Maximum Size Subarray Sum Equals k</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#滑动窗口"><span class="toc-number">18.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#643-maximum-average-subarray-i"><span class="toc-number">18.1.</span> <span class="toc-text">643. Maximum Average Subarray I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀239-sliding-window-maximum"><span class="toc-number">18.2.</span> <span class="toc-text">❀239. Sliding Window Maximum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀567-permutation-in-string"><span class="toc-number">18.3.</span> <span class="toc-text">❀567. Permutation in String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀209-minimum-size-subarray-sum"><span class="toc-number">18.4.</span> <span class="toc-text">❀209. Minimum Size Subarray Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀395-longest-substring-with-at-least-k-repeating-characters"><span class="toc-number">18.5.</span> <span class="toc-text">❀395. Longest Substring with At Least K Repeating Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀3-longest-substring-without-repeating-characters"><span class="toc-number">18.6.</span> <span class="toc-text">❀3. Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀159-longest-substring-with-at-most-two-distinct-characters"><span class="toc-number">18.7.</span> <span class="toc-text">❀159 Longest Substring with At Most Two Distinct Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#904-fruit-into-baskets"><span class="toc-number">18.8.</span> <span class="toc-text">904. Fruit Into Baskets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#340-longest-substring-with-at-most-k-distinct-characters"><span class="toc-number">18.9.</span> <span class="toc-text">340. Longest Substring with At Most K Distinct Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀992-subarrays-with-k-different-integers"><span class="toc-number">18.10.</span> <span class="toc-text">❀992. Subarrays with K Different Integers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">19.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀912-sort-an-array"><span class="toc-number">19.1.</span> <span class="toc-text">❀912. Sort an Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀75-sort-colors"><span class="toc-number">19.2.</span> <span class="toc-text">❀75. Sort Colors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀179-largest-number"><span class="toc-number">19.3.</span> <span class="toc-text">❀179. Largest Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀506-relative-ranks"><span class="toc-number">19.4.</span> <span class="toc-text">❀506. Relative Ranks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1029-two-city-scheduling"><span class="toc-number">19.5.</span> <span class="toc-text">❀1029. Two City Scheduling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1005-maximize-sum-of-array-after-k-negations"><span class="toc-number">19.6.</span> <span class="toc-text">1005. Maximize Sum Of Array After K Negations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀1122-relative-sort-array"><span class="toc-number">19.7.</span> <span class="toc-text">❀1122. Relative Sort Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1051-height-checker"><span class="toc-number">19.8.</span> <span class="toc-text">1051. Height Checker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1200-minimum-absolute-difference"><span class="toc-number">19.9.</span> <span class="toc-text">1200. Minimum Absolute Difference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀455-assign-cookies"><span class="toc-number">19.10.</span> <span class="toc-text">❀455. Assign Cookies</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子序列"><span class="toc-number">20.</span> <span class="toc-text">子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#594-longest-harmonious-subsequence"><span class="toc-number">20.1.</span> <span class="toc-text">594. Longest Harmonious Subsequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀128-longest-consecutive-sequence"><span class="toc-number">20.2.</span> <span class="toc-text">❀128. Longest Consecutive Sequence</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#时间序列"><span class="toc-number">21.</span> <span class="toc-text">时间序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀121-best-time-to-buy-and-sell-stock"><span class="toc-number">21.1.</span> <span class="toc-text">❀121. Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀122-best-time-to-buy-and-sell-stock-ii"><span class="toc-number">21.2.</span> <span class="toc-text">❀122. Best Time to Buy and Sell Stock II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀123-best-time-to-buy-and-sell-stock-iii"><span class="toc-number">21.3.</span> <span class="toc-text">❀123. Best Time to Buy and Sell Stock III</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区间"><span class="toc-number">22.</span> <span class="toc-text">区间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀56-merge-intervals"><span class="toc-number">22.1.</span> <span class="toc-text">❀56. Merge Intervals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀435-non-overlapping-intervals"><span class="toc-number">22.2.</span> <span class="toc-text">❀435. Non-overlapping Intervals</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#顺序模拟"><span class="toc-number">23.</span> <span class="toc-text">顺序模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#717-1-bit-and-2-bit-characters"><span class="toc-number">23.1.</span> <span class="toc-text">717. 1-bit and 2-bit Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#806-number-of-lines-to-write-string"><span class="toc-number">23.2.</span> <span class="toc-text">806. Number of Lines To Write String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#657-robot-return-to-origin"><span class="toc-number">23.3.</span> <span class="toc-text">657. Robot Return to Origin</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">24.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#❀11-container-with-most-water"><span class="toc-number">24.1.</span> <span class="toc-text">❀11. Container With Most Water</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#❀42-trapping-rain-water"><span class="toc-number">24.2.</span> <span class="toc-text">❀42. Trapping Rain Water</span></a></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Linest
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> customized by <a href="#">Linest</a> with <span class="octicon octicon-heart" style="color:red"></span>
				</div>
				<div class="hide">
						<a href="https://clustrmaps.com/site/x7rd" title="Visit tracker"><img src="//clustrmaps.com/map_v2.png?cl=ffffff&w=70&t=n&d=trdgmMc8YDC9aFR4WIBOzfE8f6bNwx_Pq7HA9YiG3sA" /></a>
				</div>
    </div>
  </div>
</footer>

    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true
	}
</script>

<!-- Baidu auto push -->
<script>
(function(){
	var bp = document.createElement('script');
	var curProtocol = window.location.protocol.split(':')[0];
	if (curProtocol === 'https') {
		bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	}
	else {
		bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	}
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(bp, s);
})();
</script>

<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



  </div>
<script>!function(i){var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function r(t,e){var n=new Image,i=t.getAttribute("data-original");n.onload=function(){t.src=i,e&&e()},n.src=i}function t(){for(var t=0;t<o.length;t++)e=o[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(i.innerHeight||document.documentElement.clientHeight)&&r(o[t],function(){o.splice(t,t)});var e,n}t(),i.addEventListener("scroll",t)}(this);</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>